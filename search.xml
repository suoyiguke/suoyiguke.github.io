<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1-4-Collection-子接口之-Queue.md</title>
      <link href="/2022/03/20/1-4-collection-zi-jie-kou-zhi-queue/"/>
      <url>/2022/03/20/1-4-collection-zi-jie-kou-zhi-queue/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>1.4 Collection 子接口之 Queue</p><h3 id="1-4-1-Queue-与-Deque-的区别"><a href="#1-4-1-Queue-与-Deque-的区别" class="headerlink" title="1.4.1 Queue 与 Deque 的区别"></a>1.4.1 Queue 与 Deque 的区别</h3><p>Queue是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p>Queue扩展了 Collection的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值（布尔值或object） 。</p><table><thead><tr><th>Queue接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>boolean offer(E e)  失败返回false</td></tr><tr><td>删除队首</td><td>remove()</td><td>Object poll() 失败返回null</td></tr><tr><td>查询队首元素</td><td>element()</td><td>Object peek() 失败返回null</td></tr></tbody></table><blockquote><p>记忆方法：<br>低级词汇：add、remove、element 会引发异常；<br>高级词汇：offer（插入）、poll（都有o）、peek（都有e） ；会返回特殊值（布尔值或object） </p></blockquote><p>Deque是双端队列，在队列的两端均可以插入或删除元素。</p><p>Deque扩展了 Queue的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th>Deque接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><blockquote><p>事实上，Deque还提供有 push()和 pop()等其他方法，可用于模拟栈。</p></blockquote><h3 id="1-4-2-ArrayDeque-与-LinkedList-的区别"><a href="#1-4-2-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="1.4.2 ArrayDeque 与 LinkedList 的区别"></a>1.4.2 ArrayDeque 与 LinkedList 的区别</h3><p>ArrayDeque和 LinkedList都实现了 Deque接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><p>  ArrayDeque是基于可变长的数组和双指针来实现，而 LinkedList则通过链表来实现。</p></li><li><p>  ArrayDeque不支持存储 NULL数据，但 LinkedList支持。</p><blockquote><p>Qeque、Deque 都不允许存入null。否则报空指针</p></blockquote></li><li><p>  ArrayDeque是在 JDK1.6 才被引入的，而LinkedList早在 JDK1.2 时就已经存在。</p></li><li><p>  ArrayDeque插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p></li></ul><blockquote><p>从性能的角度上，选用 ArrayDeque来实现队列要比 LinkedList更好。此外，ArrayDeque也可以用于实现栈。</p></blockquote><p>###1.4.3 说一说 PriorityQueue</p><p>PriorityQueue是在 JDK1.5 中被引入的, 其与 Queue的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li>  PriorityQueue利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>  PriorityQueue通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>  PriorityQueue是非线程安全的，且不支持存储 NULL和 non-comparable的对象。</li><li>  PriorityQueue默认是小顶堆，但可以接收一个 Comparator作为构造参数，从而来自定义元素优先级的先后。<blockquote><p>其实就是按优先级自定义排序</p></blockquote></li></ul><p>PriorityQueue在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p><pre><code>  PriorityQueue&lt;Integer&gt; objects = new PriorityQueue&lt;&gt;(5,new Comparator&lt;Integer&gt;() &#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                return o1-o2;            &#125;        &#125;);        objects.offer(200);        objects.offer(1);        objects.offer(33);        objects.offer(888);        objects.offer(666);        boolean offer = objects.offer(999);        System.out.println(offer);        while (!objects.isEmpty())&#123;            System.out.println(objects.poll());        &#125;</code></pre><p>###LinkedBlockingDeque<br>LinkedBlockingDeque是BlockingDeque接口唯一的实现类</p><p>使用它来模拟栈</p><pre><code>        LinkedBlockingDeque&lt;Object&gt; objects = new LinkedBlockingDeque&lt;&gt;(3);        objects.push(1);        objects.push(2);        objects.push(3);        Object pop = objects.pop();        //3        System.out.println(pop);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7种遍历hashMap的方式那种最好？.md</title>
      <link href="/2022/03/20/7-chong-bian-li-hashmap-de-fang-shi-na-chong-zui-hao/"/>
      <url>/2022/03/20/7-chong-bian-li-hashmap-de-fang-shi-na-chong-zui-hao/</url>
      
        <content type="html"><![CDATA[<p>HashMap 遍历从大的方向来说，可分为以下 4 类：</p><p>迭代器（Iterator）方式遍历；<br>For Each 方式遍历；<br>Lambda 表达式遍历（JDK 1.8+）;<br>Streams API 遍历（JDK 1.8+）。<br>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；<br>使用迭代器（Iterator）KeySet 的方式进行遍历；<br>使用 For Each EntrySet 的方式进行遍历；<br>使用 For Each KeySet 的方式进行遍历；<br>使用 Lambda 表达式的方式进行遍历；<br>使用 Streams API 单线程的方式进行遍历；<br>使用 Streams API 多线程的方式进行遍历。</p><p>本文我们讲了 HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，我们应该尽量使用迭代器（Iterator）来遍历 EntrySet 的遍历方式来操作 Map 集合，这样就会既安全又高效了。</p><pre><code>        // 创建并赋值 HashMap        Map&lt;Integer, String&gt; map = new HashMap();        map.put(1, &quot;Java&quot;);        map.put(2, &quot;JDK&quot;);        map.put(3, &quot;Spring Framework&quot;);        map.put(4, &quot;MyBatis framework&quot;);        map.put(5, &quot;Java中文社群&quot;);        // 遍历        Iterator&lt;Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();        while (iterator.hasNext()) &#123;            Map.Entry&lt;Integer, String&gt; entry = iterator.next();            System.out.println(entry.getKey());            System.out.println(entry.getValue());        &#125;</code></pre><p>###3.Lambda 方式</p><p>小结<br>我们不能在遍历中使用集合 map.remove() 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 iterator.remove() 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 removeIf 来提前删除数据，或者是使用 Stream 中的 filter 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 for 循环前删除数据在遍历也是线程安全的。</p><p>总结<br>本文我们讲了 HashMap 4 大类(迭代器、for、lambda、stream)遍历方式，以及具体的 7 种遍历方法，<strong>除了 Stream 的并行循环</strong>，其他几种遍历方法的性能差别不大，但从简洁性和优雅性上来看，Lambda 和 Stream 无疑是最适合的遍历方式。除此之外我们还从「安全性」方面测试了 4 大类遍历结果，从安全性来讲，我们应该使用迭代器提供的 iterator.remove() 方法来进行删除，这种方式是安全的在遍历中删除集合的方式，或者使用 Stream 中的 filter 过滤掉要删除的数据再进行循环，也是安全的操作方式。</p><p>总体来说，本文提供了 7 种方式肯定也不是最全的，我是想给读者在使用 HashMap 时多一种选择，然而选择那一种形式的写法，要综合：性能、安全性、使用环境的 JDK 版本以及优雅性和可读性等方面来综合考虑。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-种基本类型的包装类和常量池.md</title>
      <link href="/2022/03/20/8-chong-ji-ben-lei-xing-de-bao-zhuang-lei-he-chang-liang-chi/"/>
      <url>/2022/03/20/8-chong-ji-ben-lei-xing-de-bao-zhuang-lei-he-chang-liang-chi/</url>
      
        <content type="html"><![CDATA[<p>Java 基本类型的包装类的大部分都实现了常量池技术。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p><p><strong>Integer 缓存源码：</strong></p><pre><code>/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/public static Integer valueOf(int i) &#123;    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)      return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);&#125;private static class IntegerCache &#123;    static final int low = -128;    static final int high;    static final Integer cache[];&#125;</code></pre><p><strong><code>Character</code> 缓存源码:</strong></p><pre><code>public static Character valueOf(char c) &#123;    if (c &lt;= 127) &#123; // must cache      return CharacterCache.cache[(int)c];    &#125;    return new Character(c);&#125;private static class CharacterCache &#123;    private CharacterCache()&#123;&#125;    static final Character cache[] = new Character[127 + 1];    static &#123;        for (int i = 0; i &lt; cache.length; i++)            cache[i] = new Character((char)i);    &#125;&#125;</code></pre><p><strong><code>Boolean</code> 缓存源码：</strong></p><pre><code>public static Boolean valueOf(boolean b) &#123;    return (b ? TRUE : FALSE);&#125;</code></pre><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p><pre><code>Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueFloat i11 = 333f;Float i22 = 333f;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false</code></pre><p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>flase</code> 呢？</p><pre><code>Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2);</code></pre><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。你答对了吗？</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。<br><a href="https://camo.githubusercontent.com/1787ac3ea56e56450b185b8e6dccb0bfd4ce60cafe05ffdecf31f3e64c833724/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303432323136343534343834362e706e67"><img src="https://upload-images.jianshu.io/upload_images/13965490-462db0b814071f82?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array、Set、List互相转.md</title>
      <link href="/2022/03/20/array-set-list-hu-xiang-zhuan/"/>
      <url>/2022/03/20/array-set-list-hu-xiang-zhuan/</url>
      
        <content type="html"><![CDATA[<ol><li>数组转化为List：<pre><code>String[] strArray= new String[]&#123;&quot;Tom&quot;, &quot;Bob&quot;, &quot;Jane&quot;&#125;;List strList= Arrays.asList(strArray);</code></pre>List转数组<pre><code>toArray()</code></pre></li></ol><ol start="2"><li>数组转Set<br>~~~<br>String[] strArray= new String[]{“Tom”, “Bob”, “Jane”};<br>Set<String> staffsSet = new HashSet&lt;&gt;(Arrays.asList(staffs));</li></ol><p>staffsSet.add(“Mary”); // ok<br>staffsSet.remove(“Tom”); // ok</p><pre><code>3. List转Set</code></pre><p>String[] staffs = new String[]{“Tom”, “Bob”, “Jane”};<br>List staffsList = Arrays.asList(staffs);<br>Set result = new HashSet(staffsList);</p><pre><code>4. set转List</code></pre><p>String[] staffs = new String[]{“Tom”, “Bob”, “Jane”};<br>Set<String> staffsSet = new HashSet&lt;&gt;(Arrays.asList(staffs));<br>List<String> result = new ArrayList&lt;&gt;(staffsSet);</p><pre><code> </code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigDecimal.md</title>
      <link href="/2022/03/20/bigdecimal/"/>
      <url>/2022/03/20/bigdecimal/</url>
      
        <content type="html"><![CDATA[<p>###compareTo比较<br>compareTo也说得很详细，数值相同但是精度不同的两个数（例如2.0和2.00）被认为是相等的两个数，返回0。另外对于a.compareTo(b)方法</p><p>a&lt;b, 返回-1</p><p>a=b，返回0</p><p>a&gt;b, 返回1</p><p>###divide</p><p>除法</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-hashCode和equals方法与对象比较和去重(一).md</title>
      <link href="/2022/03/20/java-hashcode-he-equals-fang-fa-yu-dui-xiang-bi-jiao-he-qu-chong-yi/"/>
      <url>/2022/03/20/java-hashcode-he-equals-fang-fa-yu-dui-xiang-bi-jiao-he-qu-chong-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>事实胜于雄辩</p></blockquote><p>###什么时候需要重写hashCode 和 equals 方法呢？</p><blockquote><p>如果想使用equals比较对象，那么请将equals方法和hashCode方法重写</p></blockquote><p>######情景模式一<br><code>在使用Set进行集合元素去重的时候，请将hashCode 和 equals 方法重写。</code></p><p>如下代码，不重写hashCode 和 equals 。看看使用set是否能去重成功</p><pre><code>package io.renren;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.Set;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,                new Test(1,&quot;yinkai&quot;,23),                new Test(1,&quot;yinkai&quot;,23),                new Test(2,&quot;yinkai&quot;,25)        );        Set&lt;Test&gt; set = new HashSet&lt;&gt;(list);        System.out.println(set);    &#125;&#125;</code></pre><p>可以看到list里有两个new Test(1,”yinkai”,23)，那么使用set去重应该能够干掉一个。运行程序，打印如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-df829b4d0196706e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>还是存在两个相同的对象<br>那么，我们再使用idea生成下两个方法，代码如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-ee1f131d899a096f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>之后的代码如下</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Test test = (Test) o;        return Objects.equals(id, test.id) &amp;&amp;                Objects.equals(name, test.name) &amp;&amp;                Objects.equals(age, test.age);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(id, name, age);    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,                new Test(1,&quot;yinkai&quot;,23),                new Test(1,&quot;yinkai&quot;,23),                new Test(2,&quot;yinkai&quot;,25)        );        Set&lt;Test&gt; set = new HashSet&lt;&gt;(list);        System.out.println(set);    &#125;&#125;</code></pre><p>再次运行程序如下：<br><img src="https://upload-images.jianshu.io/upload_images/13965490-e0d8bf0f1db2f6f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>问题完美解决 ~</p><p>######情景模式二<br><code>使用自定义对象作为作为 Map 的键，请将 hashCode 和 equals方法重写。</code></p><p>如下代码，若不重写 hashCode 和 equals方法看看会发生什么情况~</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        HashMap&lt;Test,Object&gt; hashMap = new HashMap&lt;Test,Object&gt;() &#123;&#123;           put(new Test(1,"yinkai",23),1);           put(new Test(1,"yinkai",23),1);           put(new Test(3,"yinkai",25),1);        &#125;&#125;;        System.out.println(hashMap);    &#125;&#125;</code></pre><p>上面的代码两次将new Test(1,”yinkai”,23)作为HashMap的key，而我们知道HashMap的key是不会重复的。但是运行下程序：<br><img src="https://upload-images.jianshu.io/upload_images/13965490-b7f669b62f24658f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可见这个HashMap的key在这种情况是重复的，其实此时HashMap它自己认为二者key是不相同的，因为HashMap内部判断key是否重复的算法仅仅使用的是对象的引用。而我们程序员希望它根据字段来判断是否重复。</p><p>那么，我们使用idea生成一下Test类的hashCode 和 equals 方法，代码如下：</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Test test = (Test) o;        return Objects.equals(id, test.id) &amp;&amp;                Objects.equals(name, test.name) &amp;&amp;                Objects.equals(age, test.age);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(id, name, age);    &#125;    public static void main(String[] args) &#123;        HashMap&lt;Test,Object&gt; hashMap = new HashMap&lt;Test,Object&gt;() &#123;&#123;           put(new Test(1,"yinkai",23),1);           put(new Test(1,"yinkai",23),1);           put(new Test(3,"yinkai",25),1);        &#125;&#125;;        System.out.println(hashMap);    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-ccc8bcc0e5592ec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>ok，现在key总算是不重复了</p><p>###为什么使用equals比较对象就要将 hashCode 和 equals 方法一起重写？</p><p>我们可以看看Object类的源码。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-b641867bd0543563.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面例子中的两个new Test(1,”yinkai”,23) 对象的引用的确是不同的，但是引用的比较对我们来说根本没有意义，我们需要使用Test中的id,name,age字段一起进行比较！</p><blockquote><p>Object基类的equals方法的确只是比较对象的引用，但是我们程序员希望根据业务字段来进行比较。</p></blockquote><p>那么可能有人就会问了，既然需要比较业务字段，那重写equals 就行了呀，为什么还要重写hashCode呢？<br>是的，如果单单只是使用equals来判断俩对象是否相等，我们可以不去重写hashCode，看代码：</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Test test = (Test) o;        return Objects.equals(id, test.id) &amp;&amp;                Objects.equals(name, test.name) &amp;&amp;                Objects.equals(age, test.age);    &#125;    public static void main(String[] args) &#123;        System.out.println(new Test(1,&quot;yinkai&quot;,23) .equals(new Test(1,&quot;yinkai&quot;,23)) );    &#125;&#125;</code></pre><p>程序打印 true ，若按字段比较两个对象是相等的</p><p> <code>但是，我们要在 HashMap、HashTable 的 key 和 HashSet 这种容器中使用时就必须重写hashCode方法了！</code></p><p>在上面程序中添加一行代码，打印下两个字段相同对象的hashCode数值是否相同</p><pre><code>System.out.println(new Test(1,&quot;yinkai&quot;,23).hashCode() == new Test(1,&quot;yinkai&quot;,23).hashCode());</code></pre><p>打印了false，可见如果不重写hashCode。那么两个new Test(1,”yinkai”,23)对象的hashCode()方法返回值是不同的。</p><p>很巧的是，HashMap和HashTable都是使用对象的hashCode()方法和equals 方法一起来进行key键对象重复判断的。我们可以看看HashMap put方法的源码：</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-694aa59faf431f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这里调用了hash()方法，进去看看这个<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c3ec4ad01745c382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>不出所料，的确是使用了hashCode。在跟进去putval看看<br><img src="https://upload-images.jianshu.io/upload_images/13965490-2fd176e88eab27c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>已经很清晰了，hashCode和equals 一起用在了HashMap的key键的重复判断中。</p><p>由此可见在 HashMap、HashTable 的 key 和 HashSet中必须将hashCode和equals 一起重写。如果违背这个原则，那么后果就是HashMap、HashTable 的key重复，HashSet无法完成去重任务。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？.md</title>
      <link href="/2022/03/20/java-fan-xing-liao-jie-me-shi-me-shi-lei-xing-ca-chu-jie-shao-yi-xia-chang-yong-de-tong-pei-fu/"/>
      <url>/2022/03/20/java-fan-xing-liao-jie-me-shi-me-shi-lei-xing-ca-chu-jie-shao-yi-xia-chang-yong-de-tong-pei-fu/</url>
      
        <content type="html"><![CDATA[<p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><pre><code>    public static void main(String[] args)        throws  NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(12);        //这里直接添加会报错        //list.add(&quot;a&quot;);        Class&lt;? extends List&gt; clazz = list.getClass();        Method add = clazz.getDeclaredMethod(&quot;add&quot;, Object.class);        //但是通过反射添加，是可以的        add.invoke(list, &quot;kl&quot;);        System.out.println(list);    &#125;</code></pre><p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p><p>1.泛型类：</p><pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt; &#123;    private T key;    public Generic(T key) &#123;        this.key = key;    &#125;    public T getKey() &#123;        return key;    &#125;    public static void main(String[] args) &#123;        Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);        //自动获取Integer的eky        Integer key1 = genericInteger.getKey();        Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;HELLO&quot;);        //自动获取Integer的eky        String key2 = genericString.getKey();    &#125;&#125;</code></pre><p>2.泛型接口 ：</p><pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public interface Generator&lt;T&gt; &#123;    public T method();&#125;/** * 实现泛型接口，不指定类型 */class GeneratorImplA&lt;T&gt; implements Generator&lt;T&gt;&#123;    @Override    public T method() &#123;        return null;    &#125;&#125;/** * 实现泛型接口，指定类型 */class GeneratorImplB&lt;T&gt; implements Generator&lt;String&gt;&#123;    @Override    public String method() &#123;        return &quot;hello&quot;;    &#125;&#125;class Main&#123;    public static void main(String[] args) &#123;        GeneratorImplA&lt;Integer&gt;  generatorImplA = new GeneratorImplA&lt;&gt;();        //传入Integer泛型，获取了Integer类型值        Integer method = generatorImplA.method();        //实现类本身是指定了String的泛型，返回就是String        Generator&lt;String&gt; stringGenerator = new GeneratorImplB&lt;&gt;();        String method2 = stringGenerator.method();    &#125;&#125;</code></pre><p>3、泛型方法</p><pre><code>class Main &#123;    public static &lt;E&gt; void printArray(E[] inputArray) &#123;        for (E element : inputArray) &#123;            System.out.printf(&quot;%s &quot;, element);        &#125;        System.out.println();    &#125;    public static void main(String[] args) &#123;        // 创建不同类型数组： Integer, Double 和 Character        Integer[] intArray = &#123; 1, 2, 3 &#125;;        String[] stringArray = &#123; &quot;Hello&quot;, &quot;World&quot; &#125;;        printArray( intArray  );        printArray( stringArray  );    &#125;&#125;</code></pre><p>**常用的通配符为： T，E，K，V，？</p><p>？ 表示不确定的 java 类型<br>T (type) 表示具体的一个 java 类型<br>K V (key value) 分别代表 java 键值中的 Key Value<br>E (element) 代表 Element</p><p><strong>? T 区别：</strong><br>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects-equals-比较Long和Integer-一定记得加L.md</title>
      <link href="/2022/03/20/objects-equals-bi-jiao-long-he-integer-yi-ding-ji-de-jia-l/"/>
      <url>/2022/03/20/objects-equals-bi-jiao-long-he-integer-yi-ding-ji-de-jia-l/</url>
      
        <content type="html"><![CDATA[<p> if (Objects.equals(1L, groupListSize)) {<br><img src="https://upload-images.jianshu.io/upload_images/13965490-85d8db3ce824e1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongAdder与AtomicLong有什么区别？.md</title>
      <link href="/2022/03/20/longadder-yu-atomiclong-you-shi-me-qu-bie/"/>
      <url>/2022/03/20/longadder-yu-atomiclong-you-shi-me-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>LongAdder与AtomicLong有什么区别？<br>参考答案</p><ul><li>AtomicLong 是基于 CAS 方式自旋更新的；</li></ul><p>LongAdder 是把 value 分成若干cell，并发量低的时候，直接 CAS 更新值，成功即结束。并发量高的情况，CAS更新某个cell值和需要时对cell数据扩容，成功结束；更新失败自旋 CAS 更新 cell值。取值的时候，调用 sum() 方法进行每个cell累加。</p><ul><li>AtomicLong 包含有原子性的读、写结合的api；LongAdder 没有原子性的读、写结合的api，能保证结果最终一致性。</li><li>低并发场景AtomicLong 和 LongAdder 性能相似，高并发场景 LongAdder 性能优于 AtomicLong。</li></ul><p>###LongAdder求和<br>LongAdder的思想其实和之前的 数据库表实现计数器是一样的！<br>多个卡槽，随机update。最后sum求和+ </p><pre><code>    /**     * Returns the current sum.  The returned value is &lt;em&gt;NOT&lt;/em&gt; an     * atomic snapshot; invocation in the absence of concurrent     * updates returns an accurate result, but concurrent updates that     * occur while the sum is being calculated might not be     * incorporated.     *     * @return the sum     */    public long sum() &#123;        Cell[] as = cells; Cell a;        long sum = base;        if (as != null) &#123;            for (int i = 0; i &lt; as.length; ++i) &#123;                if ((a = as[i]) != null)                    sum += a.value;            &#125;        &#125;        return sum;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map-批量remove.md</title>
      <link href="/2022/03/20/map-pi-liang-remove/"/>
      <url>/2022/03/20/map-pi-liang-remove/</url>
      
        <content type="html"><![CDATA[<p>saveMap.keySet().removeAll(errMap.keySet());</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>article-title.md</title>
      <link href="/2022/03/20/article-title/"/>
      <url>/2022/03/20/article-title/</url>
      
        <content type="html"><![CDATA[<hr><p>title: article title<br>top: false<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2022-03-20 18:54:13<br>password:<br>summary:<br>tags:<br>categories:</p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>assertTrue、assertEquals.md</title>
      <link href="/2022/03/20/asserttrue-assertequals/"/>
      <url>/2022/03/20/asserttrue-assertequals/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eques.md</title>
      <link href="/2022/03/20/eques/"/>
      <url>/2022/03/20/eques/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>forEachRemaining继续输出其余的元素.md</title>
      <link href="/2022/03/20/foreachremaining-ji-xu-shu-chu-qi-yu-de-yuan-su/"/>
      <url>/2022/03/20/foreachremaining-ji-xu-shu-chu-qi-yu-de-yuan-su/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java--jar-运行，带引号解决参数中包含等号的问题.md</title>
      <link href="/2022/03/20/java-jar-yun-xing-dai-yin-hao-jie-jue-can-shu-zhong-bao-han-deng-hao-de-wen-ti/"/>
      <url>/2022/03/20/java-jar-yun-xing-dai-yin-hao-jie-jue-can-shu-zhong-bao-han-deng-hao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>java -jar identityauthsrv-1.0.5-base-linux-release.jar –spring.datasource.url=”jdbc:mysql://localhost:3306/iam?characterEncoding=utf8&amp;useSSL=false” –server.port=8077 </p><pre><code>java -jar ruoyi-admin.jar --server.port=8081 --business.apk.apkPath=&quot;file:/home/ca/iam-vue/apk&quot; --business.pdf.basePath=&quot;/home/ca/pdfstone&quot; </code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first.md</title>
      <link href="/2022/03/20/first/"/>
      <url>/2022/03/20/first/</url>
      
        <content type="html"><![CDATA[<hr><p>title: first<br>top: false<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2021-05-02 18:45:23<br>password:<br>summary:<br>tags:<br>categories:</p><hr><p>###first</p><p><img src="./kw.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-8中使用Optional-避免空指针.md</title>
      <link href="/2022/03/20/java-8-zhong-shi-yong-optional-bi-mian-kong-zhi-zhen/"/>
      <url>/2022/03/20/java-8-zhong-shi-yong-optional-bi-mian-kong-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Optional 类的引入要求程序员强制处理和避免空指针。Optional 需要使用在可能为null的变量上。很多时候，程序员都是不判空的，这些BUG就像定时炸弹一样，使用Optional 类等于强迫程序员做好判空处理，减少可能的损失。</p></blockquote><p>Optional 类的设计是十分必要的，提前处理可能发生的错误，而不是等到逻辑处理完了再报告错误。<br>如果返回的null不会终止代码逻辑的运行，比如Java的Map的get方法传了错误类型的key返回null，那么开发者可能会花大量的时间去定位错误的原因，尤其是对于那些庞大的系统来说，无疑是大海捞针。<br>Scala、lisp、hashshell、erlang等函数式编程语言无一例外地，都对NullPointerException进行了处理，都有Optional的概念，Java8是借鉴了他们。 </p><p>###阿里手册中也提到我们需要使用 Optional 类<br>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<br>1）  返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。<br> 反例：<br>public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。<br>2） 数据库的查询结果可能为 null。<br>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。<br>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。<br>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。<br>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。<br>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p><p>###Optional 使用思路<br>解决办法就是3个步骤：<br>• 包装value：of(x)传入的对象不能为null，而ofNullable(x)是支持传入null的对象，一般用使用<code>Optional.ofNullable()</code>。<br>• 逐层安全地拆解value：map()。<br>• 最终返回：orElse()/orElseGet()/orElseThrow()。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-d4b848d63b4ec476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###使用示例<br>Person 类</p><pre><code>public class Person &#123;    private String name;    private Integer age;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +            &quot;, age=&quot; + age +            &#39;&#125;&#39;;    &#125;&#125;</code></pre><p><strong>用法1、使用内部的ofNullable去掉if的写法，将返回值set到其它对象</strong><br>我比喜欢用这个方法，毕竟不要写if xx!=null 。可以直接在ifPresent() 小括号里写各种逻辑。</p><pre><code>    public static void main(String[] args) &#123;        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, &quot;kawai&quot;);        objectObjectHashMap.put(&quot;age&quot;, 18);        Person a = new Person();        //TODO 使用内部的ifPresent避免了空指针异常        Optional.ofNullable(objectObjectHashMap.get(&quot;name1&quot;))            .ifPresent(name -&gt; a.setName(name.toString().toUpperCase()));        Optional.ofNullable(objectObjectHashMap.get(&quot;age1&quot;))            .ifPresent(age -&gt; a.setAge(Integer.valueOf(age.toString()) + 18));        System.out.println(a);    &#125;</code></pre><p><strong>用法2、链式调用map()方法。消除多重if xxx!=null; 嵌套</strong><br>想要实现a、b、c三个变量的加法乘法的组合运算。但是三个变量都有可能为null。所以需要加三层if判断：</p><pre><code>Integer a = getA(); if (a != null) &#123;  Integer b = getB();  if ( b != null) &#123;    Integer c = getC();    if ( c != null) &#123;      return (a + b) * c;    &#125; else return null;  &#125; else return null;&#125; else return null;</code></pre><p>改写成这样，是不是简洁很多了？</p><pre><code>Optional&lt;Integer&gt; result = Optional.ofNullable(getA())                             .flatMap(a   -&gt; Optional.ofNullable(getB()).map( b -&gt; a + b ))                             .flatMap(sum -&gt; Optional.ofNullable(getC()).map( c -&gt; sum * c ))</code></pre><p><strong>用法3、使用orElse，为null则返回默认值</strong> </p><pre><code>    static class UserMapper &#123;        public static BizUser selectBizUserByEmployeeNum(String employeeNum) &#123;            return null;        &#125;    &#125;    public static Integer run() &#123;        BizUser user = UserMapper.selectBizUserByEmployeeNum(&quot;3306&quot;);        return Optional.ofNullable(user).map(BizUser::getDeptId)            .filter(deptId -&gt; deptId.intValue() != 0).orElse(1122);    &#125;    public static void main(String[] args) &#123;        Integer run = run();        System.out.println(run);    &#125;</code></pre><p><strong>用法4、使用orElseThrow，为null则抛出异常到上层中断执行</strong></p><pre><code>    static class UserMapper&#123;        public static BizUser selectBizUserByEmployeeNum(String employeeNum) &#123;            return null;        &#125;    &#125;    public static void main(String[] args) &#123;        BizUser user = UserMapper.selectBizUserByEmployeeNum(&quot;3306&quot;);        Optional.ofNullable(user).map(BizUser::getDeptId).filter(deptId -&gt; deptId.intValue() != 0)            .orElseThrow(() -&gt; new CustomException(&quot;查询到的user为空！&quot;));    &#125;</code></pre><p><strong>用法5、使用filter完成除非空判断以外的其它判断</strong><br>另外，如果你需要对返回值进行判断，比如结果是否大于某个值等，可以使用Optional的filter方法。</p><pre><code>        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, &quot;kawai&quot;);        objectObjectHashMap.put(&quot;age&quot;, 19);        //TODO 使用内部的ifPresent避免了空指针异常        Object a = Optional.ofNullable(objectObjectHashMap.get(&quot;age&quot;))            .filter(age -&gt; Integer.parseInt(age.toString()) &gt;= 18).orElse(18);        System.out.println(a);</code></pre><p>###来看看错误用法（滥用Optional）</p><p><strong>错误用法1、把if xx！=null 换成了 name1.isPresent()</strong><br>这种方法和if xx！=null 差不多，还有if条件。不好用！把isPresent()当做判断空指针的方法，又回归以前的if嵌套，毫无意义 。 个人觉得isPresent()不应该暴露出来，放在Optional内部使用更好。</p><pre><code>public static void main(String[] args) &#123;        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, &quot;小明&quot;);        objectObjectHashMap.put(&quot;age&quot;, 18);        Person a = new Person();        Optional&lt;Object&gt; name1 = Optional.ofNullable(objectObjectHashMap.get(&quot;name1&quot;));        if (name1.isPresent()) &#123;            a.setName(name1.get().toString().toUpperCase());        &#125;        Optional&lt;Object&gt; age = Optional.ofNullable(objectObjectHashMap.get(&quot;age1&quot;));        if (age.isPresent()) &#123;            a.setAge(Integer.valueOf(age.get().toString()) + 18);        &#125;        System.out.println(a);    &#125;&#125;</code></pre><p><strong>错误用法2、这样还是会出现空指针，因为get()后返回的就是裸露的值</strong></p><pre><code>    public static void main(String[] args) &#123;        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, null);        objectObjectHashMap.put(&quot;age&quot;, 18);        Person a = new Person();        //TODO 下面的语句还是会报空指针NoSuchElementException，get()方法返回的是裸露的值。        String name = Optional.ofNullable(objectObjectHashMap.get(&quot;name&quot;)).get().toString()            .toUpperCase();        a.setName(name);        Optional.ofNullable(objectObjectHashMap.get(&quot;age&quot;))            .ifPresent(age -&gt; a.setAge(Integer.valueOf(age.toString()) + 18));        System.out.println(a);    &#125;</code></pre><blockquote><p>注意：请不要直接使用get()方法获得值，因为它还是会造成空指针。</p></blockquote><p><strong>错误用法3、被Optional.ofNullable()包装的表达式这样写照样出现空指针</strong></p><pre><code>Optional.ofNullable(((Integer) null).toString()).orElse(&quot;123&quot;);</code></pre><p>请使用map()函数把toString()方法单独提出来。</p><pre><code>Optional.ofNullable(((Integer) null)).map(m-&gt;m.toString()).orElse(&quot;123&quot;);</code></pre><p>###orElse和orElseGet有什么区别？</p><p>对比下面代码的执行结果：<br>eg1</p><pre><code>    private static Integer query()&#123;        System.out.println(&quot;查询值&quot;);        return 1122;    &#125;    public static void main(String[] args) &#123;        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(1);        map.put(&quot;age1&quot;,1);        System.out.println(Optional.ofNullable(map.get(&quot;age1&quot;)).orElse(query())) ;    &#125;</code></pre><blockquote><p>查询值<br>1122</p></blockquote><p>eg2</p><pre><code>    private static Integer query()&#123;        System.out.println(&quot;查询值&quot;);        return 1122;    &#125;    public static void main(String[] args) &#123;        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(1);        map.put(&quot;age1&quot;,1);        System.out.println(Optional.ofNullable(map.get(&quot;age1&quot;)).orElseGet(()-&gt;query())) ;    &#125;</code></pre><blockquote><p>1</p></blockquote><p>显然，当ofNullable内部参数非空时，不会去调用默认值里的方法去获取默认值。这也算是一个优化。若query()方法实现是一个网络请求或者数据库操作这样的耗时操作。那么这里请使用orElseGet而不是orElse！<br>当然若默认值只是一个常量，那么使用orElse语法更简洁。</p><p>###使用注意<br><strong>不能使用Optional到java bean的属性中</strong><br>由于Optional并没有实现Serializable接口，所以不推荐直接作为pojo字段使用。</p><p><strong>不推荐将方法返回值设置为Optional</strong><br>虽然Optional能够防止空指针，有些类里的方法强制把返回值都定为Optional类型。<br>1、比如java8的stream流api<br>java.util.stream.Stream</p><pre><code>    Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</code></pre><p>2、JPA返回值就是Optional。</p><p>3、但是我们平时工作还是不用使用他为返回值比较好。作为内部方法的返回值，免去调用时手动包装，但这意味着强制调用者使用Optional，但不是所有人都会用这个东西。</p><p>应该把Optional当做一个简单的工具类，是一个纯主观意愿的。想用就用吧，咱也不强制别人用。</p><p>###其它三个类OptionalDouble、OptionalInt、OptionalLong<br>自己用的比较少。<br>它们的of方法形参是基本类型的，也就是说传null会报空指针：</p><pre><code>    /**     * Return an &#123;@code OptionalInt&#125; with the specified value present.     *     * @param value the value to be present     * @return an &#123;@code OptionalInt&#125; with the value present     */    public static OptionalInt of(int value) &#123;        return new OptionalInt(value);    &#125;</code></pre><p>主要了解它们的getAsInt()、getAsDouble()、getAsLong() 方法。</p><pre><code>    public static void main(String[] args) &#123;        OptionalInt op = OptionalInt.of(0);        if (op.isPresent())&#123;            //获得OptionalInt对象里面的值，输出1            System.out.println(op.getAsInt());        &#125;        op.ifPresent((value) -&gt; System.out.println(&quot;value：&quot; + value));        //创建一个空值对象        OptionalInt opint = OptionalInt.empty();        if (opint.isPresent()) &#123;            //和Optional一样，输出No value present            System.out.println(opint.getAsInt());        &#125; else &#123;            //如果没有值，赋初始值            System.out.println(opint.orElse(222));            //如果没有值，赋初始函数            System.out.println(opint.orElseGet(() -&gt; 333));        &#125;        //如果没有值则抛出异常        opint.orElseThrow(NullPointerException::new);    &#125;</code></pre><p>###实践</p><p>1、解析json</p><pre><code>    public static void main(String[] args) &#123;        String json = &quot;&#123;\n&quot;            + &quot;    \&quot;responseResult\&quot;: &#123;\n&quot;            + &quot;        \&quot;status\&quot;: 0,\n&quot;            + &quot;        \&quot;msg\&quot;: \&quot;成功\&quot;\n&quot;            + &quot;    &#125;,\n&quot;            + &quot;    \&quot;contents\&quot;: &#123;\n&quot;            + &quot;        \&quot;total\&quot;: 1,\n&quot;            + &quot;        \&quot;currentRowsSize\&quot;: 1,\n&quot;            + &quot;        \&quot;rows\&quot;: [\n&quot;            + &quot;            &#123;\n&quot;            + &quot;                \&quot;id\&quot;: 551,\n&quot;            + &quot;                \&quot;name\&quot;: \&quot;学生二\&quot;,\n&quot;            + &quot;                \&quot;phone\&quot;: \&quot;15099955982\&quot;\n&quot;            + &quot;            &#125;\n&quot;            + &quot;        ]\n&quot;            + &quot;    &#125;\n&quot;            + &quot;&#125;&quot;;        final String[] msg = &#123;&quot;&quot;&#125;;        JSONObject jsonObject = JSONObject.parseObject(json);        Optional.ofNullable(jsonObject)            .map(m1 -&gt; m1.getJSONObject(&quot;responseResult&quot;))            .filter(m2 -&gt; &#123;                msg[0] = m2.getString(&quot;msg&quot;);                return m2.getInteger(&quot;status&quot;) == 0;            &#125;)            .orElseThrow(() -&gt; new RuntimeException(String.format(&quot;netca 获取授权list失败，%s&quot;, msg[0])));        JSONArray objects = Optional.ofNullable(jsonObject).map(m -&gt; m.getJSONObject(&quot;contents&quot;))            .map(m -&gt; m.getJSONArray(&quot;rows&quot;))            .orElseThrow(() -&gt; new RuntimeException(&quot;netca 获取授权list失败，miss contents.rows&quot;));        System.out.println(objects);    &#125;</code></pre><p>2、下面demo展示如何在流获取时兼顾多个字段。这里有：m.getString(“msg”)和 m.getInteger(“status”)<br>在map内部得到json返回值的msg字段，并见它赋值给 msg[0]。随后在Throw Exception中用到。</p><blockquote><p>还有可以注意的是判断json返回状态码的写法</p></blockquote><pre><code>        jsonObject = Optional.ofNullable(JSON.parseObject(respResult))            .map(m -&gt; m.getJSONObject(&quot;responseResult&quot;)).map(m -&gt; &#123;                msg[0] = m.getString(&quot;msg&quot;);                return m;            &#125;)            .filter(m -&gt; m.getInteger(&quot;status&quot;) == 0)            .orElseThrow(                () -&gt; new CloudsignException(-15,                    String.format(&quot;netca授权签名获得授权人userToken失败,%s&quot;, msg[0])));</code></pre><p>3、Optional.map()，只能一条路走到黑，顶多使用 m-&gt;{return m } 获取同级别的节点。但是绝对不能回头。如果想走两条路，那么请用两个 Optional.ofNullable。暂时我也没找到更好的办法。<br>下面有两条路。一条路拿responseResult.status/responseResult.msg；一条路拿contents.signCert；<br>所以用了两次 <code>Optional.ofNullable</code></p><pre><code>        JSONObject jsonObject = JSONObject.parseObject(respResult);        Optional.ofNullable(jsonObject)            .map(m -&gt; m.getJSONObject(&quot;responseResult&quot;)).map(m -&gt; &#123;                msg[0] = m.getString(&quot;msg&quot;);                return m;            &#125;)            .filter(m -&gt; m.getInteger(&quot;status&quot;) == 0).orElseThrow(                () -&gt; new CloudsignException(-12,                    String.format(&quot;netca 获取base64cert失败,%s&quot;, msg[0])));        String signCert = Optional            .ofNullable(jsonObject)            .map(m -&gt; m.getJSONArray(&quot;contents&quot;)).map(m -&gt; m.getJSONObject(0))            .map(m -&gt; m.getString(&quot;signCert&quot;))            .orElseThrow(                () -&gt; new CloudsignException(-13, &quot;netca 获取base64cert失败，miss contents.signCert&quot;));</code></pre><p>4、</p><pre><code>    public static String getDescByCode(Integer code, UserEnum userEnum) &#123;        final Map&lt;Integer, SignedReturnOption&gt; all = getAll();        if (all.keySet().contains(code)) &#123;            final SignedReturnOption signedReturnOption = all.get(code);            return Optional.ofNullable(signedReturnOption).map(m -&gt; m.userEnum.equals(userEnum) ? signedReturnOption.desc : Constant.NOT_ME).orElse(null);        &#125;        return null;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-9、11、17.md</title>
      <link href="/2022/03/20/java-9-11-17/"/>
      <url>/2022/03/20/java-9-11-17/</url>
      
        <content type="html"><![CDATA[<p>1、9的dropWhile方法与filter的区别</p><pre><code>        System.out.println(&quot;dropWhile方法&quot;);        //abcde        Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,            &quot;d&quot;, &quot;e&quot;).dropWhile(name -&gt; (name.charAt(0) != &#39;a&#39;)).forEach(System.out::print);        System.out.println();        System.out.println(&quot;filter方法&quot;);        //a        Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,            &quot;d&quot;, &quot;e&quot;).filter(name -&gt; (name.charAt(0) == &#39;a&#39;)).forEach(System.out::print);</code></pre><p>dropWhile丢弃条件所在集合开头的所有项目true。一旦第一项失败，它就会停止丢弃。<br>filter丢弃整个集合中条件不正确的所有项目。它直到收集结束才停止。</p><p>2、9的takeWhile</p><p>Stream中依次获取满足条件的元素，直到不满足条件为止结束获取<br>举例：Stream中的元素 12, 4, 3, 6, 8, 9<br>条件是 x -&gt; x % 2 == 0 ，即判断是否为偶数，即当遇到元素不为偶数时终止获取<br>那么得到的结果输出就是，12, 4 因为下一个元素为3不为偶数，即结束获取，丢弃后面的其他元素</p><pre><code>IntStream.of(12, 4, 3, 6, 8, 9).takeWhile(x -&gt; x % 2 == 0).forEach(System.out::print);</code></pre><p>3、JDK12提供的新聚合方法<br>//流分别经过downstream1、downstream2聚合处理，再合并两聚合结果<br>public static &lt;T, R1, R2, R&gt; Collector&lt;T, ?, R&gt; teeing(<br>        Collector&lt;? super T, ?, R1&gt; downstream1,<br>        Collector&lt;? super T, ?, R2&gt; downstream2,<br>        BiFunction&lt;? super R1, ? super R2, R&gt; merger)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-Map接口和抽象类分析总结.md</title>
      <link href="/2022/03/20/java-map-jie-kou-he-chou-xiang-lei-fen-xi-zong-jie/"/>
      <url>/2022/03/20/java-map-jie-kou-he-chou-xiang-lei-fen-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>java.util.SortedMap</p><p>java.util.NavigableMap</p><p>抽象类<br>  java.util.AbstractMap</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-error捕获.md</title>
      <link href="/2022/03/20/java-error-bu-huo/"/>
      <url>/2022/03/20/java-error-bu-huo/</url>
      
        <content type="html"><![CDATA[<pre><code>package org.szwj.ca.identityauthsrv;import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import javax.imageio.ImageIO;import javax.imageio.stream.ImageOutputStream;import org.apache.commons.io.FileUtils;import org.szwj.ca.identityauthsrv.util.common.ImageUtils;public class DrawDemo &#123;    public static void main(String[] args) throws FileNotFoundException, IOException &#123;        /**         * 直接捕获error         */        try &#123;            byte[] bytes = new byte[1024 * 1024 * 10*10];        &#125;catch (Error error)&#123;            System.out.println(error.getMessage());        &#125;        /**         * 捕获error和exption的分类Throwable         */        try &#123;            byte[] bytes = new byte[1024 * 1024 * 10*10];        &#125;catch (Throwable throwable)&#123;            System.out.println(throwable.getMessage());        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-DTO-DO-VO.md</title>
      <link href="/2022/03/20/java-dto-do-vo/"/>
      <url>/2022/03/20/java-dto-do-vo/</url>
      
        <content type="html"><![CDATA[<p>《阿里巴巴开发手册》以及网上各种博客或多或少都有提到诸如DTO、DO、BO、PO、VO等等，也提倡对实体类进行分层。至于为什么要分层，它们的理由是“避免暴露内部设计细节，只展示必要的字段”，但我个人最大的感受其实是“解耦”。我曾遇到一件无奈的事，接口已经开发完毕，前后端也联合好了，结果产品临时要大改，Service层的逻辑基本要推倒重来，连查的表都不一样了。好在得益于DTO和VO的隔离，并没有影响到其它层，前端甚至完全不知道后端全部重写了，Swagger文档也和原来一模一样…</p><p>不过个人觉得没必要去扣这些概念，比如BO、PO是啥我也记不清。一般来说，POJO分为三类即可：</p><ul><li> 客户端/前端传入的DTO</li><li>与数据库字段映射的DO</li><li>返回给客户端/前端的VO</li></ul><p>DO和VO一般没太多争议，至于DTO，有些公司又会细分各种O，至于有没有必要，则是仁者见仁智者见智了。</p><p>使用DTO DO VO的话，自然就避免不了<code>对象的深拷贝</code>了。</p><p>数据从DTO-&gt;DO 持久化到数据库中。<br>DO-&gt;VO 数据从库中出来放到视图模型VO中返回给前端。</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-3b6ccdf84cd15863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-jdk1-8新特性之Stream流.md</title>
      <link href="/2022/03/20/java-jdk1-8-xin-te-xing-zhi-stream-liu/"/>
      <url>/2022/03/20/java-jdk1-8-xin-te-xing-zhi-stream-liu/</url>
      
        <content type="html"><![CDATA[<p>jdk8提供的Stream流能够方便操作集合、数组<br>java.util.stream包即是Stream流式计算的核心</p><p>###Stream流的特点</p><ul><li>Stream自己不会存储元素</li><li>Stream <code>不会改变源对象</code>，相反，他们会返回一个持有结果的新Stream </li><li>Stream 操作总是延迟执行的。这意味着他们会等到需要结果的时候才执行</li></ul><p>###基础用法<br>①、从数据源中获得流 ==&gt; 一个数据源(数组、List)</p><pre><code>arrayList.stream()</code></pre><p>②、中间操作==&gt;处理数据源数据</p><pre><code> .map(e -&gt; e.get(&quot;a&quot;))</code></pre><p>③、终止操作==&gt;执行中间操作链，产生结果</p><pre><code> .collect(Collectors.toList());</code></pre><p>###获得流<br>######普通流stream()</p><pre><code>import java.util.Arrays;import java.util.List;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);        // 获取空字符串的数量        int count = (int) strings.stream().filter(string -&gt; string.isEmpty()).count();        System.out.println(count);    &#125;&#125;</code></pre><p>######并行流 parallelStream()<br>parallelStream 是流并行处理程序的代替方法。以下实例我们使用parallelStream 来输出空字符串的数量：</p><pre><code>import java.util.Arrays;import java.util.List;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);        // 获取空字符串的数量        int count = (int) strings.parallelStream().filter(string -&gt; string.isEmpty()).count();        System.out.println(count);    &#125;&#125;</code></pre><p>###中间操作<br><img src="https://upload-images.jianshu.io/upload_images/13965490-6d3cbd62a24e4d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/13965490-af3b89b1daaf040a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/13965490-757a575b70c295aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h6><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数：</p><pre><code>import java.util.Random;public class Test &#123;    public static void main(String[] args) &#123;        Random random = new Random();        random.ints().limit(10).forEach(System.out::println);    &#125;&#125;</code></pre><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><pre><code>import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);        // 获取对应的平方数        List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i * i).collect(Collectors.toList());        squaresList.forEach(System.out::println);    &#125;&#125;</code></pre><p>######filter<br>filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串，然后统计数量：</p><pre><code>import org.apache.commons.lang3.StringUtils;import java.util.Arrays;import java.util.List;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot; &quot;, null,&quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot; &quot;, &quot;jkl&quot;);        // 获取空字符串的数量        int count = (int) strings.stream().filter(string -&gt; StringUtils.isBlank(string)).count();        System.out.println(count);    &#125;&#125;</code></pre><p>######Limit</p><p>limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据：</p><pre><code>import java.util.Random;public class Test &#123;    public static void main(String[] args) &#123;        Random random = new Random();        random.ints().limit(10).forEach(System.out::println);    &#125;&#125;</code></pre><p>######sorted</p><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><pre><code>import java.util.Random;public class Test &#123;    public static void main(String[] args) &#123;        Random random = new Random();        random.ints().limit(10).sorted().forEach(System.out::println);    &#125;&#125;</code></pre><p>###终止操作<br>######Collectors 转化为集合、聚合元素、字符串</p><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</p><pre><code>import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);        List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());        System.out.println(&quot;筛选列表: &quot; + filtered);        String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));        System.out.println(&quot;合并字符串: &quot; + mergedString);    &#125;&#125;</code></pre><p>######summaryStatistics 统计<br>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><pre><code>import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);        IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();        System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());        System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());        System.out.println(&quot;所有数之和 : &quot; + stats.getSum());        System.out.println(&quot;平均数 : &quot; + stats.getAverage());    &#125;&#125;</code></pre><p>###Stream流使用实战<br>1、从List<Map>中抽离出map中特定key对应的value所组成的List</p><pre><code>import java.util.*;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Map&lt;String, String&gt;&gt; arrayList = new ArrayList();        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","hhhhhhhhh");            put("b","kkkkkkkkk");        &#125;&#125;);        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","fffffffff");            put("b","gggggggggg");        &#125;&#125;);        List&lt;String&gt; list = arrayList.stream()                .map(e -&gt; e.get(&quot;a&quot;))                .collect(Collectors.toList());        list.forEach(System.out::println);    &#125;&#125;</code></pre><p>2、List<Map> 根据key查找</p><pre><code>import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Map&lt;String, String&gt;&gt; arrayList = new ArrayList();        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","hhhhhhhhh");            put("b","kkkkkkkkk");        &#125;&#125;);        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","fffffffff");            put("b","gggggggggg");        &#125;&#125;);        List&lt;Map&lt;String, String&gt;&gt; list = arrayList.stream().filter(e -&gt; e.keySet().contains(&quot;a&quot;)).collect(Collectors.toList());        System.out.println(list);    &#125;&#125;</code></pre><p>3、过滤掉List<Java Bean>中符合过滤条件的Java Bean</p><pre><code>import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;@Data@AllArgsConstructor@NoArgsConstructorpublic class Test &#123;    private String name;    private Integer age;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,new Test(&quot;yink&quot;,24),new Test(&quot;yinx&quot;,12), new Test(&quot;hh&quot;,13));        List&lt;Test&gt; testList = list.stream().filter(test -&gt; !test.getName().equals(&quot;hh&quot;)&amp;&amp;test.getAge()!=13).collect(Collectors.toList());        System.out.println(testList);    &#125;&#125;</code></pre><pre><code>import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.Arrays;import java.util.List;import java.util.UUID;import java.util.function.*;@Data@NoArgsConstructor@AllArgsConstructorclass User &#123;    private Integer id;    private String userName;    private int age;&#125;/** * @create 2019-02-26 22:24 * &lt;p&gt; * 题目：请按照给出数据，找出同时满足 * 偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序 * 最后只输出一个用户名字 */public class StreamDemo &#123;    public static void main(String[] args) &#123;        User u1 = new User(11, &quot;a&quot;, 23);        User u2 = new User(12, &quot;b&quot;, 24);        User u3 = new User(13, &quot;c&quot;, 22);        User u4 = new User(14, &quot;d&quot;, 28);        User u5 = new User(16, &quot;e&quot;, 26);        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);        list.stream().filter(p -&gt; &#123;            return p.getId() % 2 == 0;        &#125;).filter(p -&gt; &#123;            return p.getAge() &gt; 24;        &#125;).map(f -&gt; &#123;            return f.getUserName().toUpperCase();        &#125;).sorted((o1, o2) -&gt; &#123;            return o2.compareTo(o1);        &#125;).limit(1).forEach(System.out::println);    &#125;&#125;</code></pre><p>4、List<Java Bean>根据Java Bean的一个属性去重</p><pre><code>import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.*;import java.util.stream.Collectors;@Data@AllArgsConstructor@NoArgsConstructorpublic class Test &#123;    private String name;    private Integer age;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,new Test(&quot;yink&quot;,24),new Test(&quot;yink&quot;,12), new Test(&quot;hh&quot;,13));        ArrayList&lt;Test&gt; collect = list.stream().collect(                Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Test::getName))), ArrayList::new)        );        System.out.println(collect);    &#125;&#125;</code></pre><pre><code>       /**         * 按platformOrderNo去重excel集合         */        dataList = dataList.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(()                -&gt; new TreeSet&lt;&gt;(Comparator.comparing(JgOriginalOrder::getPlatformOrderNo))), ArrayList::new));</code></pre><p>5、根据具体属性查找list中的对象</p><pre><code> TbBox tbBox = boxs.stream().filter(u -&gt; u.getSbNumber().equals(&quot;123456&quot;)).findAny().get();</code></pre><p>6、List按字段分组</p><pre><code>  Map&lt;String, List&lt;CertInfoPO&gt;&gt; collect = certSet.stream()                    .collect(Collectors.groupingBy(CertInfoPO::getIdentityNumber));</code></pre><p>7、List<Bean>转 key-vue 形式的Map<code>列转行</code></p><pre><code>       List&lt;SysDictData&gt; face = sysDictDataService.selectDictDataByType(&quot;face&quot;);        Map&lt;String, String&gt; collect = face.stream()            .collect(Collectors.toMap(SysDictData::getDictLabel, SysDictData::getDictValue));</code></pre><p><strong>收集对象实体本身</strong><br>在开发过程中我们也需要有时候对自己的list中的实体按照其中的一个字段进行分组（比如 id -&gt;List），这时候要设置map的value值是实体本身。</p><pre><code>public Map&lt;Long, Account&gt; getIdAccountMap(List&lt;Account&gt; accounts) &#123;    return accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account));&#125;</code></pre><p>account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法 Function.identity()，这个方法返回自身对象，更加简洁</p><p><strong>重复key的情况。</strong><br>在list转为map时，作为key的值有可能重复，这时候流的处理会抛出个异常：Java.lang.IllegalStateException:Duplicate key。这时候就要在toMap方法中指定当key冲突时key的选择。(这里是选择第二个key覆盖第一个key)</p><pre><code>public Map&lt;String, Account&gt; getNameAccountMap(List&lt;Account&gt; accounts) &#123;    return accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2));&#125;</code></pre><p><strong>用groupingBy 或者 partitioningBy进行分组</strong><br>根据一个字段或者属性分组也可以直接用groupingBy方法，很方便。</p><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());&#125;</code></pre><p>8、count 统计</p><pre><code>                List&lt;Map&gt; reList = ((StockProductDetailRepository) stockProductDetailService.getBaseMapper()).getSupplierNoByk3Code(k3Code);                final long count = reList.stream()                        .map(m -&gt; m.get(&quot;firstTag&quot;))                        .filter(e -&gt; Objects.equals(e, 0))                        .count();</code></pre><p>9、Map 过滤方法流</p><pre><code>        /**         * 得到自定义字段         */        //jg_order_field_relationship 里的相关模板的数据除开这个枚举的之外就是自定义字段了        Map&lt;Integer, String&gt; myDefinitionMap = fieldMap.entrySet().stream()                .filter((e) -&gt; !definitionMap.keySet().contains(e.getValue()))                .collect(Collectors.toMap(                        (e) -&gt; e.getKey(),                        (e) -&gt; e.getValue()                ));</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-jdk1-8新特性之四种函数式接口.md</title>
      <link href="/2022/03/20/java-jdk1-8-xin-te-xing-zhi-si-chong-han-shu-shi-jie-kou/"/>
      <url>/2022/03/20/java-jdk1-8-xin-te-xing-zhi-si-chong-han-shu-shi-jie-kou/</url>
      
        <content type="html"><![CDATA[<p>java.util.function 包即是函数式编程的核心</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-d6eb0ce38b58c5ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-Optional#ifPresent.md</title>
      <link href="/2022/03/20/java-util-optional-ifpresent/"/>
      <url>/2022/03/20/java-util-optional-ifpresent/</url>
      
        <content type="html"><![CDATA[<p>ifPresent 用于对过滤出的数据如果存在。如果经过过滤条件后，有数据的话就可以进行修改。</p><pre><code> Optional&lt;A&gt; firstA= AList.stream()                           .filter(a -&gt; &quot;小明&quot;.equals(a.getUserName()))                           .findFirst()                          .ifPresent(a -&gt; &#123;                              a.setUserName(&quot;明明&quot;);                          &#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-Optional-缺陷.md</title>
      <link href="/2022/03/20/java-util-optional-que-xian/"/>
      <url>/2022/03/20/java-util-optional-que-xian/</url>
      
        <content type="html"><![CDATA[<p>在这种时候使用新写法就有些鸡肋了。不要为了使用而使用。反而原来的写法可读性更好</p><pre><code>        Set&lt;String&gt; keySet = map.keySet();        for (String s : keySet) &#123;            String[] split1 = s.split(Constant.COLON);            String value = split1[Constant.NUMBER_ONE];            String[] split = value.split(Constant.COMMA);            if (ArrayUtils.contains(split, key)) &#123;                return s;            &#125;        &#125;</code></pre><p>改写</p><pre><code>        String[] re = new String[1];        boolean b = map.keySet().stream().map(s -&gt; &#123;                    re[0] = s;                    return s.split(Constant.COLON);                &#125;).flatMap(Arrays::stream).skip(1).limit(1).map(s -&gt; s.split(Constant.COMMA))                .anyMatch(split -&gt; ObjectUtil.contains(split, key));        if (b) &#123;            return re[0];        &#125;</code></pre><p>在执行 s.split(Constant.COMMA)时我想拿到前面执行后的数据只能使用 re[0]来记录</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-stream-Collectors#minBy-返回的Optional本身可能会空指针.md</title>
      <link href="/2022/03/20/java-util-stream-collectors-minby-fan-hui-de-optional-ben-shen-ke-neng-hui-kong-zhi-zhen/"/>
      <url>/2022/03/20/java-util-stream-collectors-minby-fan-hui-de-optional-ben-shen-ke-neng-hui-kong-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p>所以拿出这个 Optional对象也记得要判空！</p><p>   public static <T> Collector&lt;T, ?, Optional<T>&gt;<br>    minBy(Comparator&lt;? super T&gt; comparator) {<br>        return reducing(BinaryOperator.minBy(comparator));<br>    }</p><pre><code> //分组计算最小id                    Map&lt;Long, Optional&lt;ZskAccessoriesListDo&gt;&gt; zskQuestionsAndAnswersDoMap = saveZskAccessoriesListDoList.stream()                            .filter(m -&gt; ToolUtil.isNotEmpty(m.getId())).collect(Collectors.groupingBy(ZskAccessoriesListDo::getKnowledgeId,                                    Collectors.minBy(Comparator.comparingInt(o -&gt; ObjectUtil.defaultIfNull(o.getId(), 0).intValue()))));</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-stream-Stream#reduce.md</title>
      <link href="/2022/03/20/java-util-stream-stream-reduce/"/>
      <url>/2022/03/20/java-util-stream-stream-reduce/</url>
      
        <content type="html"><![CDATA[<p>实现用一个12345的list生成一个以”element-“ 为开头元素的List</p><pre><code>    public static void main(String[] args) &#123;        List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5, 6);        ArrayList&lt;String&gt; result = numList.stream().reduce(new ArrayList&lt;String&gt;(), (a, b) -&gt; &#123;            a.add(&quot;element-&quot; + Integer.toString(b));            return a;        &#125;, (a, b) -&gt; null);        System.out.println(result);    &#125;</code></pre><p>[element-1, element-2, element-3, element-4, element-5, element-6]</p><p>a 代表生成的list，b代表原始list的元素</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-中的位运算-位运算符(&amp;，--，^).md</title>
      <link href="/2022/03/20/java-zhong-de-wei-yun-suan-wei-yun-suan-fu/"/>
      <url>/2022/03/20/java-zhong-de-wei-yun-suan-wei-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<p>关于位运算符无非也就 与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;)</p><p>位运算其实就是二进制的运算，加减乘除适用于十进制，而位运算就是二进制的运算,但是由于我们的运算都是基于十进制来说的，所以会有点绕，略微有点难懂，接下来言归正传</p><h2 id="3-与运算符-amp"><a href="#3-与运算符-amp" class="headerlink" title="3) 与运算符(&amp;)"></a>3) 与运算符(&amp;)</h2><p>   如果  4&amp;7   那么这个应该怎么运算呢？</p><p>     首先我们需要把两个十进制的数转换成二进制 </p><p>     4 ： 0000 0100</p><p>     7 ： 0000 0111</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204022745-1107563193.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-2e94d35658d580b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>在这里要提到一点，1表示true，0表示false</p><p>而与运算的时候相同位之间其实就是两个Boolean的运算</p><p>全true(1),即为true(1)</p><p>全false(0),即为false(0)</p><p>一false(0)一true(1),还是false(0)</p><h2 id="4-或运算符"><a href="#4-或运算符" class="headerlink" title="4)或运算符(|)"></a>4)或运算符(|)</h2><p>   以   5|9   为例</p><p>   5 ： 0000 0101 </p><p>   9 ： 0000 1001</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204023575-1172288145.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-35d76a0c19b6bfb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>在做与运算的时候</p><p>**                 遇true(1)就是true(1),**</p><p>**                 无true(1)就是false(0)**</p><h2 id="5-异或运算符"><a href="#5-异或运算符" class="headerlink" title="5) 异或运算符(^)"></a>5) 异或运算符(^)</h2><p>**           以 7^15 为例**</p><p>**           7：   0000 0111**</p><p>**           15： 0000 1111**</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204024149-967390106.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-f6c3b39087393bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>在异或的时候</p><p>               只要相同都是false(0)</p><p>               只有不同才是true(1)</p><h2 id="6-取反运算符"><a href="#6-取反运算符" class="headerlink" title="6) 取反运算符(~)"></a>6) 取反运算符(~)</h2><p>        例：   ~15</p><p>        同样的先变成二进制：15：0000 1111</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204024870-227422826.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-710777dfabde3ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>      这个其实挺简单的，就是把1变0，0变1</p><p>注意：二进制中，最高位是符号位   1表示负数，0表示正数</p><h2 id="7-左移运算-lt-lt"><a href="#7-左移运算-lt-lt" class="headerlink" title="7) 左移运算(&lt;&lt;)"></a>7) 左移运算(&lt;&lt;)</h2><p>左移就是把所有位向左移动几位</p><p>如：   12 &lt;&lt; 2    意思就是12向左移动两位</p><p>12的二进制是： 0000 1100</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025326-1518482974.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-38f503a210b7f5e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>通过这个图我们可以看出来，所有的位全都向左移动两位，然后把右边空的两个位用0补上，最左边多出的两个位去掉，最后得到的结果就是00110000  结果就是48</p><p><strong>我们用同样的办法算 12&lt;&lt;3  结果是 96</strong></p><p>**                            8&lt;&lt;4  结果是  128**</p><p>**  由此我们得出一个快速的算法    M &lt;&lt; n   其实可以这么算   M &lt;&lt; n  = M * 2<sup>n</sup>**</p><h2 id="8-右移运算符-gt-gt"><a href="#8-右移运算符-gt-gt" class="headerlink" title="8) 右移运算符(&gt;&gt;)"></a><strong>8) 右移运算符(&gt;&gt;)</strong></h2><p><strong>这个跟左移运算大体是一样的</strong></p><p>**     例： 12 &gt;&gt; 2**</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025862-1215072643.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-6c06712655c236cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p><strong>我们可以看出来右移和左移其实是一样的，但是还是有点不同的，不同点在于对于正数和负数补位的时候补的不一样，负数补1，正数补0</strong></p><p><strong>如我们再做一个 –8 的    -8&gt;&gt;2</strong></p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204026563-746326181.png"><strong><img src="https://upload-images.jianshu.io/upload_images/13965490-86488c1d8f0aedac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></strong></a> </p><p><strong>这里总结一下，关于负数或者正数来说，移位的时候是一样的，但是在补位的时候，如果最高位是0就补0，如果最高位是1就补1</strong></p><p><strong>由此我们得出一个快速的算法    M &gt;&gt; n   其实可以这么算   M &gt;&gt; n  = M / 2^****n</strong></p><h2 id="9）无符号右移-gt-gt-gt"><a href="#9）无符号右移-gt-gt-gt" class="headerlink" title="9）无符号右移(&gt;&gt;&gt;)"></a>9）无符号右移(&gt;&gt;&gt;)</h2><p>无符号右移(&gt;&gt;&gt;)只对32位和64位有意义<br>在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0</p><p>  这个就不画图了</p><p>###补充<br>使用位运算来判断两个数符号是否相同</p><pre><code>       int a =1;        int b = 10000000;        boolean b1 = ((a &gt;&gt; 31) ^ (b &gt;&gt; 31)) == 0;        System.out.println(b1);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-使用ScheduledExecutorService来代替Timer.md</title>
      <link href="/2022/03/20/java-shi-yong-scheduledexecutorservice-lai-dai-ti-timer/"/>
      <url>/2022/03/20/java-shi-yong-scheduledexecutorservice-lai-dai-ti-timer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>志存高远</p></blockquote><p>《阿里巴巴Java开发手册》中有关于Timer和ScheduledExecutorService的用法说明如下</p><blockquote><p>【强制】 多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用ScheduledExecutorService 则没有这个问题。</p></blockquote><p>它要求使用ScheduledExecutorService来代替Timer</p><p>###先来看Timer</p><p>我们来看下列程序</p><pre><code>package io.renren;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123;    public static void main(String[] args) &#123;        Timer timer = new Timer();        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);            &#125;        &#125;,0,3*1000);        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;***&quot;+Thread.currentThread().getName()+&quot;***&quot;);            &#125;        &#125;,0,3*1000);    &#125;&#125;</code></pre><p>一个Timer运行了2个TimerTask，TimerTask的run方法每3秒执行一次。打印了执行run方法的线程名；可以看到它们是使用同一个<code>Timer-0</code>线程来执行任务的<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c90e4d9d5906bbbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>######Timer的任务出现异常可能导致其他任务不被执行<br>因为Timer总是使用单个线程来执行多个TimerTask的，这样一个TimerTask抛出异常会影响到其它TimerTask的执行 ~<br>如下给 其中一个抛出一个运行时异常看看会怎么样呢？</p><pre><code>package io.renren;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123;    public static void main(String[] args) &#123;        Timer timer = new Timer();        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);            &#125;        &#125;,0,3*1000);        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                int i = 1/0;                System.out.println(&quot;***&quot;+Thread.currentThread().getName()+&quot;***&quot;);            &#125;        &#125;,0,3*1000);    &#125;&#125;</code></pre><p>运行上面程序古，可以看到线程直接退出了<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c2546a27aa86b6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>TimerTask抛出的未检查的异常会终止timer线程，此后已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了</p></blockquote><p>######执行耗时的TimerTask会影响其它TimerTask的执行<br>我们再来看如下例子</p><pre><code>package io.renren;import java.sql.Time;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) &#123;        Timer timer = new Timer();        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;            System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);                try &#123;                    TimeUnit.SECONDS.sleep(10);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,0,3*1000);        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;***&quot;+Thread.currentThread().getName()+&quot;***&quot;);            &#125;        &#125;,0,3*1000);    &#125;&#125;</code></pre><p>执行程序就会发现第二个TimerTask迟迟得不到执行。这也是Timer的单线程执行导致的缺点</p><blockquote><p>创建Timer的时候会创建TimerThread做为执行线程，所以一个Timer对应一个线程，如果一个TimerTask执行的时间过长，其他的TimerTask只能等待。</p></blockquote><p>######Timer的执行时基于系统的绝对时间的<br>如果系统的绝对时间被改变，那么Timer的执行将被影响！</p><p>如下程序，设定等到2020-03-18 10:04:00 时就会触发调用TimerTask。如果我在之前将系统的时间修改，那么改程序就无法得到准确的执行了。</p><p>我将时间修改为 2020-03-17 日。今天其实是18日。执行下列程序。就发现TimerTask迟迟得不到执行</p><pre><code>package io.renren;import java.sql.Time;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) throws ParseException &#123;        Timer timer = new Timer();        SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);        Date parse = ft.parse(&quot;2020-03-18 10:04:00&quot;);        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;               System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);                try &#123;                    TimeUnit.SECONDS.sleep(10);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, parse);    &#125;&#125;</code></pre><blockquote><p>Timer对调度的支持是基于绝对时间的，对系统时钟的改变是敏感的</p></blockquote><p>###我们再来看ScheduledExecutorService<br>ScheduledExecutorService没有timer的上面说名的三个缺陷。<br>它是多线程执行任务的，可以指定初始化线程数（因为它本身是使用线程池ThreadPoolExecutor实现的）</p><p>我们来看下面代码，即使在第二次提交Runnable时出现了除0异常，也不会影响到第一次提交的Runnable执行</p><pre><code>package io.renren;import java.text.ParseException;import java.util.concurrent.*;public class ScheduledExecutorServiceTest &#123;    public static void main(String[] args) &#123;        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        System.out.println(&quot;===&quot; + Thread.currentThread().getName() + &quot;===&quot;);                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        int i = 1/0;                        System.out.println(&quot;***&quot; + Thread.currentThread().getName() + &quot;***&quot;);                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);    &#125;&#125;</code></pre><p>再来看是否因为某个Runnable执行时长过长导致其他Runnable延迟执行</p><pre><code>package io.renren;import java.text.ParseException;import java.util.concurrent.*;public class ScheduledExecutorServiceTest &#123;    public static void main(String[] args) &#123;        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        System.out.println(&quot;===&quot; + Thread.currentThread().getName() + &quot;===&quot;);                        try &#123;                            TimeUnit.SECONDS.sleep(10);                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        System.out.println(&quot;***&quot; + Thread.currentThread().getName() + &quot;***&quot;);                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);    &#125;&#125;</code></pre><p>执行上面程序，可以看到打印了多次 pool-1-thread-2。说明这个问题在ScheduledExecutorService 中不会出现<br><img src="https://upload-images.jianshu.io/upload_images/13965490-3d00cc5267c8fe58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>ScheduledExecutorService 是基于<code>相对时间</code>的，这点也不同于Timer。因此不会出现修改系统时间，指定运行的任务也跟着影响的尴尬局面了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-代码积累.md</title>
      <link href="/2022/03/20/java-dai-ma-ji-lei/"/>
      <url>/2022/03/20/java-dai-ma-ji-lei/</url>
      
        <content type="html"><![CDATA[<p>1、集合逗号拼接<br>String join = org.apache.commons.lang3.StringUtils.StringUtils.join(doctorEmployeeNum,”,”);</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-内存中join-算法.md</title>
      <link href="/2022/03/20/java-nei-cun-zhong-join-suan-fa/"/>
      <url>/2022/03/20/java-nei-cun-zhong-join-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>这个有点像mysql join 算法</p><p>###double netsted for</p><pre><code>import java.util.ArrayList;import java.util.List;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;public class Join &#123;    @Data    @AllArgsConstructor    @NoArgsConstructor    static    class Couple &#123;        private Integer familyId;        private String userName;    &#125;    public static void main(String[] args) &#123;        // 用于计算循环次数        int count = 0;        // 老公组        List&lt;Couple&gt; husbands = new ArrayList&lt;&gt;();        husbands.add(new Couple(1, &quot;梁山伯&quot;));        husbands.add(new Couple(2, &quot;牛郎&quot;));        husbands.add(new Couple(3, &quot;干将&quot;));        husbands.add(new Couple(4, &quot;工藤新一&quot;));        husbands.add(new Couple(5, &quot;罗密欧&quot;));        // 老婆组        List&lt;Couple&gt; wives = new ArrayList&lt;&gt;();        wives.add(new Couple(1, &quot;祝英台&quot;));        wives.add(new Couple(2, &quot;织女&quot;));        wives.add(new Couple(3, &quot;莫邪&quot;));        wives.add(new Couple(4, &quot;毛利兰&quot;));        wives.add(new Couple(5, &quot;朱丽叶&quot;));        for (Couple husband : husbands) &#123;            for (Couple wife : wives) &#123;                // 记录循环的次数                count++;                if (husband.getFamilyId().equals(wife.getFamilyId())) &#123;                    System.out.println(husband.getUserName() + &quot;爱&quot; + wife.getUserName());                    // 把已经匹配的remove                    wives.remove(wife);                    //本次已经找到，再循环下去没有意义                    break;                &#125;            &#125;        &#125;        System.out.println(&quot;----------------------&quot;);        System.out.println(&quot;循环了：&quot; + count + &quot;次&quot;);    &#125;&#125;</code></pre><p>在本案例中，第三版算法在男嘉宾顺序时可以得到最好的结果（5次），如果倒序则得到最差的结果（15次）。</p><p>第二种算法，使用hash</p><h3 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h3><pre><code>    public static void main(String[] args) &#123;        // 用于计算循环次数        int count = 0;        // 老公组        List&lt;Couple&gt; husbands = new ArrayList&lt;&gt;();        husbands.add(new Couple(1, &quot;梁山伯&quot;));        husbands.add(new Couple(2, &quot;牛郎&quot;));        husbands.add(new Couple(3, &quot;干将&quot;));        husbands.add(new Couple(4, &quot;工藤新一&quot;));        husbands.add(new Couple(5, &quot;罗密欧&quot;));        // 老婆组        List&lt;Couple&gt; wives = new ArrayList&lt;&gt;();        wives.add(new Couple(1, &quot;祝英台&quot;));        wives.add(new Couple(2, &quot;织女&quot;));        wives.add(new Couple(3, &quot;莫邪&quot;));        wives.add(new Couple(4, &quot;毛利兰&quot;));        wives.add(new Couple(5, &quot;朱丽叶&quot;));        // 给女嘉宾发牌子        Map&lt;Integer, Couple&gt; wivesMap = new HashMap&lt;&gt;();        for (Couple wife : wives) &#123;            // 女嘉宾现在不在List里了，而是去了wivesMap中，前面放了一块牌子：男嘉宾的号码            wivesMap.put(wife.getFamilyId(), wife);            count++;        &#125;        // 男嘉宾上场        for (Couple husband : husbands) &#123;            // 找到举着自己号码牌的女嘉宾            Couple wife = wivesMap.get(husband.getFamilyId());            System.out.println(husband.getUserName() + &quot;爱&quot; + wife.getUserName());            count++;        &#125;        System.out.println(&quot;----------------------&quot;);        System.out.println(&quot;循环了：&quot; + count + &quot;次&quot;);    &#125;</code></pre><p>此时无论你如何调换男嘉宾出场顺序，都只会循环10次。</p><p>###小结</p><p>它的精髓就是利用HashMap给其中一列数据加了“索引”，每个数据的“索引”（Map的key）是不同的，让数据差异化。<br>了解原理后，如何掌握这简单有效的小算法呢？<br>记住两步：<br>• 先把其中一列数据由线性结构的List转为Hash散列的Map，为数据创建“索引”<br>• 遍历另一列数据，依据索引从Map中匹配数据<br>相比第三版在原有的两个List基础上操作数据，第四版需要额外引入一个Map，内存开销稍微多了一点点。算法中，有一句特别经典的话：空间换时间。第四版勉强算吧。但要清楚，实际上Couple对象并没有增多，Map只是持有原有的Couple对象的引用而已。新增的内存开销主要是Map的索引（Key）。<br>请大家务必掌握这个小算法，后面很多地方会用到它。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-内部类应用之剥离配置到静态内部类让配置信息初始化不依赖于类的本身初始化.md</title>
      <link href="/2022/03/20/java-nei-bu-lei-ying-yong-zhi-bo-chi-pei-zhi-dao-jing-tai-nei-bu-lei-rang-pei-zhi-xin-xi-chu-shi-hua-bu-yi-lai-yu-lei-de-ben-shen-chu-shi-hua/"/>
      <url>/2022/03/20/java-nei-bu-lei-ying-yong-zhi-bo-chi-pei-zhi-dao-jing-tai-nei-bu-lei-rang-pei-zhi-xin-xi-chu-shi-hua-bu-yi-lai-yu-lei-de-ben-shen-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>现在有这么一种情况</p><p>A 类和B类都实现了接口C，接口C中有两个方法，方法1和方法2。A类实现了方法1和方法2，而B类只实现了方法1，B类的方法2没有实现，只能去调用A类的方法2，但是这样调用会报空指针，因为A类使用了@ConditionalOnExpression注解且配置文件中声明使用的实现是B类，故初始化类A所需必要配置信息没办法得到有效的初始化。</p><p>那么我们可以这样处理：</p><p>1、将方法2声明为static方法并从接口C中移除；<br>2、将初始化A类的配置信息放到A类的静态内部类当中,然后加上@Component注解将此类纳入到spring容器的管理，这样A类初始化所需的配置就可以得到初始化了！</p><p>1、接口C</p><pre><code>public interface AiService &#123;    //人脸    void facePost(String image, String name, String idNo);&#125;</code></pre><p>2、A类</p><pre><code>@Service(&quot;BaiduUtilsServiceImpl&quot;)@ConditionalOnExpression(&quot;&#39;$&#123;business.idCartOcr.choice&#125;&#39;.equalsIgnoreCase(&#39;BAIDU&#39;)&quot;)public class BaiduUtilsServiceImpl implements AiService &#123;  void facePost(String image, String name, String idNo)&#123;       //实现接口1      //访问内部类Conifg中的属性    &#125;   //接口2 实现 改为静态；    public static IdCart ocrPost(String photoFront, String photoBack) &#123;    //访问内部类Conifg中的属性    &#125;    /**     * 内部类     */    @Component    public static class Config &#123;        private static String accessToken;        private static String thirdEndpoint;        private static String thirdClientId;        private static String thirdClientSecret;        //接口URL        private static String thirdEndpointIdCart;        private static String thirdEndpointFace;        @NacosValue(value = &quot;$&#123;business.idCartOcr.baidu.thirdClientId&#125;&quot;, autoRefreshed = true)        public void setThirdClientId(String thirdClientId) &#123;            Config.thirdClientId = thirdClientId;        &#125;        @NacosValue(value = &quot;$&#123;business.idCartOcr.baidu.thirdClientSecret&#125;&quot;, autoRefreshed = true)        public void setThirdClientSecret(String thirdClientSecret) &#123;            Config.thirdClientSecret = thirdClientSecret;        &#125;        @NacosValue(value = &quot;$&#123;business.idCartOcr.baidu.thirdEndpoint&#125;&quot;, autoRefreshed = true)        public void setThirdEndpoint(String thirdEndpoint) &#123;            Config.thirdEndpoint = thirdEndpoint;            Config.thirdEndpointIdCart = String                .format(&quot;%s/rest/2.0/ocr/v1/idcard&quot;, thirdEndpoint);            Config.thirdEndpointFace = String                .format(&quot;%s/rest/2.0/face/v3/person/verify&quot;, thirdEndpoint);        &#125;    &#125;&#125;</code></pre><p>3、B类</p><pre><code>@Service(&quot;GdcaUtilsServiceImpl&quot;)@ConditionalOnExpression(&quot;&#39;$&#123;business.idCartOcr.choice&#125;&#39;.equalsIgnoreCase(&#39;GDCA&#39;)&quot;)public class GdcaUtilsServiceImpl implements AiService &#123;    @Override    public void facePost(String image, String name, String idNo) &#123;    //实现  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-刷题.md</title>
      <link href="/2022/03/20/java-shua-ti/"/>
      <url>/2022/03/20/java-shua-ti/</url>
      
        <content type="html"><![CDATA[<p>1、byte b = (byte)129;<br>  -127</p><p>其实可以把每个数据类型范围画成一个圈，byte是从-128-127，可以这样想，从-128开始，向上加就是一步一步画圈，知道加到127，这个圆圈刚好补满了，所以127再加一就又到了-128，再加一就是129，也就是-127</p><p>2、java中的泛型相关结论<br>1、虚拟机中没有泛型，只有普通类和普通方法<br>2、所有泛型类的类型参数在编译时都会被擦除<br>3、创建泛型对象时请指明类型，让编译器尽早的做参数检查</p><p>3、获得参数的方法区分：如何获取ServletContext设置的参数值？<br>getInitParameter();</p><p>getParameter()是获取POST/GET传递的参数值；<br>getInitParameter获取Tomcat的server.xml中设置Context的初始化参数<br>getAttribute()是获取对象容器中的数据值；<br>getRequestDispatcher是请求转发。</p><p>4、java8中，忽略内部接口的情况，不能用来修饰interface里的方法的有（ ）<br>正确答案: A C<br>A private<br>B public<br>C protected<br>D static</p><p>Java8的接口方法可以有如下定义<br>only public, abstract, default, static and strictfp are permitted<br>`java <code>1.8</code>开始支持接口中定义静态方法</p><p>5、如果一个list初始化为{5，3，1}，执行以下代码后，其结果为（B）？<br>nums.add(6);<br>nums.add(0,4);<br>nums.remove(1);</p><p> A[5, 3, 1, 6]<br>B [4, 3, 1, 6]<br> C[4, 3, 6]<br> D[5, 3, 6]</p><p>1、add(int)和两个重载<br>add(int) 是往后面加一位元素；<br>add(int a,int b) 将b插入到指定索引a处，原来a处的元素和后面的元素向后移动一位。注意不是单纯的替换<br>2、remove(int index) 和 remove(Object a) 两种重载<br>即可移除指定位置，又可按元素内容移除。移除后，后面元素往都要往前补一位</p><p>将题目修改下nums.remove((Object)1); 最终输出就是[4, 5, 3, 6]了，因为这次调用的是remove(Object a)重载乃，直接移除指定元素。</p><p>6、表达式(short)10/10.2*2运算后结果是什么类型？</p><p>double。java中默认的浮点就是double。除不断的除法运算计算结果也是double。除的断的结果是int。</p><pre><code>double v = 10 / 2.1;int i = 10 / 2;</code></pre><p>10、关于protected 修饰的成员变量，以下说法正确的是<br>可以被该类自身、与它在同一个包中的其它类、在其它包中的该类的子类所访问</p><p>11、抽象类可以被抽象类继承</p><p>12、javac 命令参数</p><p>-d destination 目的地<br>-s source 起源地<br>javac -d 指定放置生成的类文件的位置<br>javac -s 指定放置生成的源文件的位置</p><p>13、构造函数不能被继承，构造方法只能被显式或隐式的调用。</p><p>14、</p><pre><code>class Animal&#123;    public void move()&#123;        System.out.println(&quot;动物可以移动&quot;);    &#125;&#125;class Dog extends Animal&#123;    public void move()&#123;        System.out.println(&quot;狗可以跑和走&quot;);    &#125;    public void bark()&#123;        System.out.println(&quot;狗可以吠叫&quot;);    &#125;&#125;public class TestDog&#123;    public static void main(String args[])&#123;        Animal a = new Animal();        Animal b = new Dog();         a.move();        b.move();        b.bark();    &#125;&#125;</code></pre><p>编译错误！</p><blockquote><p>编译看左边，运行看右边。 父类型引用指向子类型对象，无法调用只在子类型里定义的方法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-反射.md</title>
      <link href="/2022/03/20/java-fan-she/"/>
      <url>/2022/03/20/java-fan-she/</url>
      
        <content type="html"><![CDATA[<p>1、调用所有包含get的方法名，参数数目为0的</p><pre><code>      Class&lt;?&gt; herosClass = Certificate.class;        Method[] methods = herosClass.getMethods();        for (Method method : methods) &#123;            if(method.getName().contains(&quot;get&quot;) &amp;&amp;   method.getParameterCount()  == 0)&#123;                System.out.println(method.getName());                Object invoke = method.invoke(x509Certificate);                System.out.println(invoke);            &#125;        &#125;</code></pre><p>2、使用字符串方法名调用方法</p><pre><code>@Test    public void test7() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException&#123;        Class&lt;?&gt; Person = Class.forName(&quot;com.Person&quot;);        Object newInstance = Person.newInstance();        for (int i = 1; i &lt; 4; i++) &#123;            Method method = Person.getMethod(&quot;getPerson&quot;+i, String.class);            String str2= (String) method.invoke(newInstance, new Object[]&#123;i+&quot;&quot;&#125;);            System.out.println(str2);        &#125;    &#125;</code></pre><p>3、调用set</p><pre><code>    /***     * 初始化时加载所有set方法     */    static &#123;        Class cs = null;        try &#123;            cs = Class.forName(JgOriginalOrder.class.getName());        &#125; catch (ClassNotFoundException e) &#123;            log.error(&quot;初始化JgOriginalOrder set 失败&quot;,e);        &#125;        Field[] fileds = cs.getDeclaredFields();        try &#123;            for (Field field : fileds) &#123;                PropertyDescriptor pd = new PropertyDescriptor(field.getName(), cs);                //获取所有set方法                Method method = pd.getWriteMethod();                methodMap.put(field.getName(),method);            &#125;        &#125; catch (Exception e) &#123;            log.error(&quot;初始化JgOriginalOrder set 失败&quot;,e);        &#125;    &#125;    private static void setObjOnOrder(JgOriginalOrder order, String fieldName ,Object setObj) &#123;        final Method method = methodMap.get(fieldName);        try &#123;            method.invoke(order,setObj);        &#125; catch (IllegalAccessException e) &#123;           log.error(&quot;set 方法调用失败&quot;,e);        &#125; catch (InvocationTargetException e) &#123;            log.error(&quot;set 方法调用失败&quot;,e);        &#125;    &#125;</code></pre><p>4、pojo 各种属性都为null判断</p><pre><code>    private static Method[] methods = MgbsupplierBatchDto.class.getMethods();    private static boolean isAllNull(MgbsupplierBatchDto t) &#123;        for (Method method : methods) &#123;            if (method.getName().contains(&quot;get&quot;) &amp;&amp; method.getParameterCount() == 0) &#123;                if(!StringUtils.contains(method.getName(),&quot;getCellStyleMap&quot;)&amp;&amp;!StringUtils.contains(method.getName(),&quot;getClass&quot;) )&#123;                    Object invoke = null;                    try &#123;                        invoke = method.invoke(t);                    &#125; catch (IllegalAccessException e) &#123;                        log.error(e.toString(),e);                    &#125; catch (InvocationTargetException e) &#123;                        log.error(e.toString(),e);                    &#125;                    if (ToolUtil.isNotEmpty(invoke)) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-匿名内部类相关概念.md</title>
      <link href="/2022/03/20/java-ni-ming-nei-bu-lei-xiang-guan-gai-nian/"/>
      <url>/2022/03/20/java-ni-ming-nei-bu-lei-xiang-guan-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>###匿名内部类</p><pre><code>public class MyThread &#123;    private MyRunnable target;    public MyThread(MyRunnable target) &#123;        this.target = target;    &#125;    public void run() &#123;        System.out.println(&quot;去12306买了一张票&quot;);        System.out.println(&quot;坐火车...&quot;);    &#125;    public void start() &#123;        if (target != null) &#123;            target.run();        &#125; else &#123;             this.run();        &#125;    &#125;&#125;</code></pre><pre><code>@FunctionalInterfacepublic interface MyRunnable &#123;    void run();&#125;</code></pre><pre><code>    public static void main(String[] args) &#123;        Integer i =1;        new MyThread(new MyRunnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;不用买票&quot;);                System.out.println(&quot;骑电瓶车...&quot;);                System.out.println(i);            &#125;        &#125;).start();    &#125;</code></pre><p>####匿名内部类访问外部方法中定义的变量<br>jdk1.8后匿名部内部类访问外面方法中定义胡变量不需要加final了。记住，在1.7时还需加final否则编译不通过！<br>查看反编译代码，可见编译后的代码自动了帮我们加了final。</p><pre><code>public class t1 &#123;    public t1() &#123;    &#125;    public static void main(String[] args) &#123;        final Integer i = 1;        (new MyThread(new MyRunnable() &#123;            public void run() &#123;                System.out.println(&quot;不用买票&quot;);                System.out.println(&quot;骑电瓶车...&quot;);                System.out.println(i);            &#125;        &#125;)).start();    &#125;&#125;</code></pre><p><strong>为什么传递给匿名内部类的参数必须声明为final？</strong><br>局部变量在方法中，方法调用完毕即弹栈，会从内存消失。而匿名内部类的实例是在堆中，在未来某个时刻被垃圾回收。生命周期不同步会导致：一个实例持有一个已经不存在的变量引用…<br>由于对象的生命周期无法改变，所以只能是局部变量做出让步：加final变为常量，常驻内存。这样，变量的生命周期反而可能比实例更长久。</p><p><em>我这个里还有个疑问：</em><br>但是，这种情况。for循环中的循环计数器i如果要使用到匿名内部类里面去。编译会报错：<br>需要用int finalI = i; 接收下。</p><pre><code>    public static void main(String[] args) &#123;        for (int i = 0; i &lt;10 ; i++) &#123;            int finalI = i;            new MyThread(new MyRunnable() &#123;                @Override                public void run() &#123;                    System.out.println(&quot;不用买票&quot;);                    System.out.println(&quot;骑电瓶车...&quot;);                    System.out.println(finalI);                &#125;            &#125;).start();        &#125;    &#125;</code></pre><p>why？<br>因为不能把final声明在i上，i毕竟还要自增。故只能再用一个final 变量接收i的值。而jdk1.8中final会自动加上，所以就是 int finalI = i; </p><p>###Lambda<br><strong>只有一个抽象方法的匿名内部类(函数式接口)可以写作lambada</strong><br>上面的可以简写为如下：</p><pre><code>    public static void main(String[] args) &#123;        for (int i = 0; i &lt;10 ; i++) &#123;            final String finalI = String.valueOf(i);            new MyThread(() -&gt; &#123;                System.out.println(&quot;不用买票&quot;);                System.out.println(&quot;骑电瓶车...&quot;);                System.out.println(finalI);            &#125;).start();        &#125;    &#125;</code></pre><p>1、说明Lambda表达式在身份上与匿名类对象等价。<br>2、说明Lambda表达式在作用上与方法等价。</p><blockquote><p>Lambda表达式，其实是一段可传递的代码。Lambda本质是以类的身份，干方法的活。</p></blockquote><p>###函数式接口<br>介绍完Lambda表达式，最后提一下函数式接口。大家肯定会有疑问：难道所有接口都可以接收Lambda表达式吗？显然不是的，接口要想接收Lambda表达式，必须是一个函数式接口。所谓函数式接口，最核心的特征是：</p><blockquote><p>有且只有一个抽象方法。</p></blockquote><p>这句话有两个重点：抽象方法、唯一。你可能觉得：啥玩意，Java的接口不就抽象方法吗？难道还有别的方法？是的，Java8的接口可以添加静态方法和默认方法，越来越像一个类。关于Java8为什么需要静态方法和默认方法，后面介绍Stream流操作时我们再来介绍。</p><p>也就是说，如果你希望一个接口能接收Lambda表达式充当匿名类对象，那么接口必须仅有一个抽象方法，这是函数式接口的定义。通常我们可以在接口上加一个@FunctionalInterface检测，作用于@Override一样。但函数式接口和@FunctionalInterface注解没有必然联系。</p><p>若接口包含多个抽象方法，则不是一个<code>函数式接口</code>，不能改写为<code>Lambda</code>。<br>下面的代码不会被idea置灰提示可以改写为Lambda。</p><pre><code>public interface MyRunnable &#123;    void run();    void rr();&#125;</code></pre><pre><code>    public static void main(String[] args) &#123;        for (int i = 0; i &lt;10 ; i++) &#123;            final String finalI = String.valueOf(i);            new MyThread(new MyRunnable() &#123;                @Override                public void run() &#123;                    System.out.println(&quot;不用买票&quot;);                    System.out.println(&quot;骑电瓶车...&quot;);                    System.out.println(finalI);                &#125;                @Override                public void rr() &#123;                &#125;            &#125;).start();        &#125;    &#125;</code></pre><p>###Lambda与匿名内部类的区别</p><blockquote><p>很多人可能在心里已经自动把Lambda等同于匿名内部类，认为Lambda是匿名内部类的语法糖。然而并不是。</p></blockquote><p>1、只有仅仅包含一个抽象方法实现的匿名内部类才可以改写为Lambda。<br>2、使用匿名内部类编译后产生两个class<code>（t1.class、t1$1.class）</code>；Lambda编译产生一个<code>class(t1.class)</code>。<br>3、在抽象方法体打印this二者不同；匿名内部类的this指向匿名内部类对象<code>(t1$1@16f6e28)</code>；Lambda方法体this指向调用者<code>(t1@14c265e)</code>。</p><h3 id="this与闭包"><a href="#this与闭包" class="headerlink" title="this与闭包"></a>this与闭包</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之Random-随机数.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-random-sui-ji-shu/"/>
      <url>/2022/03/20/java-ji-chu-zhi-random-sui-ji-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>吾生也有涯，而知也无涯</p></blockquote><p>######使用Random 生成指定大小范围内的随机数</p><blockquote><p>公式:  random.nextInt(n -m + 1) +m;</p></blockquote><p>如下生成[22,433]范围内的随机数，注意两边都是闭区间。22和443都会取得到</p><pre><code>package io.renren;import java.util.Random;public class RandomTest &#123;    public static void main(String[] args) &#123;        Random random = new Random(1);        // [22,433]        for (int i = 0; i &lt;1000 ; i++) &#123;            System.out.println(random.nextInt(433-22+1) + 22);        &#125;    &#125;&#125;</code></pre><p>######Random 是线程安全的么？可以被线程共享一个实例么？<br>在工程中不同地方生成随机数总是new了很多个Random 实例，想着这个Random 能不能复用。于是打开jdk文档看看，里面有提到</p><blockquote><p>java.util.Random的是线程安全的。 但是，跨线程的同时使用java.util.Random实例可能会遇到争用，从而导致性能下降。 在多线程设计中考虑使用<a href="../../java/util/concurrent/ThreadLocalRandom.html" title="java.util.concurrent中的类"><code>ThreadLocalRandom</code></a> 。</p></blockquote><p>文档中说明了Random是线程安全的，但是不建议多线程访问同一个实例。因为会带来效率问题。我们来看看Random的源码探究下</p><p>nextInt方法里调用了next方法<br><img src="https://upload-images.jianshu.io/upload_images/13965490-d2b9900682d44567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>那么再看看next方法，可以看到next方法里为了保证seed对象是最新的就调用了compareAndSet方法</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-661203cd1e2d7be2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们知道compareAndSet是著名的<code>CAS</code> 乐观锁算法，而这种算法在激烈的并发修改下会导致自旋次数过多。从而长时间占用cpu执行时间片。</p><p>那么这种建议背后的原理就一目了然了。而且在《阿里巴巴Java开发手册》中也有提到：</p><blockquote><p>【推荐】 避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。<br>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。<br>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例</p></blockquote><p>JDK7之前可以使用ThreadLocal为每一个线程绑定一个Random 实例。JDK7之后就有一个现成的ThreadLocalRandom类可以使用了</p><p>######ThreadLocalRandom 多线程共享随机数生成<br>关于ThreadLocalRandom 可以看看这篇文章<br><a href="https://www.jianshu.com/p/bf276d506668">https://www.jianshu.com/p/bf276d506668</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-发起post请求,自定义header和body.md</title>
      <link href="/2022/03/20/java-fa-qi-post-qing-qiu-zi-ding-yi-header-he-body/"/>
      <url>/2022/03/20/java-fa-qi-post-qing-qiu-zi-ding-yi-header-he-body/</url>
      
        <content type="html"><![CDATA[<pre><code>package io.renren.modules.websocket.test;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.*;/** * @date 2019/10/1017:12 */public class HttpUtils &#123;    //post请求    /**     * @param url     * @param headerMap  header 参数     * @param contentMap body 参数     * @return     */    public static String postMap(String url, Map&lt;String, String&gt; headerMap, Map&lt;String, String&gt; contentMap) &#123;        String result = null;        CloseableHttpClient httpClient = HttpClients.createDefault();        HttpPost post = new HttpPost(url);        List&lt;NameValuePair&gt; content = new ArrayList&lt;NameValuePair&gt;();        Iterator iterator = contentMap.entrySet().iterator();           //将content生成entity        while (iterator.hasNext()) &#123;            Map.Entry&lt;String, String&gt; elem = (Map.Entry&lt;String, String&gt;) iterator.next();            content.add(new BasicNameValuePair(elem.getKey(), elem.getValue()));        &#125;        CloseableHttpResponse response = null;        try &#123;            Iterator headerIterator = headerMap.entrySet().iterator();          //循环增加header            while (headerIterator.hasNext()) &#123;                Map.Entry&lt;String, String&gt; elem = (Map.Entry&lt;String, String&gt;) headerIterator.next();                post.addHeader(elem.getKey(), elem.getValue());            &#125;            if (content.size() &gt; 0) &#123;                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(content, &quot;UTF-8&quot;);                post.setEntity(entity);            &#125;            response = httpClient.execute(post);            //发送请求并接收返回数据            if (response != null &amp;&amp; response.getStatusLine().getStatusCode() == 200) &#123;                HttpEntity entity = response.getEntity();       //获取response的body部分                result = EntityUtils.toString(entity);          //读取reponse的body部分并转化成字符串            &#125;            return result;        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125; catch (ClientProtocolException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                httpClient.close();                if (response != null) &#123;                    response.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;    // url格式转map    public static Map&lt;String, String&gt; paramToMap(String paramStr) &#123;        String[] params = paramStr.split(&quot;&amp;&quot;);        Map&lt;String, String&gt; resMap = new HashMap&lt;String, String&gt;();        for (int i = 0; i &lt; params.length; i++) &#123;            String[] param = params[i].split(&quot;=&quot;);            if (param.length &gt;= 2) &#123;                String key = param[0];                String value = param[1];                for (int j = 2; j &lt; param.length; j++) &#123;                    value += &quot;=&quot; + param[j];                &#125;                resMap.put(key, value);            &#125;        &#125;        return resMap;    &#125;    //Header字符串转map    public static Map&lt;String, String&gt; splid(String zz) &#123;        String[] stepOne = zz.split(&quot;\n&quot;);        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        for (int i = 0; i &lt; stepOne.length; i++) &#123;            String[] stepTwo = stepOne[i].split(&quot;: &quot;);            if (map.get(stepTwo[0]) == null)                map.put(stepTwo[0], stepTwo[1]);            else                map.put(stepTwo[0], stepTwo[1] + &quot;,&quot; + map.get(stepTwo[0]));        &#125;        return map;    &#125;    public static void main(String[] args) &#123;        String header =                &quot;Host: r.cnews.qq.com\n&quot; +                        &quot;Accept-Encoding: gzip,deflate\n&quot; +                        &quot;Referer: http://cnews.qq.com/cnews/android/\n&quot; +                        &quot;User-Agent: %E5%A4%A9%E5%A4%A9%E5%BF%AB%E6%8A%A56080(android)\n&quot; +                        &quot;Cookie: lskey=; luin=; skey=; uin=; logintype=0;\n&quot; +                        &quot;snqn: isrlo83QeV0HUKSXBDEC2KU0i6dA6NJ+cJ6DfolV5BUaHTHKTIU0WQXRMHW9bo+0oWH2Uep5SZ6wOU2ufjuBOl9TYQKJaDModIprMcdjEIFHr32o8/mB9Da/apEitNzMj/o+zfCmWj7zQZTmMNvZaQ==\n&quot; +                        &quot;svqn: 1_4\n&quot; +                        &quot;qn-sig: 8da32c703ef980b76fc3343118e1a9f8\n&quot; +                        &quot;qn-rid: 16e0d706-a1e4-465b-9a39-ce0caea0e03f\n&quot; +                        &quot;Content-Type: application/x-www-form-urlencoded\n&quot; +                        &quot;Connection: Keep-Alive&quot;;        //&quot;Content-Length: 2267\n&quot;;        Map splid = splid(header);        System.out.println(splid);        Map&lt;String, String&gt; bodyMap = paramToMap(&quot;adcode=440111&amp;last_id=20191008A046A900&amp;lon=113.268162&amp;cityList=%E5%B9%BF%E5%B7%9E&amp;loc_streetNo=&amp;forward=1&amp;refreshType=normal&amp;provinceId=19&amp;last_time=1570521327&amp;userCity=%E5%B9%BF%E5%B7%9E&amp;bottom_id=20191007A0DZI400&amp;loc_name=%E7%99%BD%E4%BA%91%E7%BB%BF%E5%9C%B0%E4%B8%AD%E5%BF%83&amp;top_time=1570495721&amp;manualRefresh=1&amp;top_id=20191008A046A900&amp;loc_addr=%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%B9%BF%E5%B7%9E%E5%B8%82%E7%99%BD%E4%BA%91%E5%8C%BA%E4%BA%91%E5%9F%8E%E8%A5%BF%E8%B7%AF%E4%B8%8E%E9%BD%90%E5%BF%83%E8%B7%AF%E4%BA%A4%E5%8F%89%E5%8F%A3%E5%8D%97150%E7%B1%B3&amp;page=8&amp;cityId=198&amp;lastRefreshTime=1570521327&amp;loc_street=%E4%BA%91%E5%9F%8E%E8%A5%BF%E8%B7%AF&amp;preload=1&amp;loc_catalog=%E6%88%BF%E4%BA%A7%E5%B0%8F%E5%8C%BA%3A%E5%95%86%E5%8A%A1%E6%A5%BC%E5%AE%87&amp;refresh_from=refresh_footer&amp;direction=1&amp;sessionid=undefined&amp;chlid=kb_news_hotnews&amp;bottom_time=1570435632&amp;is_viola=1&amp;loc_accuracy=40.0&amp;lat=23.180721&amp;REQBuildTime=1570521551393&amp;adcode=440111&amp;lon=113.268162&amp;ssid=YR-TECH&amp;omgid=f4287f3ea730a249015bd9d06a73f6dc23c00010212406&amp;REQExecTime=1570521551412&amp;qqnetwork=wifi&amp;commonsid=7b7615ee4c8e412b9ba95ca7ebbca7eb&amp;kingCardType=0&amp;picSizeMode=0&amp;adCookie=&amp;commonGray=1_3%7C2_1%7C12_0%7C49_1%7C14_1%7C17_1%7C30_1%7C99_1&amp;currentTab=kuaibao&amp;proxy_addr=192.168.1.99%3A8888&amp;is_wap=0&amp;lastCheckCardType=0&amp;omgbizid=a323e236f72cee4c10e96ec642cb73943d3a0080214908&amp;imsi=460005292210411&amp;commonIsFirstLaunch=0&amp;bssid=22%3Abc%3A5a%3A74%3Aa0%3A88&amp;taid=0101869FFED6E4A84F898262CADBA96EC2521FB86438AEE01A238B538F2A8F90BA0F96B93C4F0770FD1F0AED&amp;activefrom=icon&amp;unixtimesign=1570521551414&amp;qimei=92a420ebc78a0356&amp;Cookie=%26lskey%3D%26luin%3D%26skey%3D%26uin%3D%26logintype%3D0&amp;qaid=0171E6660E55174412AC482013E10C8E&amp;imsi_history=460005292210411&amp;qn-sig=8da32c703ef980b76fc3343118e1a9f8&amp;qn-rid=16e0d706-a1e4-465b-9a39-ce0caea0e03f&amp;lat=23.180721&amp;hw_fp=Coolpad%2FCool1_CN%2Fcool_c1%3A6.0.1%2FZAXCNFN5902606201S%2F0001820%3Auser%2Frelease-keys&amp;gpu=Qualcomm%20Adreno%20%28TM%29%20510&amp;mid=ca57d1f0e21794164956b43da41d7fea68de70fa&amp;devid=861795038752864&amp;mac=54%3ADC%3A1D%3A2A%3A0A%3A2A&amp;store=9002096&amp;screen_height=1920&amp;apptype=android&amp;origin_imei=861795038752864&amp;codeclevel=5.1&amp;rover=1&amp;hw=Coolpad_C106&amp;appversion=6.0.80&amp;appver=23_areading_6.0.80&amp;uid=92a420ebc78a0356&amp;screen_width=1080&amp;sceneid=&amp;android_id=92a420ebc78a0356&quot;);        String s = postMap(&quot;https://r.cnews.qq.com/getVerticalChannel?devid=861795038752864&quot;, splid, bodyMap);        System.out.println(s);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之java异常体系.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-java-yi-chang-ti-xi/"/>
      <url>/2022/03/20/java-ji-chu-zhi-java-yi-chang-ti-xi/</url>
      
        <content type="html"><![CDATA[<p>#Java异常类的架构<br><img src="https://upload-images.jianshu.io/upload_images/13965490-d66aae69de2722b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="RuntimeException-UnCheckException"><a href="#RuntimeException-UnCheckException" class="headerlink" title="RuntimeException/UnCheckException"></a>RuntimeException/UnCheckException</h3><p>定义: RuntimeException及其子类都被称为运行时异常。<br>特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。<br>spring框架的@Transactional事务注解默认回滚RuntimeException。</p><p>例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常、常见的空指针异常NullPointerException等，都属于运行时异常。</p><p>虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。</p><blockquote><p>如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p></blockquote><h3 id="CheckException"><a href="#CheckException" class="headerlink" title="CheckException"></a>CheckException</h3><p>定义: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。<br>特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如进行文件操作时遇到的IOException、线程sleep方法/obj的wait方法抛出的InterruptedException等都属于CheckException。</p><p>@Transactional事务注解默认不会回滚checkException，需要指定Exception父类，用法如下：<br>@Transactional(rollbackFor = Exception.class); 而且捕获后需要抛出给上层调用者，这样事务才会正常回滚。</p><blockquote><p>被检查异常通常都是可以恢复的。</p></blockquote><h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><p>定义: Error类及其子类。<br>特点: 和运行时异常一样，编译器也不会对错误进行检查。<br>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。</p><p>@Transactional事务注解默认回滚ERROR</p><p>例如我们常见的虚拟机内存栈溢出错误StackOverflowError。</p><blockquote><p>熟悉java异常机制对我们使用spring声明式事务有很大帮助！这篇文章探讨了异常和spring事务的关系 <a href="https://www.jianshu.com/p/702ac5630b99">https://www.jianshu.com/p/702ac5630b99</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之finally是否一定会执行-.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-finally-shi-fou-yi-ding-hui-zhi-xing/"/>
      <url>/2022/03/20/java-ji-chu-zhi-finally-shi-fou-yi-ding-hui-zhi-xing/</url>
      
        <content type="html"><![CDATA[<p>事实上finally区域代码在很多情况下都不会执行<br>######没有进入try区域<br> <br>1、程序在进入try区域之前抛出异常，那么整个try-catch -finally都不会执行</p><pre><code>class TestThreadLocal &#123;    public static Integer test() &#123;        int a = 1 / 0;        try &#123;            int b = 1 / 0;// 不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);// 不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);// 不会执行            return 1;// 不会执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p>2、程序在进入try区域之前return，那么整个try-catch -finally都不会执行</p><pre><code>class TestThreadLocal &#123;    public static Integer test() &#123;        if (true) &#123;            return 0;        &#125;        try &#123;            int b = 1 / 0;// 不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);// 不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);// 不会执行            return 1;// 不会执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p>######进入了try区域<br> 如果当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。</p><p>1、守护线程随着用户线程退出而退出，finally 不会执行</p><pre><code>class DaemonDemo &#123;    public static void main(String[] args) &#123;        Thread daemonThread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (true) &#123;                    try &#123;                        System.out.println(&quot;i am alive&quot;);                        Thread.sleep(500);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125; finally &#123;                        System.out.println(&quot;finally block&quot;);                    &#125;                &#125;            &#125;        &#125;);        daemonThread.setDaemon(true);        daemonThread.start();        try &#123;            //确保main线程结束前能给daemonThread能够分到时间片            Thread.sleep(800);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-2ac9520341c45633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第二次没有执行finally</p><p>######退出程序<br>1、执行了System.exit(0); 退出java虚拟机</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        System.exit(0);        try &#123;            int b = 1 / 0;// 不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);// 不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);// 不会执行            return 1;// 不会执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之switch语句细节.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-switch-yu-ju-xi-jie/"/>
      <url>/2022/03/20/java-ji-chu-zhi-switch-yu-ju-xi-jie/</url>
      
        <content type="html"><![CDATA[<p>###switch所允许的数据类型<br><img src="https://upload-images.jianshu.io/upload_images/13965490-73a8c2501dba91d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>基本数据类型：byte, short, char, int<br>包装数据类型：Byte, Short, Character, Integer<br>枚举类型：Enum<br>字符串类型：String（jdk 7 开始支持）</p><p>不支持boolean和double、float类型<br>###switch语句的执行特征<br>1、switch 分支是由上到下执行的<br>2、程序会继续执行下一条 case 语句，直到出现 break 语句，当遇到 break 语句时，switch 语句终止<br>3、switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分 支（可以在任何位置，但一般在最后一个）。<br>4、default 在没有 case 语句的值和变量值相等的时候执行。<br>5、default放到最后的话就不需要 break 语句，如果放到前面情况就不同了。</p><p>######实例<br>1、没有break 语句，程序将由上至下执行 case。直到遇到break </p><pre><code>    public static void main(String[] args) &#123;        switch (0) &#123;            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-7ba0d9ac4735e357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>2、再来看有break会怎么样</p><pre><code>public static void main(String[] args) &#123;        switch (0) &#123;            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);                break;            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-cba3e313503979b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>3、default在没有匹配时执行</p><pre><code>    public static void main(String[] args) &#123;        switch (8) &#123;            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-554953b5d84faa0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>4、如果default语句块写在上面，因为没有遇到break，全都执行一遍~</p><pre><code>  public static void main(String[] args) &#123;        switch (8) &#123;            default:                System.out.println(&quot;default&quot;);            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-884fb296a3207e4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之try-catch-finally.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-try-catch-finally/"/>
      <url>/2022/03/20/java-ji-chu-zhi-try-catch-finally/</url>
      
        <content type="html"><![CDATA[<p>####关于try-catch -finally异常处理语句块最基本的知识</p><p>1、catch 里的代码只有在try里抛出未处理异常时才会执行</p><pre><code>class TestFinally&#123;    public static void test() &#123;        try &#123;            System.out.println(&quot;会执行吗？&quot;);//执行        &#125; catch (Exception e) &#123;            System.out.println(e);//不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行        &#125;    &#125;    public static void main(String[] args) &#123;        test();    &#125;&#125;</code></pre><p>2、try里抛出异常代码行下面的代码不会被执行</p><pre><code>class TestFinally&#123;    public static void test() &#123;        try &#123;            int a = 1 / 0;//抛出异常的代码            System.out.println(&quot;会执行吗？&quot;);//不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行        &#125;    &#125;    public static void main(String[] args) &#123;        test();    &#125;&#125;</code></pre><p>3、try中抛出异常，catch成功捕获执行后。在try-catch-finally后的代码也会得到执行</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int i = 1 / 0;        &#125; catch (Exception e) &#123;            System.out.println(e);//执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行        &#125;        System.out.println(&quot;我会执行吗?&quot;);//执行        return 2;//执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//2    &#125;&#125;</code></pre><p>4、catch 中使用throw 向调用者抛出异常，则在try-catch-finally后的代码不会执行</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int i = 1 / 0;        &#125; catch (Exception e) &#123;            throw e;//方法跳出        &#125;        System.out.println(&quot;我会执行吗?&quot;);//不会执行        return 2;//不会执行    &#125;    public static void main(String[] args) &#123;        try &#123;            System.out.println(test());        &#125;catch (Exception e)&#123;            System.out.println(e);//执行        &#125;    &#125;&#125;</code></pre><p>###try-catch-finally 和return语句不得不说的关系</p><p>######1、finally中有return语句<br><code>finally中的return语句优先级是最高的！函数最终的返回值以finally中的return语句为准</code><br>①、来看try和finally中return语句的优先级</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        try &#123;            return 0;//不执行        &#125; catch (Exception e) &#123;            System.out.println(e);            return 2;//因为没有抛出异常，不执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);            return 1;//执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-79aae1697576444e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>②、再来看catch和finally中的return语句优先级</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        try &#123;            int a = 1/0;        &#125; catch (Exception e) &#123;            System.out.println(e);            return 2;// 被finally中的return覆盖！        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);            return 1;//执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-ac50efd72841e6fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>③、在finally里的return导致finally中后面的语句不被执行</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int a = 1/0;        &#125; catch (Exception e) &#123;            System.out.println(e);//执行        &#125; finally &#123;            if (true) &#123;                return 1;            &#125;            System.out.println(&quot;我会执行吗！&quot;); //不会执行        &#125;        return 0;//不会执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//1    &#125;&#125;</code></pre><p>######2、try/catch 中有return语句，finally块中没有return语句</p><p>①、<code>这里情况很特殊</code>程序执行的顺序被打乱了。代码运行到 return 1;会将return 的结果暂时保留，并没有立刻返回。先去执行finally 区域中的代码，然后返回return 1;</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int a = 1 / 0;        &#125; catch (Exception e) &#123;            System.out.println(e);            return 1;//执行了        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行了        &#125;        System.out.println(&quot;会执行吗?&quot;);//没有执行        return 0;//没有执行    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);//输出1    &#125;&#125;</code></pre><p>执行结果<br><img src="https://upload-images.jianshu.io/upload_images/13965490-f75f91cc278ed363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>②、所谓的<code>返回值暂时保留</code>可以再看一个例子：</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        int i = 0;        try &#123;            int a = 1 / 0;        &#125; catch (Exception e) &#123;            System.out.println(e);            return i;// 保留返回值为 0        &#125; finally &#123;            i++;            System.out.println(&quot;执行finally！&quot;);//执行了        &#125;        System.out.println(&quot;会执行吗?&quot;);//没有执行        return -1;//没有执行    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);//输出0    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-cadbfdc7705e2587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>最终的返回值是 0 。而不是1，有人肯定会说明明执行了i++，之后才返回为什么？ 因为在finally 执行之前的return语句的返回值会被<code>返回值暂时保留</code></p><p>③、catch 中的return 优先级大于try-catch-finally后面的</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int a = 1/0;            if (true) &#123;                return 1;//不会执行            &#125;        &#125; catch (Exception e) &#123;            System.out.println(e);//执行            return 2;//执行        &#125; finally &#123;            System.out.println(&quot;finally执行&quot;); //执行        &#125;        System.out.println(&quot;我会执行吗?&quot;);//不会执行        return 3;//不会执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//2    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-9dee15767f4c8bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>④、try中的return 优先级高于try-catch-finally后面的</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            if (true) &#123;                return 1;//执行            &#125;        &#125; finally &#123;            System.out.println(&quot;finally执行&quot;);//执行        &#125;        return  3;//不会执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//1    &#125;&#125;</code></pre><p>######try/catch/finally和return 关系总结</p><ul><li>finally中的return 优先级最高。如果finally中有return 1，那么方法的返回值就是1了</li><li>try和catch中return 的优先级无法比较</li><li>try中的return 优先级高于try-catch-finally后面的</li><li>catch 中的return 优先级大于try-catch-finally后面的</li><li>注意<code>返回值保留</code>问题</li></ul><h6 id="try-catch-finally和-throw抛出异常的关系"><a href="#try-catch-finally和-throw抛出异常的关系" class="headerlink" title="try/catch/finally和 throw抛出异常的关系"></a>try/catch/finally和 throw抛出异常的关系</h6><pre><code>class TestFinally &#123;    public static void test() &#123;       try &#123;           int i = 1 / 0; //执行       &#125;catch (Exception e)&#123;           System.out.println(e);//执行           throw e;//执行       &#125;finally &#123;           System.out.println(&quot;finally被执行&quot;); //执行       &#125;        System.out.println(&quot;我会执行吗？&quot;);//不执行    &#125;    public static void main(String[] args) &#123;        test();    &#125;&#125;</code></pre><p>###大总结<br>1、finally 不受 try、catch、throw 、return的影响，一定会执行<br>2、finally前有return，会先执行return语句，并将结果保存下来，再执行finally块，最后return<br>3、finally前有return，finally中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的return结果，并返回</p><p>###使用try/catch/finally/throw 处理对线程执行流程的影响<br>1、如果某<code>运行时异常</code>没有被捕获，那么直接中断线程执行</p><pre><code>   public static void main(String[] args) &#123;        String str = (String) new Object();        System.out.println(&quot;不会被执行&quot;);    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-e131bec77d0bad69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>2、某异常被try-catch-finally捕获，线程会继续执行finally之后的代码</p><pre><code>    public static void main(String[] args) &#123;        try &#123;            String str = (String) new Object();        &#125;catch ( Exception e )&#123;          e.printStackTrace();        &#125;finally &#123;        &#125;        System.out.println(&quot;继续执行！&quot;);    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-0ef546950bea3028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>3、如果使用throw抛出异常，则finally之后的代码不会执行</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之接口.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-jie-kou/"/>
      <url>/2022/03/20/java-ji-chu-zhi-jie-kou/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之错误和异常.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-cuo-wu-he-yi-chang/"/>
      <url>/2022/03/20/java-ji-chu-zhi-cuo-wu-he-yi-chang/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13965490-768cbbd2ccc997ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><code>异常和错误有一个共同的基类java.lang.Throwable</code></p><p>###错误<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。<br>比如 栈内存溢出错误(java.lang.StackOverflowError)</p><p>###异常<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。<br>异常(java.lang.Exception)可以分为<br>######非受检异常<br>也叫<code>运行时异常</code> ，它继承了java.lang.RuntimeException类;虽然不是一定要使用try-catch捕获，但是也可以使用之捕获</p><blockquote><p>常见的受检异常有 空指针异常（java.lang.NullPointerException）、除0异常（java.lang.ArithmeticException）、数组越界异常（java.lang.ArrayIndexOutOfBoundsException）、类型强转异常（java.lang.ClassCastException）</p></blockquote><p>######常见运行时异常测试<br>java.lang.NullPointerException</p><pre><code>Object a = null;a.equals(&quot;1&quot;);</code></pre><p> java.lang.ArithmeticException: / by zero</p><pre><code>int i = 1/0;</code></pre><p>java.lang.ArrayIndexOutOfBoundsException</p><pre><code>int[] arr = new int[1];arr[2] = 1;</code></pre><p>java.lang.ClassCastException</p><pre><code> String str = (String) new Object();</code></pre><h6 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h6><p>受检异常必须被try-catch捕获或throws抛出处理，否则idea将报错</p><blockquote><p>常见的受检异常有 反射异常（java.lang.ReflectiveOperationException）、类文件未找到异常（java.lang.ClassNotFoundException）、数据库sql异常（java.sql.SQLException）、文件IO异常（java.io.IOException）</p></blockquote><h6 id="受检异常测试"><a href="#受检异常测试" class="headerlink" title="受检异常测试"></a>受检异常测试</h6><p>我们在写jdbc代码时会遇到这种情况，idea提示异常，需要显式的对异常进行try/catch或者在方法的尾巴上  throws SQLException<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c8bcbd1e3e1af11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>使用try/catch<br><img src="https://upload-images.jianshu.io/upload_images/13965490-be05fdef79dcf70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在方法尾巴上抛出<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c0522d7bcf4f78f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之合理使用if-else.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-he-li-shi-yong-if-else/"/>
      <url>/2022/03/20/java-ji-chu-zhi-he-li-shi-yong-if-else/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e5fa79de51d45271849e7bd">https://juejin.im/post/5e5fa79de51d45271849e7bd</a></p><pre><code>@Around(&quot;dataSourcePointCut()&quot;)    public Object around(ProceedingJoinPoint point) throws Throwable &#123;        //事实上默认数据源是 MASTER        //得到类上的注解        DataSource dataSourceClass = point.getTarget().getClass().getAnnotation(DataSource.class);        //如果类上的注解的参数是SLAVE        if(dataSourceClass != null &amp;&amp; DataSourceNames.SLAVE.getName().equals(dataSourceClass.name()))&#123;            //设置当前线程数据源为SLAVE            DynamicDataSource.setDataSource(DataSourceNames.SLAVE.getName());            logger.info(&quot;设置数据源为&quot; + DataSourceNames.SLAVE);        &#125;        //得到方法上的注解,方法上的注解优先级大于类上的        MethodSignature signature = (MethodSignature) point.getSignature();        Method method = signature.getMethod();        DataSource dataSourceMethod = method.getAnnotation(DataSource.class);        //如果类上的注解的参数是SLAVE        if(dataSourceMethod != null &amp;&amp; DataSourceNames.SLAVE.getName().equals(dataSourceMethod.name()))&#123;            //设置当前线程数据源为SLAVE            DynamicDataSource.setDataSource(DataSourceNames.SLAVE.getName());            logger.info(&quot;设置数据源为&quot; + DataSourceNames.SLAVE);        &#125;else&#123;            //让方法上的注解优先级大于类上的，所以需要写一个else            //设置当前线程数据源为MASTER            DynamicDataSource.setDataSource(DataSourceNames.MASTER.getName());            logger.info(&quot;设置数据源为&quot; + DataSourceNames.MASTER);        &#125;        try &#123;            return point.proceed();        &#125; finally &#123;            DynamicDataSource.clearDataSource();            logger.info(&quot;调用目标方法后，将数据源还原为默认&quot;);        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础命令.md</title>
      <link href="/2022/03/20/java-ji-chu-ming-ling/"/>
      <url>/2022/03/20/java-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>首先确定电脑环境变量配置正确<br>1、直接执行class文件</p><p>进入到文件夹里，看到了HelloWorld.class文件。可以直接执行</p><pre><code>java HelloWorld</code></pre><p>2、运行java文件</p><p>cmd进入java文件路径下<br>编译成字节码.class文件 javac HelloWorld.java<br>运行文件，使用-cp参数指定类文件搜索路径 java -cp D:\ajava\test HelloWorld </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识1-传值和传引用.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-1-chuan-zhi-he-chuan-yin-yong/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-1-chuan-zhi-he-chuan-yin-yong/</url>
      
        <content type="html"><![CDATA[<p>######1、基本类型传复印件</p><pre><code>public static void cr(int a)&#123;    a++;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//2&#125;public static void main(String[] args) &#123;    int a = 1;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//1&#125;</code></pre><p>######2、基本类型的包装类型也传的是复印件</p><pre><code>public static void cr(Integer a)&#123;    a++;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//2&#125;public static void main(String[] args) &#123;    Integer a = 1;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//1&#125;</code></pre><p>######3、String 使用+拼接，也是不同的。String是不可变类</p><pre><code>public static void cr(String a)&#123;    a=a+&quot; kai&quot;;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//yin kai&#125;public static void main(String[] args) &#123;    String a = &quot;yin&quot;;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//yin&#125;</code></pre><p>######4、ArrayList这种复合对象传入的是对象的引用；修改list内部元素对所有引用都生效<br><img src="https://upload-images.jianshu.io/upload_images/13965490-2fb39d3f3630e3f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>public static void cr(List a)&#123;    a.add(4);    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//[1, 2, 3, 4]&#125;public static void main(String[] args) &#123;    ArrayList&lt;Integer&gt; a = new ArrayList();    Collections.addAll(a, 1,2,3);    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//[1, 2, 3, 4]&#125;</code></pre><p>######5、ArrayList 在cr方法中用一个新new的对象赋值，则指向不同的堆内存块了；此时两个list修改不会影响对方<br><img src="https://upload-images.jianshu.io/upload_images/13965490-33f9138e35605045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>public static void cr(List a)&#123;    a = new ArrayList();    Collections.addAll(a, 4,5,6);    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//[4, 5, 6]&#125;public static void main(String[] args) &#123;    ArrayList&lt;Integer&gt; a = new ArrayList();    Collections.addAll(a, 1,2,3);    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//[1, 2, 3]&#125;</code></pre><p>######6、Integer[]、int[]数组传的也是引用</p><pre><code>public static void cr(Integer[] a)&#123;    a[3] = 4;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;public static void main(String[] args) &#123;    Integer[] a = &#123;1,2,3,null&#125;;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;//public static void cr(int[] a)&#123;    a[3] = 4;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;public static void main(String[] args) &#123;    int[] a = new int[4];    a[0] = 1;    a[1] = 2;    a[2] = 3;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;</code></pre><p>######7、自己写的类构造的对象中的传值和传引用</p><pre><code>public class Test &#123;   private String name;    public void setName(String name) &#123;        this.name = name;    &#125;    public void changeName(String name) &#123;        name = &quot;kaikai&quot;;    &#125;    public void changeAge(Integer age) &#123;        age = 22;    &#125;    private void changeTest(Test test)&#123;        test.setName(&quot;kai&quot;);    &#125;    public Test(String name) &#123;        this.name = name;    &#125;    public Test() &#123;    &#125;    public static void main(String[] args) &#123;        Test test1 = new Test();        int age = 20;        test1.changeAge(age);        System.out.println(&quot;age===&gt;&quot;+age); //20        Test test2 = new Test(&quot;yin&quot;);        test2.changeTest(test2);        System.out.println(&quot;test2.name==&gt;&quot;+test2.name);// kai        String str = &quot;xuan&quot;;        test2.changeName(str);        System.out.println(&quot;str===&gt;&quot;+str);//xuan    &#125;&#125;</code></pre><p>这个例子也可以这样理解：使用方法作用域来理解<br>1、我们学过JVM中的栈。每个方法都有一个栈帧，栈帧里面有对应的<code>局部变量表</code>。所以这里打印的age是main方法中的age,而不是changeAge方法中的age</p><pre><code>Test test1 = new Test();int age = 20;test1.changeAge(age);System.out.println(&quot;age===&gt;&quot;+age); //20</code></pre><p>2、这里打印的name是test2对象实例中的name属性</p><pre><code>Test test2 = new Test(&quot;yin&quot;);test2.changeTest(test2);System.out.println(&quot;test2.name==&gt;&quot;+test2.name);// kai</code></pre><p>3、这里打印的str 和第一点一样,是main方法中的str </p><pre><code>String str = &quot;xuan&quot;;test2.changeName(str);System.out.println(&quot;str===&gt;&quot;+str);//xuan</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识2-比较-==-和-equals().md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-2-bi-jiao-he-equals/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-2-bi-jiao-he-equals/</url>
      
        <content type="html"><![CDATA[<h3 id="的用法"><a href="#的用法" class="headerlink" title="== 的用法"></a>== 的用法</h3><p><strong><code>不推荐</code>== 使用在数值类型之间</strong><br>1、 == 使用在包装类型之间，比较的是引用地址</p><p>java中对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，<code>推荐使用equals方法进行判断</code>。</p><pre><code>Integer a1 = -129;Integer b1 = -129;System.out.println(a1==b1);//falseInteger a2 = 128;Integer b2 = 128;System.out.println(a2==b2);//flase</code></pre><p>2、== 两边如果有一个是基本类型的话，比较的是内容</p><pre><code>Integer a1 = -129;int b1 = -129;System.out.println(a1==b1);//trueInteger a2 = 128;int b2 = 128;System.out.println(a2==b2);//true</code></pre><p><strong>==<code>不推荐</code>使用在String之间</strong><br>因为jvm中存在字符串常量池，String a = “yinkai” 的字符串实际上存在常量池里面。而new String(“yinkai”)在jvm堆内存里；因为==比较的是引用，所以返回false</p><pre><code>String a = &quot;yinkai&quot;;String b = new String(&quot;yinkai&quot;);System.out.println(a == b);//false</code></pre><p>###equals()的用法<br><strong>1、<code>推荐</code>字符串之间的比较使用equals()</strong></p><pre><code>String a = &quot;yinkai&quot;;String b = new String(&quot;yinkai&quot;);System.out.println(a.equals(b));//true</code></pre><p><strong>2、<code>推荐</code>数值类型之间的比较使用equals()</strong></p><pre><code>        /**         * -128  127         */Integer a1 = -129;Integer b1 = -129;System.out.println(a1==b1);//falseSystem.out.println(a1.equals(b1));//trueInteger a2 = -128;Integer b2 = -128;System.out.println(a2==b2);//trueSystem.out.println(a2.equals(b2));//true</code></pre><p><strong>3、<code>推荐</code>Long 与 int 比较时使用equals()是个大坑！</strong><br>看代码：</p><pre><code>   @Test    public  void demo2()&#123;        Integer integer100 = 100;        int int100 = 100;        Long long200 = 200l;        System.out.println(long200.equals(integer100 + int100));    &#125;</code></pre><p>结果输出为false。<br>分析过程：<br>①integer100+int100就会得到一个类型为int且value为200的基础数据类型a<br>②Long的equals方法将a进行装箱，装箱所得到的是类型为Integer的对象b<br>③因为b与long200为不同的类型的对象，所以输出false；</p><p>总结：Long 与 相同值的 包装类 用equals比较时，如果传入的类型不是Long,那么全部返回false</p><p>###结论</p><ul><li>String使用equals()比较</li><li>数值使用equals()比较</li></ul><p>###测试</p><pre><code>  public static void main(String[] args)&#123;        System.out.println(&quot;==========test1========&quot;);        test1();        System.out.println(&quot;==========test2========&quot;);        test2();        System.out.println(&quot;==========test3========&quot;);        test3();        System.out.println(&quot;==========test4========&quot;);        test4();        System.out.println(&quot;==========test5========&quot;);        test5();        System.out.println(&quot;==========test6========&quot;);        test6();        System.out.println(&quot;==========test7========&quot;);        test7();    &#125;    public static void test1()&#123;        Integer m=127;        Integer n=127;        System.out.println(m==n);//true        System.out.println(m.equals(n));//true    &#125;    public static void test2()&#123;        Integer m=127;        int n=127;        System.out.println(m==n);//true    &#125;    public static void test3()&#123;        Integer m=127;        Integer n=new Integer(127);        System.out.println(m==n);//false        System.out.println(m.equals(n));//true    &#125;    public static void test4()&#123;        Integer m=127;        Integer n=Integer.valueOf(127);        System.out.println(m==n);//true        System.out.println(m.equals(n));//true    &#125;    public static void test5()&#123;        Integer m=128;        Integer n=128;        System.out.println(m==n);//false        System.out.println(m.equals(n));//true    &#125;    public static void test6()&#123;        Integer m=128;        int n=128;        System.out.println(m==n);//true    &#125;    public static void test7()&#123;        Integer m=128;        Integer n=new Integer(128);        System.out.println(m==n);//false        System.out.println(m.equals(n));//true    &#125;</code></pre><p>1、int 跟Integer、Integer.valueOf()、new Integer()做==比较时，只比较两者的数值，数值相等即为true.根据这个原则，test2()和test6()都是输出为true;<br>   <code>“==” 等号只要作用在基本类型之上，那么就是比较内容</code></p><p>2、When boxing (transforming int to Integer)the compiler uses a cache for small values (-128 - 127) and reuses the same objects for the same values.<br>在-128-127之间时，包括边界值，Integer m=127,Integer n=Integer.valueOf(127),都会将127装箱成Integer类型，并且m和n共用同一个127的Integer类型。<br>根据这个原则，test1()输出为true,true;</p><p>3、当值不在-128-127之内时，Integer m=128,Integer n= 128或者Integer n=Integer.valueOf(128)，也会将128装箱成Integer类型，但这时不再重用同一个Integer对象，而是各自一个了。此时的Integer<br>m=128或Integer m=Integer.valueOf(128)，都相当于new了一个Integer对象。</p><p>4、当一个int数值用new创建时，无论在不在-128-127之间，都会创建一个Integer对象，而且不会重用</p><p>5、Integer m=数值和Integer m=Integer.valueOf(数值）的效果一样的，两者可以互换。他们在-128-127之内时，会重用Integer,在之外，不会重用。</p><p>看看java.lang.Integer.valueOf(int)方法的源码，就一目了然了。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9347822769ecf43e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识3-数值类型之间的类型转换.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-3-shu-zhi-lei-xing-zhi-jian-de-lei-xing-zhuan-huan/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-3-shu-zhi-lei-xing-zhi-jian-de-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>###java中基本类型数值的取值范围和占用字节<br>要明白java中的类型转换问题必须先要了解java中的各个基本数据类型数值类型的占用字节和取值范围<br>类型| 占用字节|   取值范围<br>-|-|-<br>byte|1字节| -128 ~ 127<br>short| 2字节|-32768 ~ 32767<br>int| 4字节| -2147483648 ~ 2147483647<br>long| 8字节| -9223372036854775808 ~ 9223372036854775807<br>float|    4字节|大约±3.40282347E+38F(6~7位有效数字)<br>double|8字节|大约±1.79769313486231570E+308(15位有效数字)<br>byte==&gt;字节<br>bit==&gt;位<br>关系==&gt;1byte = 8bit</p><pre><code>boolean  8bit/1bytebyte      8bit/1bytechar      16bit/2byteshort     16bit/2bytefloat      32bit/4byteint        32bit/4bytelong      64bit/8bytedouble  64bit/8byte</code></pre><p>###隐式类型转换<br>从表示范围小的类型转换为表示范围大的类型，可以直接转换，称为隐式转换。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9e13e5b4ba06bca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>6个实心箭头箭头表示无信息丢失的转换;</li><li>3个虚箭头表示可能有精度损失的转换.</li></ul><p><strong>无信息丢失的隐式转换</strong></p><ul><li><p>byte==&gt;short</p></li><li><p>short==&gt;int</p></li><li><p>int==&gt;long</p></li><li><p>int==&gt;double</p></li><li><p>float==&gt;double</p></li><li><p>char==&gt;int<br>~~~<br>  public static void main(String[] args) {</p><pre><code>  byte a = 97;  short b = a;//byte==&gt;short  System.out.println(b);//97  int c = b;//short==&gt;int  System.out.println(c);//97  long d = c;//int==&gt;long  System.out.println(d);//97  double e = c;//int==&gt;double  System.out.println(e);//97.0  float f = new Float(97);  double g = f;//float==&gt;double  System.out.println(g);//97.0  char h = &#39;a&#39;;  int i = h;//char==&gt;int  System.out.println(i);//97</code></pre></li></ul><pre><code>&#125;</code></pre><pre><code>**有信息丢失的隐式转换**- int==&gt;float- long==&gt;float- long==&gt;double</code></pre><pre><code>public static void main(String[] args) &#123;    int a = 999999999;    float b = a;//int==&gt;float    System.out.println(b);//1.0E9    long c = 999999999999999999L;    float d = c;//long==&gt;float    System.out.println(d);//9.9999998E17    long e = 999999999999999999L;    double f = e;//long==&gt;double    System.out.println(f);//1.0E18&#125;</code></pre><pre><code>###显式类型转换强制类型转换（显式类型转换），从存储范围大的类型到存储范围小的类型。该类类型转换很可能存在精度的损失。`强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。`</code></pre><pre><code>public static void main(String[] args) &#123;    int a = 127;    byte b = (byte)a;//int==&gt;byte    System.out.println(b);//127    int c = 128;    byte d = (byte)c;//int==&gt;byte    System.out.println(d);//-128 出现精度丢失&#125;</code></pre><pre><code>###运算时会产生精度提升当使用上面两个数值进行二元操作时,先要将两个操作数转换为同一类型,然后再进行计算。规则:两个数中小类型的值将自动转换为大类型的值。小转大可以,但是大转小会损失精度,则需要强制转换。这里的b是byte类型的；`b*3`中，3是int类型。`b*3`精度提升成int类型了。所以这里又赋值给b会报错：`Error:(16, 13) java: 不兼容的类型: 从int转换到byte可能会有损失`,因此需要进行强制转换![image.png](https://upload-images.jianshu.io/upload_images/13965490-75ca29d767944bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>byte b = 127;<br>b=(byte)(b*3);<br>System.out.println(b);//125 出现精度丢失</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识4.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-4/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-4/</url>
      
        <content type="html"><![CDATA[<p><strong>1、++i 和 i++的区别</strong></p><ul><li><p>i++先赋值后增加</p></li><li><p>++i 先增加后赋值</p></li></ul><pre><code>public static void main(String[] args) &#123;    int i = 0;    System.out.println(i++);//0  此时i的值已经为1，i++的返回值只是执行i++之前i的副本    System.out.println(i);//1&#125;public static void main(String[] args) &#123;    int i = 0;    System.out.println(++i);//1  此时i的值为1，++i的值返回值就是i的值    System.out.println(i);//1&#125;</code></pre><ul><li>一个特殊的例子 i=i++;</li></ul><p>执行i++之前i的值的副本为0，副本赋值给i了。那么输出0</p><pre><code>public static void main(String[] args) &#123;    int i = 0;    i=i++;    System.out.println(i);//0  执行i++之前i的值的副本为0，副本赋值给i了。那么输出0&#125;</code></pre><p><strong>2、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</strong></p><ul><li><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-18c3d0bd55fc2f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>有多个punlic类，报错~<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9cd324d70be0e779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>可以没有public类，类名可以不和文件名保持一致<br><img src="https://upload-images.jianshu.io/upload_images/13965490-0aef3498bf11c61b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><ul><li>一个java文件里包含多个类的话，编译一个java文件会生成多个class文件<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9fd9561d1e34aefe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><strong>3、数值类型的错误</strong></p><p>1、float i = 0.1 报错<br>java中出现的浮点小数默认是双精度，因此需要使用double类型来接收~<br><img src="https://upload-images.jianshu.io/upload_images/13965490-205dfe896832492a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>2、Long j = 121321; 报错<br>java中的整数默认是int类型,如果需要直接赋值给Long类型的话。后面需要加一个L;直接赋值给long类型却是正确的！因为存在int到long的隐式类型转换<br><img src="https://upload-images.jianshu.io/upload_images/13965490-7904ccb7806c1db0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>4、&amp;和&amp;&amp;的区别</strong></p><ul><li><p>&amp;&amp;具有<code>短路</code>的功能，即如果第一个表达式为false，则不再计算第二个表达式；例如，对于if(str != null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。</p></li><li><p>&amp;还可以用作<code>位运算符</code>，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 </p></li></ul><p><strong>5、switch语句变量类型</strong></p><ul><li><p>在jdk 1.7 之前，switch 只能支持 byte、short、char、int 这几个基本数据类型和其对应的封装类型。switch后面的括号里面只能放int类型的值，但由于byte，short，char类型，它们会 自动 转换为int类型（精精度小的向大的转化），所以它们也支持。</p></li><li><p>Jdk1.7之后整型、枚举类型，boolean，字符串都可以。</p></li></ul><p><strong>6、char型变量中能不能存贮一个中文汉字？</strong><br>　char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：<code>unicode编码的汉字占用两个字节</code>，所以，char类型的变量也是占用两个字节。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-1adedb499236b9bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  编译后<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c60a0b7762ca4fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>7、使用final关键字修饰一个引用变量时，是引用不能变，还是引用的对象不能变？</strong><br>　使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c5f2e3e9a3b67a12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>8、java中构造对象的几种方式</strong></p><ul><li>用<code>new</code>语句创建对象，这是最常见的创建对象的方法。显式的调用构造函数 </li><li> 运用<code>反射</code>手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li>调用对象的<code>clone()</code>方法。是在内存上对已有对象的影印，所以不会调用构造函数 </li><li>运用<code>反序列化</code>手段，调用java.io.ObjectInputStream对象的 readObject()方法。是从文件中还原类的对象，也不会调用构造函数。</li></ul><p><strong>9、ArrayList list = new ArrayList(20);中的list扩容次数</strong><br>我们知道ArrayList 的初始容量为10，加载因子为0.75，扩容为原来的1.5倍。但是这里构造list的时候传入了20为初始容量，所以不会进行扩容</p><p><strong>10、为什么泛型不可以有基本类型</strong><br>因为Java中的泛型是通过编译时的<code>类型擦除</code>来完成的，当泛型被类型擦除后都变成Object类型。但是Object类型不能指代像int，double这样的基本类型只能指代Integer，Double这样的引用类型。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识5-新建实例时各部分执行顺序.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-5-xin-jian-shi-li-shi-ge-bu-fen-zhi-xing-shun-xu/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-5-xin-jian-shi-li-shi-ge-bu-fen-zhi-xing-shun-xu/</url>
      
        <content type="html"><![CDATA[<p>我们先来看一个例子</p><pre><code>package test;class HelloA &#123;    public HelloA() &#123;        System.out.println(&quot;父类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 1 执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 2 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 1 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 2 执行&quot;);    &#125;&#125; class HelloB extends HelloA &#123;    public HelloB() &#123;        System.out.println(&quot;子类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;子类实例块 1 执行&quot;);    &#125;     &#123;         System.out.println(&quot;子类实例块 2 执行&quot;);     &#125;    static &#123;        System.out.println(&quot;子类静态块 1 执行&quot;);    &#125;     static &#123;         System.out.println(&quot;子类静态块 2 执行&quot;);     &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;执行 new HelloB()&quot;);        new HelloB();//①        System.out.println(&quot;new HelloB() 执行完毕&quot;);        System.out.println(&quot;===========================&quot;);        System.out.println(&quot;执行 new HelloA()&quot;);        new HelloA();//②        System.out.println(&quot;new HelloA() 执行完毕&quot;);    &#125;&#125;</code></pre><p>####运行结果<br>父类静态块 1 执行<br>父类静态块 2 执行<br>子类静态块 1 执行<br>子类静态块 2 执行<br>执行 new HelloB()<br>父类实例块 1 执行<br>父类实例块 2 执行<br>父类构造器执行<br>子类实例块 1 执行<br>子类实例块 2 执行<br>子类构造器执行<br>new HelloB() 执行完毕<br>===========================<br>执行 new HelloA()<br>父类实例块 1 执行<br>父类实例块 2 执行<br>父类构造器执行<br>new HelloA() 执行完毕</p><p>####上面代码的执行流程可以分析成这样流程<br>父类静态块 &gt; 子类静态块 &gt; main方法开始执行 &gt; 执行 new 子类() ①&gt;执行new 父类()②</p><p>①：父类实例块&gt;父类构造器&gt;子类实例块&gt;子类构造器<br>②：子类实例块&gt;子类构造器</p><ul><li>静态块只执行一次，在main方法之前便执行</li><li>父类静态块在子类静态块之前执行</li><li>多个静态块执行顺序就是定义的顺序，由上到下执行</li><li>多个实例块执行顺序就是定义的顺序，由上到下执行</li><li>实例块在构造方法之前执行</li><li>父类的实例块和构造器在子类的实例块和构造器之前执行</li></ul><p>####误区：<br>  1、在父类静块中访问子类静态属性，只会的到子类静态属性的默认值，因为子类还没有初始化；int类型的默认值是0，所以下面的例子打印出HelloB.i的值为0<br>如：</p><pre><code>class HelloA &#123;    public HelloA() &#123;        System.out.println(&quot;父类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 1 执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 2 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 1 执行&quot;);        int i = HelloB.i;        System.out.println(i);    &#125;    static &#123;        System.out.println(&quot;父类静态块 2 执行&quot;);    &#125;&#125; class HelloB extends HelloA &#123;    static  int i  = 1;    public HelloB() &#123;        System.out.println(&quot;子类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;子类实例块 1 执行&quot;);    &#125;     &#123;         System.out.println(&quot;子类实例块 2 执行&quot;);     &#125;    static &#123;        System.out.println(&quot;子类静态块 1 执行&quot;);    &#125;     static &#123;         System.out.println(&quot;子类静态块 2 执行&quot;);     &#125;    public static void main(String[] args) &#123;    &#125;&#125;</code></pre><p>执行结果：<br>父类静态块 1 执行<br>0<br>父类静态块 2 执行<br>子类静态块 1 执行<br>子类静态块 2 执行</p><p>2、在实例块中访问构造器中赋值的类属性，只会的到实例属性的默认值；</p><pre><code>class HelloA &#123;    public HelloA() &#123;        System.out.println(&quot;父类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 1 执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 2 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 1 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 2 执行&quot;);    &#125;&#125; class HelloB extends HelloA &#123;    int i ;    public HelloB() &#123;        i = 1;        System.out.println(&quot;子类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;子类实例块 1 执行&quot;);        System.out.println(i);    &#125;     &#123;         System.out.println(&quot;子类实例块 2 执行&quot;);     &#125;    static &#123;        System.out.println(&quot;子类静态块 1 执行&quot;);    &#125;     static &#123;         System.out.println(&quot;子类静态块 2 执行&quot;);     &#125;    public static void main(String[] args) &#123;        new HelloB();    &#125;&#125;</code></pre><p>执行结果：</p><p>父类静态块 1 执行<br>父类静态块 2 执行<br>子类静态块 1 执行<br>子类静态块 2 执行<br>父类实例块 1 执行<br>父类实例块 2 执行<br>父类构造器执行<br>子类实例块 1 执行<br>0<br>子类实例块 2 执行<br>子类构造器执行</p><p>3、在静态块中访问实例属性,idea直接报错了<br><img src="https://upload-images.jianshu.io/upload_images/13965490-3422b25d4e1a364d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###静态块执行即类被虚拟机加载<br>什么时候类会被加载？可以看看我的这篇文章<br><a href="https://www.jianshu.com/p/558750148f36">https://www.jianshu.com/p/558750148f36</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-字符串操作.md</title>
      <link href="/2022/03/20/java-zi-fu-chuan-cao-zuo/"/>
      <url>/2022/03/20/java-zi-fu-chuan-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>###基础使用<br>1、java字符串占位符替换</p><pre><code>java.text.MessageFormat.format(&quot;该域名&#123;0&#125;被访问了 &#123;1&#125; 次.&quot;, domain , iVisit);</code></pre><p>或者使用</p><pre><code>String domain = &quot;www.baidu.com&quot;;int iVisit = 0;System.out.println(String.format(&quot;该域名%s被访问了%s次.&quot;, domain , iVisit));</code></pre><p>注意：常见HTML标签的属性对用法有干扰，此时需要使用转义<br>比如：</p><pre><code>String pattern = &quot;&lt;div class=\&quot;content-img-wrapper\&quot;&gt;&lt;div class=\&quot;content-img\&quot; data-pending=\&quot;false\&quot; data-src=&#123;0&#125; alt=&#123;1&#125; style=\&quot;width: 100%; height: 0px; padding-top: 66.5%; background-image: url(&#123;2&#125;);\&quot;&gt;&lt;/div&gt;&lt;div class=\&quot;content-img-desc\&quot;&gt;&lt;div class=\&quot;triangle\&quot;&gt;&lt;/div&gt;&#123;3&#125;&lt;/div&gt;&lt;/div&gt;&quot;;String format = MessageFormat.format(pattern, &quot;\&#39;http://bai\&#39;&quot;, &quot;\&#39;你好\&#39;&quot;, &quot;\&#39;http://bai\&#39;&quot;, &quot;你好&quot;);System.out.println(format);</code></pre><p>还可以直接：替代方法 相比字符串的格式化操作，使用字符串的替换更加安全，避免因为疏忽或者考虑不全等带来的崩溃问题。 </p><pre><code>String s = &quot;%country%/%city%&quot;.replace(&quot;%country%&quot;, &quot;China&quot;).replace(&quot;%city%&quot;, &quot;Beijing&quot;);</code></pre><p>2、字符串中替换第一个出现的字符</p><pre><code>String join = &quot;hello,hello php&quot;;join = join.replaceFirst(&quot;hello&quot;, &quot;你好&quot;);System.out.println(join);    //输出：你好 java,hello php</code></pre><p>3、数组join成字符串<br>Jdk8的新方法，不用通过数组，直接连接字符串</p><pre><code>String str = String.join(&quot;,&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre><p>当然也提供了重载</p><pre><code>String[] arr = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;String join = String.join(&quot;,&quot;, arr);</code></pre><p>jdk1.8之前都是用apache的commons工具类吧</p><pre><code>org.apache.commons.lang3.StringUtils.join(articleIds,&quot;,&quot;);</code></pre><p>4、字符串前缀和后缀判断<br>如果字符串以指定的前缀开始，则返回 true；否则返回 false。</p><pre><code>String Str = &quot;www.runoob.com&quot;;System.out.print(&quot;返回值 :&quot; );System.out.println(Str.startsWith(&quot;www&quot;) );System.out.print(&quot;返回值 :&quot; );System.out.println(Str.startsWith(&quot;runoob&quot;) );System.out.print(&quot;返回值 :&quot; );System.out.println(Str.startsWith(&quot;runoob&quot;, 4) );</code></pre><p>同样 endsWith 就是针对后缀的方法</p><p>5、大小写转换</p><ul><li>小写转大写<pre><code>String str = &quot;nihao cai xu kun &quot;;String s = str.toUpperCase();System.out.println(s);</code></pre></li><li>大写转小写<pre><code>String str = &quot;NIHAO CAI XU KUN  &quot;;String s = str.toLowerCase();System.out.println(s);</code></pre></li></ul><p>6、字符串非空判断</p><ul><li> null 、“”、 “  ” 都被算为空<pre><code>org.apache.commons.lang3.StringUtils.isBlank(string) </code></pre></li><li>null、”” 为空<pre><code>org.apache.commons.lang3.StringUtils.isEmpty(string) </code></pre></li><li>“” 为空<pre><code>String.isEmpty()</code></pre>7、判断字符串中是否存在某个字符<pre><code>if(&quot;yinkai&quot;.indexOf(&quot;m&quot;) == -1)&#123;          System.out.println(&quot;no exit&quot;);&#125;</code></pre>或<pre><code>if(!&quot;yinkai&quot;.contains(&quot;m&quot;))&#123;     System.out.println(&quot;no exit&quot;);&#125;</code></pre>8、截取字符串</li><li>按字符索引截取<pre><code>String substring = &quot;yin_kai&quot;.substring(4,7);System.out.println(substring);</code></pre></li></ul><p>9、忽略大小写的比较内容</p><pre><code>if(&quot;XXX&quot;.equalsIgnoreCase(&quot;xxx&quot;))&#123;   System.out.println(&quot;yes&quot;);&#125;</code></pre><p>10、把字符串按 “,” 分为字符串数组</p><pre><code>String[] a= &quot;1,2,3,4,5&quot;.split(&quot;,&quot;);for (String s : a) &#123;       System.out.println(s);&#125;</code></pre><p>11、将字符串数组join成字符串</p><pre><code>String[] arr = &#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;&#125;;String join = String.join(&quot;,&quot;, arr);System.out.println(join);</code></pre><p>12、字符串去除空格</p><ul><li>去除首尾空格（只限于半角空格）<pre><code>String trim = &quot; 1 2 &quot;.trim();System.out.println(trim);</code></pre></li><li>去除所有空格（只限于半角空格）<pre><code>String trim = &quot; 1 2 &quot;.replaceAll(&quot; &quot;, &quot;&quot;);System.out.println(trim);</code></pre></li><li>去除所有空格，包括全角空格<pre><code>String trim = &quot; 1 ｄｓ 2 &quot;.replaceAll(&quot;　| &quot;, &quot;&quot;);System.out.println(trim);</code></pre></li></ul><p>13、去除半角空格、回车、换行符、制表符（只限于半角）</p><pre><code>    public static String replaceBlank(String str) &#123;        String dest = &quot;&quot;;        if (str!=null) &#123;            Pattern p = Pattern.compile(&quot;\\s*|\t|\r|\n&quot;);            Matcher m = p.matcher(str);            dest = m.replaceAll(&quot;&quot;);        &#125;        return dest;    &#125;    public static void main(String[] args) &#123;        System.out.println(replaceBlank(&quot;just \n  \t    \t 　do it!&quot;));    &#125;</code></pre><p>14、字符串拼接</p><ul><li>使用 +</li><li>使用 concat方法<pre><code>String concat = &quot;yin&quot;.concat(&quot;kai&quot;);System.out.println(concat);</code></pre></li><li>使用StringBuilder/StringBuffer</li></ul><p>###实用场景<br>1、获取文件后缀</p><pre><code>String orginalFilename = &quot;file.txt&quot;;String substring = orginalFilename.substring(orginalFilename.lastIndexOf(&quot;.&quot;));// 返回 图片 &quot;1.jpg&quot; 的后缀： &quot;.jpg&quot;System.out.println(substring);</code></pre><p>2、截取目标字符串的指定子字符串之后的字符串</p><pre><code>String str=&quot;abcdefg&quot;;System.out.println(str.substring(str.indexOf(&quot;c&quot;)+1));</code></pre><p>3、干掉指定sql字符串中第一个AND</p><pre><code>String sql = &quot;select * from t_customer WHERE AND name=&#39;张三&#39; AND sex=&#39;男&#39; AND station=&#39;百度&#39; AND salary BETWEEN 5001 AND 10000&quot;;String s = org.apache.commons.lang.StringUtils.replaceOnce(sql, &quot; AND&quot;, &quot;&quot;);System.out.println(s);</code></pre><p>###生成字符串</p><p>生成32位的md5摘要</p><pre><code>System.out.println(DigestUtils.md5DigestAsHex(&quot;1234&quot;.getBytes()));</code></pre><p>生成32位的uuid</p><pre><code> String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);</code></pre><p>###字符串转码</p><pre><code>String string = new String(str.toString().getBytes(), &quot;UTF-8&quot;);</code></pre><blockquote><p>GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换：<br>GBK、GB2312－－Unicode－－UTF8<br>UTF8－－Unicode－－GBK、GB2312</p></blockquote><p>GBK转UTF-8</p><pre><code>    public static byte[] getUTF8BytesFromGBKString(String gbkStr) &#123;        int n = gbkStr.length();        byte[] utfBytes = new byte[3 * n];        int k = 0;        for (int i = 0; i &lt; n; i++) &#123;            int m = gbkStr.charAt(i);            if (m &lt; 128 &amp;&amp; m &gt;= 0) &#123;                utfBytes[k++] = (byte) m;                continue;            &#125;            utfBytes[k++] = (byte) (0xe0 | (m &gt;&gt; 12));            utfBytes[k++] = (byte) (0x80 | ((m &gt;&gt; 6) &amp; 0x3f));            utfBytes[k++] = (byte) (0x80 | (m &amp; 0x3f));        &#125;        if (k &lt; utfBytes.length) &#123;            byte[] tmp = new byte[k];            System.arraycopy(utfBytes, 0, tmp, 0, k);            return tmp;        &#125;        return utfBytes;    &#125;    public static void main(String[] args) throws IllegalAccessException, PkiException, InvocationTargetException &#123;        try &#123;            byte[] str = &quot;支持™&quot;.getBytes(&quot;gbk&quot;);            String gbkStr = new String(str, &quot;gbk&quot;);            String utf8 = new String(getUTF8BytesFromGBKString(gbkStr), &quot;UTF-8&quot;);            System.out.println(utf8);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-字符串拼接方式-+-、-concat-和-StringBuilder的性能比较.md</title>
      <link href="/2022/03/20/java-zi-fu-chuan-pin-jie-fang-shi-concat-he-stringbuilder-de-xing-neng-bi-jiao/"/>
      <url>/2022/03/20/java-zi-fu-chuan-pin-jie-fang-shi-concat-he-stringbuilder-de-xing-neng-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p>###字符串的concat()方法</p><pre><code>    /**     * Concatenates the specified string to the end of this string.     * &lt;p&gt;     * If the length of the argument string is &#123;@code 0&#125;, then this     * &#123;@code String&#125; object is returned. Otherwise, a     * &#123;@code String&#125; object is returned that represents a character     * sequence that is the concatenation of the character sequence     * represented by this &#123;@code String&#125; object and the character     * sequence represented by the argument string.&lt;p&gt;     * Examples:     * &lt;blockquote&gt;&lt;pre&gt;     * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot;     * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot;     * &lt;/pre&gt;&lt;/blockquote&gt;     *     * @param   str   the &#123;@code String&#125; that is concatenated to the end     *                of this &#123;@code String&#125;.     * @return  a string that represents the concatenation of this object&#39;s     *          characters followed by the string argument&#39;s characters.     */    public String concat(String str) &#123;        int otherLen = str.length();        if (otherLen == 0) &#123;            return this;        &#125;        int len = value.length;        #使用 Arrays.copyOf()扩容        char buf[] = Arrays.copyOf(value, len + otherLen);        #使用 getChars()插入字符        str.getChars(buf, len);        # 使用到了new关键字拼接出来的字符串也是一个新对象        return new String(buf, true);    &#125;</code></pre><p>####concat和+、StringBuild相比的字符串拼接效率如何</p><pre><code>/** * @author ceshi * @Title: * @Package * @Description: * @date 2020/2/218:03 */public class HelloTest &#123;    /**     * 计算concat所用时间     */    public static void str1()&#123;        String s1 = &quot;yinkai&quot;;        String str1 = &quot;&quot;;        long str1Start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000; i++) &#123;            str1 = str1.concat(s1);        &#125;        long str1End = System.currentTimeMillis();        System.out.println(&quot;concat计算时间为：&quot; + (str1End - str1Start)+&quot;  &quot;+str1.length());    &#125;    /**     * 计算+所用时间     */    public static void str2()&#123;        String s2 = &quot;yinkai&quot;;        String str2 = &quot;&quot;;        long str2Start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000; i++) &#123;            str2 = str2 + s2;        &#125;        long str2End = System.currentTimeMillis();        System.out.println(&quot;+计算时间为：&quot; + (str2End - str2Start)+&quot;  &quot;+str2.length());    &#125;    /**     * 计算stringBuilder所用时间     */    public static void str3()&#123;        String s3 = &quot;yinkai&quot;;        String str3 = &quot;&quot;;        long str3Start = System.currentTimeMillis();        StringBuilder stringBuilder = new StringBuilder(str3);        for (int i = 0; i &lt; 100000; i++) &#123;            stringBuilder.append(s3);        &#125;        long str3End = System.currentTimeMillis();        System.out.println(&quot;StringBuilder计算时间为：&quot; + (str3End - str3Start)+&quot;  &quot;+stringBuilder.toString().length());    &#125;    public static void main(String[] args) &#123;        str1();//14036        str2();//52531        str3();//10    &#125;&#125;</code></pre><ul><li>实验结果<br>性能上 StringBuilder &gt; concat &gt; +</li><li>使用建议<br>一两个字符串之间的拼接推荐使用concat ，多了就使用StringBuilder</li></ul><p>+一般用在非字符串和字符串之间的拼接中</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-实现按Map的value排序.md</title>
      <link href="/2022/03/20/java-shi-xian-an-map-de-value-pai-xu/"/>
      <url>/2022/03/20/java-shi-xian-an-map-de-value-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自弃者天弃之</p></blockquote><p>如果要实现按value排序，不能采用SortedMap结构比如TreeMap，因为SortedMap是按key排序的Map，而不是按value排序</p><p>可以使用ArrayList做排序过渡，然后构建一个LinkedHashMap</p><pre><code>package com.springboot.study.demo1;import java.util.*;public class Test &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() &#123;&#123;            put("3", "1");            put("1", "2");            put("2", "3");        &#125;&#125;;        Map sorted1 = sortByValue(map, true);        Map sorted2 = sortByValue(map, false);        System.out.println(sorted1);        System.out.println(sorted2);    &#125;    /**     * 实现map的value排序     *     * @param map     * @param reverse     * @return     */    public static Map sortByValue(Map map, final boolean reverse) &#123;        //将Map转为 List&lt;Map.Entry&gt;        List list = new ArrayList(map.entrySet());        //在 List&lt;Map.Entry&gt; 内部按元素getValue大小排序        Collections.sort(list, new Comparator() &#123;            public int compare(Object o1, Object o2) &#123;                if (reverse) &#123;                    return -((Comparable) ((Map.Entry) (o1)).getValue())                            .compareTo(((Map.Entry) (o2)).getValue());                &#125;                return ((Comparable) ((Map.Entry) (o1)).getValue())                        .compareTo(((Map.Entry) (o2)).getValue());            &#125;        &#125;);        //将有序的List转为 LinkedHashMap，使用LinkedHashMap做插入顺序排序        Map result = new LinkedHashMap(map.size());        for (Iterator it = list.iterator(); it.hasNext(); ) &#123;            Map.Entry entry = (Map.Entry) it.next();            result.put(entry.getKey(), entry.getValue());        &#125;        list = null;        return result;    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-aeac6b12e3b914a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-小技巧1，多表join时。提出类型、部门等在程序中兑换成名字.md</title>
      <link href="/2022/03/20/java-xiao-ji-qiao-1-duo-biao-join-shi-ti-chu-lei-xing-bu-men-deng-zai-cheng-xu-zhong-dui-huan-cheng-ming-zi/"/>
      <url>/2022/03/20/java-xiao-ji-qiao-1-duo-biao-join-shi-ti-chu-lei-xing-bu-men-deng-zai-cheng-xu-zhong-dui-huan-cheng-ming-zi/</url>
      
        <content type="html"><![CDATA[<p>list转map。使用id做key，name做value</p><pre><code>    private Map&lt;String, String&gt; getChannel() &#123;        List&lt;MgbChannel&gt; list = channelService.list(new LambdaQueryWrapper&lt;MgbChannel&gt;().eq(MgbChannel::getDelStatus, DelFlag.EFFECTIVE.getIndex()));        return list.stream().collect(Collectors.toMap(MgbChannel::getChannelKey, MgbChannel::getChannelName, (k1, k2) -&gt; k1));    &#125;    private Map&lt;String,String&gt; getProductCategory() &#123;        List&lt;ProductCategory&gt; list = productCategoryService.list();        return list.stream().collect(Collectors.toMap(ProductCategory::getCatNo, ProductCategory::getCatName, (k1, k2) -&gt; k1));    &#125;</code></pre><p>使用如下：</p><pre><code>    @Override    public GbmResult selectMgbGoodsPage(Page&lt;MgbGoods&gt; page, MgbGoodsDto dto) &#123;        Page&lt;MgbGoodsVo&gt; mgbGoodsVoPage = mgbGoodsMapper.selectMgbGoodsPage(page, dto);        //品类        Map&lt;String, String&gt; productCategoryMap = getProductCategory();        //渠道        Map&lt;String, String&gt; channelMap = getChannel();        List&lt;MgbGoodsVo&gt; records = mgbGoodsVoPage.getRecords();        for (MgbGoodsVo vo:records) &#123;            //获取品类名称            //一级            vo.setCatRootName(productCategoryMap.get(vo.getCatRootNo()));            //二级            vo.setCatParentName(productCategoryMap.get(vo.getCatParentNo()));            //三级            vo.setCatChildName(productCategoryMap.get(vo.getCatChildNo()));            //上架渠道            vo.setChannelName(channelMap.get(vo.getChannelKey()));            //销量            //商品状态            vo.setStateName(MgbGoodsStateEnum.getMsgByIndex(vo.getState()));            //获取0扣点采集价和代发价//            getZeroPointsPrice(vo);        &#125;        return GbmResult.success(new PageBean(mgbGoodsVoPage));    &#125;</code></pre><p>这样就能代替大表的subquery了！！！</p><p>###value为实体类对象</p><pre><code>    /**     * 获取所有供应商名、售后地址，  supplierNo==&gt;supplierName,refundAddress     * @return     */    @Cacheable(value = &quot;getSupplierBySupplierNoMap&quot;)    @Override       public Map&lt;String, Supplier&gt; getSupplierBySupplierNoMap() &#123;        List&lt;Supplier&gt; list = list(new LambdaQueryWrapper&lt;Supplier&gt;().select(Supplier::getSupplierNo, Supplier::getSupplierName,Supplier::getRefundAddress));        return list.stream().collect(Collectors.toMap(Supplier::getSupplierNo, a -&gt; a, (k1, k2) -&gt; k1));    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-工具之Collections中的sort方法如何比较元素？.md</title>
      <link href="/2022/03/20/java-gong-ju-zhi-collections-zhong-de-sort-fang-fa-ru-he-bi-jiao-yuan-su/"/>
      <url>/2022/03/20/java-gong-ju-zhi-collections-zhong-de-sort-fang-fa-ru-he-bi-jiao-yuan-su/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-异常处理思路.md</title>
      <link href="/2022/03/20/java-yi-chang-chu-li-si-lu/"/>
      <url>/2022/03/20/java-yi-chang-chu-li-si-lu/</url>
      
        <content type="html"><![CDATA[<p>什么时候只需打印异常信息，什么时候又需要抛出异常？</p><p>1、影响正常业务流程的异常做抛出自定义异常处理<br>   像是参数非空判断、重要业务文件io流异常、</p><p>2、不影响正常业务流程的异常只需打印一下异常日志<br> 像是 记录操作日志到数据库、删除中间生成的临时文件捕获的异常就是属于这类不影响正常业务流程的！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-异常处理规范.md</title>
      <link href="/2022/03/20/java-yi-chang-chu-li-gui-fan/"/>
      <url>/2022/03/20/java-yi-chang-chu-li-gui-fan/</url>
      
        <content type="html"><![CDATA[<ol><li><p>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj != null) {…} 反例：try { obj.method(); } catch (NullPointerException e) {…} </p></li><li><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。 </p></li><li><p><code>中招</code>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。<code>对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理</code>。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p></li></ol><ol start="4"><li><p><code>中招</code>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p><code>注意</code>【强制】有try块放到了事务代码中，catch异常后（不进行下一步抛出），如果需要回滚事务，一定要注意手动回滚事务。</p></li></ol><ol start="6"><li>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</li></ol><ol start="7"><li><p> <code>注意</code>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p><pre><code>private int x = 0;public int checkReturn() &#123;try &#123;// x等于1，此处不返回return ++x;&#125; finally &#123;// 返回的结果是2return ++x;&#125;&#125;</code></pre></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li></ol><ol start="9"><li>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</li></ol><ol start="10"><li><p><code>注意</code>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p></li><li><p><code>注意</code>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：<br>1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：</p><pre><code>public int f() &#123; return Integer 对象&#125;</code></pre><p>如果为null，自动解箱抛NPE。</p></li></ol><p> 2） 数据库的查询结果可能为null。</p><p> 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。</p><p>4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。</p><p> 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>正例：使用JDK8的Optional类来防止NPE问题。</p><ol start="12"><li>【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。</li></ol><ol start="13"><li>【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</li></ol><ol start="14"><li>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。</li></ol><p> 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto) {…}</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-我见过的异常.md</title>
      <link href="/2022/03/20/java-wo-jian-guo-de-yi-chang/"/>
      <url>/2022/03/20/java-wo-jian-guo-de-yi-chang/</url>
      
        <content type="html"><![CDATA[<p>1、在对ArrayList并发add时报出<br>并发修改异常<br>java.util.ConcurrentModificationException </p><p>2、<br>BrokenBarrierException异常</p><p>3、IllegalTransactionStateException异常<br>事务的传播行为出现的异常</p><p>4、线程中断异常<br>InterruptedException</p><p>5、线程池拒绝策略异常<br>java.util.concurrent.RejectedExecutionException</p><p>###错误</p><p>SO 栈内存溢出 错误<br> java.lang.StackOverflowError</p><blockquote><p>StackOverflowError extends VirtualMachineError</p></blockquote><p>OOM 堆内存溢出 错误<br>java.lang.OutOfMemoryError</p><blockquote><p>OutOfMemoryError extends VirtualMachineError </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-日期.md</title>
      <link href="/2022/03/20/java-ri-qi/"/>
      <url>/2022/03/20/java-ri-qi/</url>
      
        <content type="html"><![CDATA[<p>###注意<br>【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为<br>static，必须加锁，或者使用 DateUtils 工具类。<br>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：<br>private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {<br>@Override<br>protected DateFormat initialValue() {<br>return new SimpleDateFormat(“yyyy-MM-dd”);<br>}<br>};<br>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，<br>DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable<br>thread-safe。</p><p>###字符串日期比较大小</p><pre><code>String cd = DateUtils.getCurrentDate();// 获得当前日期DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);if(dateFormat.parse(cd).getTime() &lt; dateFormat.parse(&quot;2019-01-05&quot;).getTime())&#123;    System.out.println(213);&#125;else&#123;    System.out.println(321);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-有序Map之TreeMap的使用.md</title>
      <link href="/2022/03/20/java-you-xu-map-zhi-treemap-de-shi-yong/"/>
      <url>/2022/03/20/java-you-xu-map-zhi-treemap-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>谦虚使人进步</p></blockquote><p>想要了解一个类，就可以从它实现的接口和继承的父类开始。我们可以看到TreeMap实现了java.util.NavigableMap接口，NavigableMap它又继承了排序Map接口 java.util.SortedMap，因此TreeMap具有排序能力；其次，TreeMap实现了Cloneable和Serializable接口，它也具备克隆和序列化能力</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-cb04e714a1912fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>TreeMap底层由<code>红黑树</code>实现，按照<code>Key的自然顺序升序</code>或者实现Comprator接口进行<code>自定义排序</code>。且TreeMap的排序特性只作用在key上。如果需要value也跟着排序就需要使用一些别的手段。</p><p>###排序特性<br>######按key排序<br>默认按key升序排列</p><pre><code>package com.springboot.study.demo1;import java.util.*;public class Test &#123;    public static void main(String[] args) &#123;        TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;() &#123;&#123;            put("3", "1");            put("1", "3");            put("2", "2");        &#125;&#125;;        for (String s : treeMap.keySet()) &#123;            System.out.println(s+&quot;==&gt;&quot;+treeMap.get(s));        &#125;    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-ae30bf8423101df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>按key降序排列</p><pre><code>package com.springboot.study.demo1;import java.util.*;public class Test &#123;    public static void main(String[] args) &#123;        TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(new Comparator&lt;String&gt;() &#123;            @Override            public int compare(String o1, String o2) &#123;                return o2.compareTo(o1);            &#125;        &#125;) &#123;&#123;            put("3", "1");            put("1", "2");            put("2", "3");        &#125;&#125;;        for (String s : treeMap.keySet()) &#123;            System.out.println(s + &quot;==&gt;&quot; + treeMap.get(s));        &#125;    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-f91c78019a65d7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>######按value排序<br>如果需要value也跟着排序就需要使用一些别的手段。当然HashMap的value排序也可以使用这种方法</p><p>将Map转为 List&lt;Map.Entry&gt;，然后使用java.util.Collections工具类来排序。当然这种方法也适用于HashMap</p><pre><code>package com.springboot.study.demo1;import java.util.*;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; treeMap = new HashMap&lt;String, String&gt;() &#123;&#123;            put("3", "1");            put("1", "2");            put("2", "3");        &#125;&#125;;        //将Map转为 List&lt;Map.Entry&gt;        List&lt;Map.Entry&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(treeMap.entrySet());        //按照        Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123;            //升序排序            public int compare(Map.Entry&lt;String, String&gt; o1, Map.Entry&lt;String, String&gt; o2) &#123;                return o1.getValue().compareTo(o2.getValue());            &#125;        &#125;);        for (Map.Entry&lt;String, String&gt; e: list) &#123;            System.out.println(e.getKey()+&quot;==&gt;&quot;+e.getValue());        &#125;    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-831110e1b5371228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###性能特性</p><ul><li><p>TreeMap的优势在于能够实现<code>自定义排序功能</code>，但是性能要比HashMap和LinkedHashMap差。它的 containsKey 、get 、 put 、remove 方法的时间复杂度是 log(n)</p></li><li><p>虽然LinkedHashMap也是有序的，但是LinkedHashMap内元素顺序只和插入顺序有关，无法进行自定义排序</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-有序Map值LinkedHashMap.md</title>
      <link href="/2022/03/20/java-you-xu-map-zhi-linkedhashmap/"/>
      <url>/2022/03/20/java-you-xu-map-zhi-linkedhashmap/</url>
      
        <content type="html"><![CDATA[<p>LinkedHashMap 拥有 HashMap 的所有特性，它比 HashMap 多维护了一个双向链表，因此可以按照插入的顺序从头部或者从尾部迭代，是有序的，不过因为比 HashMap 多维护了一个双向链表，它的内存相比而言要比 HashMap 大，并且性能会差一些，但是如果需要考虑到元素插入的顺序的话， LinkedHashMap 不失为一种好的选择</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-查看汇编指令.md</title>
      <link href="/2022/03/20/java-cha-kan-hui-bian-zhi-ling/"/>
      <url>/2022/03/20/java-cha-kan-hui-bian-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>1、idea运行配置</p><pre><code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly </code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-6127507629f26b29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>2、将hsdis-amd64.dll文件放到\jdk1.8\jre\bin下<br><img src="https://upload-images.jianshu.io/upload_images/13965490-fe2af406d548fcdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>3、运行即可<br><img src="https://upload-images.jianshu.io/upload_images/13965490-6f09f4849643d5b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-枚举.md</title>
      <link href="/2022/03/20/java-mei-ju/"/>
      <url>/2022/03/20/java-mei-ju/</url>
      
        <content type="html"><![CDATA[<p>1、根据name获得value，非常方便，不要去写switch了！</p><pre><code>package com.sfpay.axg.enums;import org.apache.commons.lang3.StringUtils;public enum OrderPage &#123;    WAITPRINT(&quot;01&quot;, &quot;待打印&quot;),    PRINTED(&quot;02&quot;, &quot;已打印&quot;),    DELIVERGOODS(&quot;03&quot;, &quot;已发货&quot;),    ALLORDER(&quot;04&quot;, &quot;全部订单&quot;),    ORDERMANAGEMENT(&quot;05&quot;, &quot;订单管理&quot;),    CATCHORDER(&quot;09&quot;, &quot;抓单打印&quot;);    private String key;    private String value;    OrderPage(String key, String value) &#123;        this.key = key;        this.value = value;    &#125;    public String getKey() &#123;        return key;    &#125;    public void setKey(String key) &#123;        this.key = key;    &#125;    public String getValue() &#123;        return value;    &#125;    public void setValue(String value) &#123;        this.value = value;    &#125;    @Override    public String toString() &#123;        return this.getKey();    &#125;    /**     * 根据key得到value     * @param key     * @return     */    public static String getValue(String key) &#123;        if (StringUtils.isBlank(key)) &#123;            return null;        &#125;        for (OrderPage type : values()) &#123;            if (type.getKey().equals(key)) &#123;                return type.getValue();            &#125;        &#125;        return null;    &#125;    /**     * 根据name 得到key     * @param name     * @return     */    public static String getKeyByName(String name) &#123;        OrderPage[] productEnums = values();        for (OrderPage productEnum : productEnums) &#123;            if ((productEnum.name()).equals(name)) &#123;                return productEnum.key;            &#125;        &#125;        return null;    &#125;    public static void main(String[] args) &#123;        System.out.println(getKeyByName(&quot;1&quot;));    &#125;&#125;</code></pre><p>2、一个枚举类里还可以使用其它枚举对象作为成员属性</p><p>利用好这个写法可以维护一个关系 </p><pre><code>package com.gbm.cloud.treasure.entity.mgbUndertakesOrder.Enum.option;import com.gbm.cloud.common.util.Constant;import com.gbm.cloud.treasure.entity.mgbUndertakesOrder.Enum.vo.UserEnum;import java.util.Arrays;import java.util.Map;import java.util.Optional;import java.util.stream.Collectors;/** * @author 尹凯 * @time 2021/8/9 17:02 * @Description: 售后流程-已发货退货 */public enum ShippedReturnOption &#123;    /**     * 已发货退货     */    ONE(0, &quot;已发货退货&quot;, UserEnum.PLATFORMOOPERATION),    TWO(1, &quot;确认退货&quot;,UserEnum.SUPPLIER),    THREE(2, &quot;确认退款&quot;,UserEnum.PLATFORMOOPERATION);    public static final String NO = &quot;C&quot;;    ShippedReturnOption(Integer code, String desc, UserEnum userEnum) &#123;        this.code = code;        this.desc = desc;        this.userEnum = userEnum;    &#125;    public int code;    public String desc;    public UserEnum userEnum;    private static Map&lt;Integer, ShippedReturnOption&gt; collect = Arrays.stream(ShippedReturnOption.values()).collect(Collectors.toMap(s -&gt; s.code, section -&gt; section,(v1,v2)-&gt;v2));    public static Map&lt;Integer, ShippedReturnOption&gt; getAll() &#123;        return collect;    &#125;    public static String getDescByCode(Integer code,UserEnum userEnum) &#123;        final Map&lt;Integer, ShippedReturnOption&gt; all = getAll();        if (all.keySet().contains(code)) &#123;            final ShippedReturnOption shippedReturnOption = all.get(code);            return Optional.ofNullable(shippedReturnOption).map(m -&gt; m.userEnum.equals(userEnum) ? shippedReturnOption.desc : Constant.NOT_ME).orElse(null);        &#125;        return null;    &#125;&#125;</code></pre><pre><code>public enum UserEnum &#123;    SUPPLIER(1, &quot;供应商&quot;),    PLATFORMOOPERATION(2, &quot;平台运营&quot;);    UserEnum(int code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    private int code;    private String desc;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-泛型-E-T.md</title>
      <link href="/2022/03/20/java-fan-xing-e-t/"/>
      <url>/2022/03/20/java-fan-xing-e-t/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-正确的日志使用习惯.md</title>
      <link href="/2022/03/20/java-zheng-que-de-ri-zhi-shi-yong-xi-guan/"/>
      <url>/2022/03/20/java-zheng-que-de-ri-zhi-shi-yong-xi-guan/</url>
      
        <content type="html"><![CDATA[<p><strong>禁止使用e.printStackTrace()</strong><br> <br>e.printStackTrace()打印的是异常堆栈信息，会额外的占用内存空间。正确的姿势是把日志打印到文件中。如下</p><pre><code>    public static void main(String[] args) &#123;        try &#123;            int i = 1/0;        &#125;catch (Exception e)&#123;            //禁止使用 e.printStackTrace()             logger.error(&quot;错误&quot;,e);        &#125;    &#125;</code></pre><blockquote><p>注意log.error()最后一个参数要填捕获到的异常e，这样才能将异常详细堆栈信息打印到log</p></blockquote><p><strong>使用合适的日志级别</strong><br> <br>Slf4j有四个级别的log level可供选择，级别从上到下由低到高，优先级高的将被打印出来。<br>Debug：简单来说，对程序调试有利的信息都可以debug输出。<br>info：对用户有用的信息，比如最常见的打印接口入参和返参。<br>warn：可能会导致错误的信息，比如某个对象可能为null的场景判断。<br>error：顾名思义，发生错误的地方，最常见的catch代码块中的日志。<br> <br>这里以error日志为例，举一个例子，在合适的场合打印合适的日志，是我们日志界的规范。</p><pre><code>    public static void main(String[] args) &#123;        try &#123;            int i = 1 / 0;        &#125; catch (Exception e) &#123;            //catch中不适合使用info级别            // logger.info(&quot;错误&quot;,e);             logger.error(&quot;错误&quot;, e);        &#125;    &#125;</code></pre><p> </p><p><strong>使用占位符，而不是字符串拼接</strong></p><p>Slf4j打印日志使用了占位符，避免了字符串拼接操作。字符串拼接最大的弊端，就是需要new新的字符串对象，增加了内存的开销。</p><pre><code>    public static void main(String[] args) &#123;        int a = 1;        int b = 0;        try &#123;            int i = a / b;        &#125; catch (Exception e) &#123;            //不要使用+字符串直接拼接            //logger.error(&quot;错误 a=&quot;+a+&quot; b=&quot;+b,e);            logger.error(&quot;错误 a=&#123;&#125; b=&#123;&#125;&quot;, a, b, e);        &#125;    &#125; ~~~**尽量打印更少的日志，能一行打印的不要分为多行**不要打印无用的日志，不要重复打印日志，尽量不要在for循环中打印日志。</code></pre><pre><code>public static void main(String[] args) &#123;    int a = 1;    int b = 0;    try &#123;        int i = a / b;    &#125; catch (Exception e) &#123;</code></pre><p>//            //能一行打印的不要分为多行<br>//            logger.error(“错误 a={}”, a);<br>//            logger.error(“错误 b={}”, b);<br>//            logger.error(“错误 “, e);<br>            logger.error(“错误 a={} b={}”, a, b, e);<br>        }<br>    } </p><pre><code>  ###从源码角度看看log打印和e.printStackTrace()的区别1、log.error底层实现ch.qos.logback.core.spi.AppenderAttachableImpl#appendLoopOnAppenders循环迭代appenderArray数组，一般是三个元素分别为：控制台、全日志、错误日志。三个输出目标依次执行！</code></pre><pre><code>/** * Call the &lt;code&gt;doAppend&lt;/code&gt; method on all attached appenders. */public int appendLoopOnAppenders(E e) &#123;    int size = 0;    final Appender&lt;E&gt;[] appenderArray = appenderList.asTypedArray();    final int len = appenderArray.length;    for (int i = 0; i &lt; len; i++) &#123;        appenderArray[i].doAppend(e);        size++;    &#125;    return size;&#125;</code></pre><pre><code>![image.png](https://upload-images.jianshu.io/upload_images/13965490-b4a97887ebee045a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)分支逻辑 ch.qos.logback.core.UnsynchronizedAppenderBase#doAppend this.append(eventObject);this有连个两个多态实现：ch.qos.logback.core.ConsoleAppender[STDOUT]和ch.qos.logback.core.rolling.RollingFileAppender[FILE]分别表示控制台输出和日志文件输出</code></pre><pre><code>public void doAppend(E eventObject) &#123;    // WARNING: The guard check MUST be the first statement in the    // doAppend() method.    // prevent re-entry.    if (Boolean.TRUE.equals(guard.get())) &#123;        return;    &#125;    try &#123;        guard.set(Boolean.TRUE);        if (!this.started) &#123;            if (statusRepeatCount++ &lt; ALLOWED_REPEATS) &#123;                addStatus(new WarnStatus(&quot;Attempted to append to non started appender [&quot; + name + &quot;].&quot;, this));            &#125;            return;        &#125;        if (getFilterChainDecision(eventObject) == FilterReply.DENY) &#123;            return;        &#125;        // ok, we now invoke derived class&#39; implementation of append        this.append(eventObject);    &#125; catch (Exception e) &#123;        if (exceptionCount++ &lt; ALLOWED_REPEATS) &#123;            addError(&quot;Appender [&quot; + name + &quot;] failed to append.&quot;, e);        &#125;    &#125; finally &#123;        guard.set(Boolean.FALSE);    &#125;&#125;</code></pre><pre><code>**2、e.printStackTrace()底层实现**java.lang.Throwable#printStackTrace(java.lang.Throwable.PrintStreamOrWriter)</code></pre><pre><code>private void printStackTrace(PrintStreamOrWriter s) &#123;    // Guard against malicious overrides of Throwable.equals by    // using a Set with identity equality semantics.    Set&lt;Throwable&gt; dejaVu =        Collections.newSetFromMap(new IdentityHashMap&lt;Throwable, Boolean&gt;());    dejaVu.add(this);    synchronized (s.lock()) &#123;        // Print our stack trace        s.println(this);        StackTraceElement[] trace = getOurStackTrace();        for (StackTraceElement traceElement : trace)            s.println(&quot;\tat &quot; + traceElement);        // Print suppressed exceptions, if any        for (Throwable se : getSuppressed())            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\t&quot;, dejaVu);        // Print cause, if any        Throwable ourCause = getCause();        if (ourCause != null)            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu);    &#125;&#125;</code></pre><pre><code>java.lang.Throwable.WrappedPrintStream#println</code></pre><p>   void println(Object o) {<br>            printStream.println(o);<br>        }</p><pre><code>java.io.PrintStream#println(java.lang.Object)</code></pre><pre><code>public void println(Object x) &#123;    String s = String.valueOf(x);    synchronized (this) &#123;        print(s);        newLine();    &#125;&#125;</code></pre><pre><code>java.io.PrintStream#write(java.lang.String)</code></pre><pre><code>private void write(String s) &#123;    try &#123;        synchronized (this) &#123;            ensureOpen();            textOut.write(s);            textOut.flushBuffer();            charOut.flushBuffer();            if (autoFlush &amp;&amp; (s.indexOf(&#39;\n&#39;) &gt;= 0))                out.flush();        &#125;    &#125;    catch (InterruptedIOException x) &#123;        Thread.currentThread().interrupt();    &#125;    catch (IOException x) &#123;        trouble = true;    &#125;&#125;</code></pre><pre><code>&gt;e.printStackTrace()使用BufferedWriter.write(s);输出到控制台，而且是逐行输出，存在资源浪费的性能问题。###补充一下alibaba开发手册中日志规范内容1、应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架 SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</code></pre><p>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>private static final Logger logger = LoggerFactory.getLogger(Test.class);</p><pre><code>2、在日志输出时，字符串变量之间的拼接使用占位符的方式。 说明：因为String字符串的拼接会使用StringBuilder的append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。 正例：</code></pre><p>logger.debug(“Processing trade with id: {} and symbol: {}”, id, symbol);</p><pre><code>3、对于trace/debug/info级别的日志输出，必须进行日志级别的开关判断。 说明：虽然在debug(参数)的方法体内第一行代码isDisabled(Level.DEBUG_INT)为真时（Slf4j的常见实现Log4j和Logback），就直接return，但是参数可能会进行字符串拼接运算。此外，如果debug(getName())这种参数内有getName()方法调用，无谓浪费方法调用的开销。 正例： // 如果判断为真，那么可以输出trace和debug级别的日志</code></pre><pre><code>  if(log.isTraceEnabled())&#123;       log.trace(&quot;111&quot;);    &#125;    if(log.isDebugEnabled())&#123;       log.debug(&quot;111&quot;);    &#125;    if(JgRulaUnsuitableGoodsServiceImpl.log.isInfoEnabled())&#123;        log.info(&quot;111&quot;);    &#125;</code></pre><pre><code>4、【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。 正例：</code></pre><logger name="com.taobao.dubbo.config" additivity="false">~~~<p>5、【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。</p><p> 正例：</p><pre><code>logger.error(各类参数或者对象toString() + &quot;_&quot; + e.getMessage(), e);</code></pre><p>6、【推荐】谨慎地记录日志。<code>生产环境禁止输出debug日志</code>；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。 说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ </p><p>7、  <code>重要</code> 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过<br>关键字 throws 往上抛出。<br>正例：logger.error(“inputParams:{} and errorMessage:{}”, 各类参数或者对象 toString(), e.getMessage(), e);</p><p>8、<code>重要</code>日志打印时禁止直接用 JSON 工具将对象转换成 String。说明：如果对象里某些 get 方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流<br>程的执行。<br>正例：打印日志时仅打印出业务相关属性值或者调用其对象的 toString()方法。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-泛型之泛型擦除.md</title>
      <link href="/2022/03/20/java-fan-xing-zhi-fan-xing-ca-chu/"/>
      <url>/2022/03/20/java-fan-xing-zhi-fan-xing-ca-chu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-泛型学习.md</title>
      <link href="/2022/03/20/java-fan-xing-xue-xi/"/>
      <url>/2022/03/20/java-fan-xing-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>1、返回值泛型</p><pre><code>1\. 服务提供者 函数： //通过&lt;T&gt;声明告诉JVM返回值定义一个泛型 T        //// 这里的T只是个占位符的效果，26个字母随便写哪个字母都可以，但一定要是和&lt; &gt;里面相同的字母，这里使用Tpublic &lt;T&gt; T findList(String sqlID,Map&lt;String,Object&gt; params) &#123;String statement = &quot;com.mybatis.mapping.userMapper.&quot;+sqlID;//映射sql的标识字符串return (T) this.session.selectList(statement, params);&#125;2\. 服务调用者 函数：//这里接收的类型声明直接写真实的类型就可以，无需强制转换List&lt;SubsHis&gt; list = jdbc.findList(&quot;getSubsHisList&quot;, map);分类: [工作总结](https://www.cnblogs.com/jpfss/category/992649.html), [开发经验](https://www.cnblogs.com/jpfss/category/992650.html)</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-版本.md</title>
      <link href="/2022/03/20/java-ban-ben/"/>
      <url>/2022/03/20/java-ban-ben/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13965490-8f603a93862405b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>java8、java11、java17</p><p>现在使用最多的版本还是java 8（或者1.8）。因为java 8版本，具备了java开发者足够的功能，生态也比较完善，不用担心使用的包，没有足够的支持，而且不用担心会被Oracle罚款。下面是来自jetbrains idea IDE 对java各版本的使用统计情况（2020年）。</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-9c1c4d06a88626b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-深拷贝和浅拷贝.md</title>
      <link href="/2022/03/20/java-shen-kao-bei-he-qian-kao-bei/"/>
      <url>/2022/03/20/java-shen-kao-bei-he-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<p>浅拷贝： <strong>不额外创建子对象，</strong>只是把子对象的引用拷贝过去<br>深拷贝： 创建新的子对象并拷贝属性</p><p>如果把java bean划分为 DTO、DO、VO 的话就避免不了对象的copy了。一般选择的spring的工具类都是浅拷贝。当<code>对象内部还有对象</code> 时只能copy内部对象的引用，这样的话不利于灵活修改。</p><p>浅拷贝模式，分两步：</p><ul><li>  先创建一个新的同类型对象</li><li>  把原对象的各个属性值拷贝到对应字段</li></ul><p>spring 的BeanUtils.copyProperties(sourceBean, destBean)只针对Person对象，所以只会把左边Person对象的属性值拷贝到右边，至于子对象department，也只是拷贝了引用。具体看下面的BeanUtils.copyProperties例子。</p><pre><code>import java.io.Serializable;import java.util.ArrayList;import java.util.List;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.beans.BeanUtils;public class MyBeanUtilsTest &#123;    private static List&lt;Person&gt; list;    @Data    @AllArgsConstructor    @NoArgsConstructor    public static class Person implements Serializable &#123;        private String name;        private Integer age;        private Department department;    &#125;    @Data    @AllArgsConstructor    @NoArgsConstructor    public static class Department implements Serializable&#123;        private String name;    &#125;    static &#123;        list = new ArrayList&lt;&gt;();        list.add(new Person(&quot;小明&quot;, 18, new Department(&quot;行政部&quot;)));    &#125;    public static void main(String[] args) &#123;        Person bean = list.get(0);        Person copyBean = new Person();        BeanUtils.copyProperties(bean, copyBean);        System.out.println(bean == copyBean);        System.out.println(&quot;==== copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());        bean.setName(&quot;小亮&quot;);        bean.getDepartment().setName(&quot;研发部&quot;);        System.out.println(&quot;==== sourceBean修改后，copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());    &#125;&#125;</code></pre><blockquote><p>false<br>==== copyBean的属性 ====<br>小明<br>行政部<br>==== sourceBean修改后，copyBean的属性 ====<br>小明<br>研发部</p></blockquote><p>修改bean的department 同时也把copyBean 的department 修改了。<br>使用Spring提供的BeanUtils进行数据拷贝，但它有两个问题：</p><ul><li> 没有提供额外的映射关系，所以两个实体类字段名必须完全一致</li><li>不支持深拷贝</li></ul><p>###深拷贝如何实现</p><p>1、ObjectOutputStream.writeObject()</p><pre><code>    public static &lt;T&gt; T deepCopyObj(T object) throws IOException, ClassNotFoundException &#123;        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(byteOut);        out.writeObject(object);        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());        ObjectInputStream in = new ObjectInputStream(byteIn);        T dest = (T) in.readObject();        return dest;    &#125;</code></pre><p>这次修改为调用深拷贝实现：</p><pre><code>    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        Person bean = list.get(0);        Person copyBean = MyBeanUtils.deepCopyObj(bean);        System.out.println(bean == copyBean);        System.out.println(&quot;==== copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());        bean.setName(&quot;小亮&quot;);        bean.getDepartment().setName(&quot;研发部&quot;);        System.out.println(&quot;==== sourceBean修改后，copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());    &#125;</code></pre><blockquote><p>false<br>==== copyBean的属性 ====<br>小明<br>行政部<br>==== sourceBean修改后，copyBean的属性 ====<br>小明<br>行政部</p></blockquote><p>修改bean的department  也没有影响到copyBean 的department，达到了深拷贝的目的！</p><p>2、JSON序列化、反序列化也是可以的。使用ObjectMapper</p><p>先引入jackson</p><pre><code>    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;      &lt;version&gt;2.9.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;      &lt;version&gt;2.9.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;2.9.6&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;</code></pre><p>使用</p><pre><code>    public static void main(String[] args) throws IOException &#123;        Person bean = list.get(0);        ObjectMapper objectMapper = new ObjectMapper();        String copyBeanStr = objectMapper.writeValueAsString(bean);        Person copyBean = objectMapper.readValue(copyBeanStr, new TypeReference&lt;Person&gt;() &#123;&#125;);        System.out.println(bean == copyBean);        System.out.println(&quot;==== copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());        bean.setName(&quot;小亮&quot;);        bean.getDepartment().setName(&quot;研发部&quot;);        System.out.println(&quot;==== sourceBean修改后，copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());    &#125;</code></pre><blockquote><p>false<br>==== copyBean的属性 ====<br>小明<br>行政部<br>==== sourceBean修改后，copyBean的属性 ====<br>小明<br>行政部</p></blockquote><p>3、使用二方库 MapStruct</p><pre><code>import java.util.List;import org.mapstruct.Mapper;import org.mapstruct.Mapping;import org.mapstruct.Mappings;import org.mapstruct.factory.Mappers;@Mapperpublic interface PersonConverter &#123;    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);    @Mappings(&#123;        @Mapping(source = &quot;name&quot;, target = &quot;name&quot;),        @Mapping(source = &quot;age&quot;, target = &quot;age&quot;),        @Mapping(source = &quot;department.name&quot;, target = &quot;department.name&quot;),    &#125;)    Person domain2dto(Person person);    List&lt;Person&gt; domain2dto(List&lt;Person&gt; people);&#125;</code></pre><pre><code>    public static void main(String[] args) throws IOException &#123;        Person bean = list.get(0);        Person copyBean = PersonConverter.INSTANCE.domain2dto(bean);        System.out.println(bean == copyBean);        System.out.println(&quot;==== copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());        bean.setName(&quot;小亮&quot;);        bean.getDepartment().setName(&quot;研发部&quot;);        System.out.println(&quot;==== sourceBean修改后，copyBean的属性 ====&quot;);        System.out.println(copyBean.getName());        System.out.println(copyBean.getDepartment().getName());    &#125;&#125;</code></pre><blockquote><p>false<br>==== copyBean的属性 ====<br>小明<br>行政部<br>==== sourceBean修改后，copyBean的属性 ====<br>小明<br>行政部</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-算法记录1，计算1-100随机数出现1000次中各个数字出现的个数.md</title>
      <link href="/2022/03/20/java-suan-fa-ji-lu-1-ji-suan-1-100-sui-ji-shu-chu-xian-1000-ci-zhong-ge-ge-shu-zi-chu-xian-de-ge-shu/"/>
      <url>/2022/03/20/java-suan-fa-ji-lu-1-ji-suan-1-100-sui-ji-shu-chu-xian-1000-ci-zhong-ge-ge-shu-zi-chu-xian-de-ge-shu/</url>
      
        <content type="html"><![CDATA[<pre><code>package GGG.COM.class1;public class GGGA &#123;    public static void main(String[] args) &#123;        int[] arr = new int[1000];        for (int i = 0; i &lt;1000 ; i++) &#123;            arr[i] = (int) (100*Math.random()+1);        &#125;        int[] arrCount = new int[100];        for (int i = 0; i &lt; 100; i++) &#123;           arrCount[i]=0;        &#125;        for (int i = 0; i &lt; 1000; i++) &#123;          //注意：加1           arrCount[arr[i]-1]++;        &#125;        for (int i = 1; i &lt;=arrCount.length ; i++) &#123;            System.out.println(i+&quot;==&gt;&quot;+arrCount[i-1]);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-算法记录2-分组统计字符串中出现字符串数.md</title>
      <link href="/2022/03/20/java-suan-fa-ji-lu-2-fen-zu-tong-ji-zi-fu-chuan-zhong-chu-xian-zi-fu-chuan-shu/"/>
      <url>/2022/03/20/java-suan-fa-ji-lu-2-fen-zu-tong-ji-zi-fu-chuan-zhong-chu-xian-zi-fu-chuan-shu/</url>
      
        <content type="html"><![CDATA[<p>直接使用HashMap解决</p><pre><code>package GGG.COM.class1;import java.util.HashMap;public class GGGA &#123;    public static void main(String[] args) &#123;        String str = &quot;yinkaiyinkai&quot;;        char[] chars = str.toCharArray();        HashMap&lt;Object, Integer&gt; objectObjectHashMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; chars.length; i++) &#123;            char c = chars[i];            Integer o = objectObjectHashMap.get(c);            if(o==null)&#123;                objectObjectHashMap.put(c,1);            &#125;else&#123;                objectObjectHashMap.put(c,o+1);            &#125;        &#125;        System.out.println(objectObjectHashMap);    &#125;&#125;</code></pre><p>java8写法</p><pre><code>package GGG.COM.class1;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.function.Function;import java.util.stream.Collectors;import java.util.stream.Stream;public class GGGA &#123;    public static void main(String[] args) &#123;        String str = &quot;yinkaiyinkai&quot;;        Character[] charObjectArray =            str.chars().mapToObj(c -&gt; (char)c).toArray(Character[]::new);        Map&lt;Character, Long&gt; collect = Stream.of(charObjectArray)            .collect(                Collectors.groupingBy(                    Function.identity(), Collectors.counting()                )            );        System.out.println(collect);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-自定义泛型.md</title>
      <link href="/2022/03/20/java-zi-ding-yi-fan-xing/"/>
      <url>/2022/03/20/java-zi-ding-yi-fan-xing/</url>
      
        <content type="html"><![CDATA[<p>观察下面使用泛型的手法：</p><pre><code>    public static &lt;T&gt; T deepCopyObj(T object) throws IOException, ClassNotFoundException &#123;        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(byteOut);        out.writeObject(object);        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());        ObjectInputStream in = new ObjectInputStream(byteIn);        @SuppressWarnings(&quot;unchecked&quot;)        T dest = (T) in.readObject();        return dest;    &#125;</code></pre><pre><code>    public static &lt;T&gt; List&lt;T&gt; deepCopyList(List&lt;T&gt; src) throws IOException, ClassNotFoundException &#123;        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(byteOut);        out.writeObject(src);        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());        ObjectInputStream in = new ObjectInputStream(byteIn);        @SuppressWarnings(&quot;unchecked&quot;)        List&lt;T&gt; dest = (List&lt;T&gt;) in.readObject();        return dest;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-能用异常控制流程的地方一定可以使用return！.md</title>
      <link href="/2022/03/20/java-neng-yong-yi-chang-kong-zhi-liu-cheng-de-di-fang-yi-ding-ke-yi-shi-yong-return/"/>
      <url>/2022/03/20/java-neng-yong-yi-chang-kong-zhi-liu-cheng-de-di-fang-yi-ding-ke-yi-shi-yong-return/</url>
      
        <content type="html"><![CDATA[<p>1、在构造函数里也可以使用return的方式</p><p>将返回包装类GbmResult声明到类的成员变量中：<br>然后</p><p>2、构造函数{<br>        if (StringUtils.isEmpty(stringStringMap)) {<br>            this.gbmResult = GbmResultGenerator.genFailResult(“未找到对应模板信息”);<br>            return;<br>        }<br>}</p><p>3、在上层可以这样使用：</p><pre><code>       /**         * 构造         */        ImportOrderByExcelListener listener = new ImportOrderByExcelListener(templateNo, customerCode, platformCode, importDate, importBatch,templateService, relationshipService,excelFieldService, originalOrderService, customerGoodsRelationshipService, codeGenerator);        GbmResult gbmResult = listener.getGbmResult();        if(ToolUtil.isNotEmpty(gbmResult))&#123;            return gbmResult;        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合之ArrayList和LinkedList的区别和使用建议.md</title>
      <link href="/2022/03/20/java-ji-he-zhi-arraylist-he-linkedlist-de-qu-bie-he-shi-yong-jian-yi/"/>
      <url>/2022/03/20/java-ji-he-zhi-arraylist-he-linkedlist-de-qu-bie-he-shi-yong-jian-yi/</url>
      
        <content type="html"><![CDATA[<p>1、ArrayList 基于动态数组实现的非线程安全的集合；LinkedList 基于双向链表实现的非线程安全的集合。</p><p>2、扩容问题：ArrayList 使用数组实现，无参构造函数默认初始化长度为 10，数组扩容是会将原数组中的元素重新拷贝到新数组中，长度为原来的 1.5 倍(扩容代价高)；LinkedList 不存在扩容问题，新增元素放到集合尾部，修改相应的指针节点即可。</p><p>3、LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用节点，一个指向前一个元素，一个指向下一个元素。</p><p>4、对于随机 index 访问的 get 和 set 方法，一般 ArrayList 的速度要优于 LinkedList。因为 ArrayList 直接通过数组下标直接找到元素；LinkedList 要移动指针遍历每个元素直到找到为止。</p><p>5、新增add和删除remove元素，一般 LinkedList 的速度要优于 ArrayList。因为 ArrayList 在新增和删除元素时，可能扩容和复制数组；LinkedList 实例化对象需要时间外，只需要修改节点指针即可。</p><p>6、LinkedList 集合不支持高效的随机访问（RandomAccess）<br>ArrayList 的空间浪费主要体现在在list列表的结尾预留一定的容量空间；LinkedList 的空间花费则体现在它的每一个元素都需要消耗存储指针节点对象的空间。</p><p>###使用建议<br>1、千万别在循环中调用 LinkedList 的 get 方法，耗时会让你崩溃。最好采用Iterator或者foreach的方式遍历，效率最高，因为foreach编译后就是使用Iterator的。</p><p>思考：</p><p>arrayList add 10000000 cost time: 3293；linkedList add 10000000 cost time: 1337<br>arrayList add 1000000  cost time: 22  ；   linkedList add 1000000   cost time: 1011<br>跑另外一组数据，size 设为 1000 * 1000，得出当size增加，ArrayList 的 add操作的累计时间增长更快</p><p>代码例子中，”新增和删除元素，一般 LinkedList 的速度要优于 ArrayList” 并不成立，可以思考一下原因。</p><p>理论上 set、get、fori循环遍历 这些设计到index索引位置的方法（随机访问） ArrayList比LinkedList快。而add、remove等移动元素位置的方法LinkedList较快。<br>但是注意：无论是fori、foreach、iterator。对于相同元素的两个遍历。都是ArrayList快</p><p>###测试例子</p><pre><code>package com.springboot.study.demo1;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.List;public class Test &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();        LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;();        int size = 10000 * 1000;        int index = 5000 * 1000;        System.out.println(&quot;arrayList add &quot; + size);        addData(arrayList, size);        System.out.println(&quot;linkedList add &quot; +  + size);        addData(linkedList, size);        System.out.println();        System.out.println(&quot;arrayList get &quot; + index + &quot; th&quot;);        getIndex(arrayList, index);        System.out.println(&quot;linkedList get &quot; + index + &quot; th&quot;);        getIndex(linkedList, index);        System.out.println();        System.out.println(&quot;arrayList set &quot; + index + &quot; th&quot;);        setIndex(arrayList, index);        System.out.println(&quot;linkedList set &quot; + index + &quot; th&quot;);        setIndex(linkedList, index);        System.out.println();        System.out.println(&quot;arrayList add &quot; + index + &quot; th&quot;);        addIndex(arrayList, index);        System.out.println(&quot;linkedList add &quot; + index + &quot; th&quot;);        addIndex(linkedList, index);        System.out.println();        System.out.println(&quot;arrayList remove &quot; + index + &quot; th&quot;);        removeIndex(arrayList, index);        System.out.println(&quot;linkedList remove &quot; + index + &quot; th&quot;);        removeIndex(linkedList, index);        System.out.println();        System.out.println(&quot;arrayList remove Object &quot; + index);        removeObject(arrayList, (Object)index);        System.out.println(&quot;linkedList remove Object &quot; + index);        removeObject(linkedList, (Object)index);        System.out.println();        System.out.println(&quot;arrayList add&quot;);        add(arrayList);        System.out.println(&quot;linkedList add&quot;);        add(linkedList);        System.out.println();        System.out.println(&quot;arrayList foreach&quot;);        foreach(arrayList);        System.out.println(&quot;linkedList foreach&quot;);        foreach(linkedList);        System.out.println();        System.out.println(&quot;arrayList forSize&quot;);        forSize(arrayList);        System.out.println(&quot;linkedList forSize 慢到怀疑人生 ......&quot;);        forSize(linkedList);        System.out.println(&quot;cost time: ...&quot;);        System.out.println();        System.out.println(&quot;arrayList iterator&quot;);        ite(arrayList);        System.out.println(&quot;linkedList iterator&quot;);        ite(linkedList);    &#125;    private static void addData(List&lt;Integer&gt; list, int size) &#123;        long s1 = System.currentTimeMillis();        for (int i = 0; i &lt;size; i++) &#123;            list.add(i);        &#125;        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void getIndex(List&lt;Integer&gt; list, int index) &#123;        long s1 = System.currentTimeMillis();        list.get(index);        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void setIndex(List&lt;Integer&gt; list, int index) &#123;        long s1 = System.currentTimeMillis();        list.set(index, 1024);        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void addIndex(List&lt;Integer&gt; list, int index) &#123;        long s1 = System.currentTimeMillis();        list.add(index, 1024);        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void removeIndex(List&lt;Integer&gt; list, int index) &#123;        long s1 = System.currentTimeMillis();        list.remove(index);        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void removeObject(List&lt;Integer&gt; list, Object obj) &#123;        long s1 = System.currentTimeMillis();        list.remove(obj);        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void add(List&lt;Integer&gt; list) &#123;        long s1 = System.currentTimeMillis();        list.add(1024);        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void foreach(List&lt;Integer&gt; list) &#123;        long s1 = System.currentTimeMillis();        for (Integer i : list) &#123;            //do nothing        &#125;        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void forSize(List&lt;Integer&gt; list) &#123;        long s1 = System.currentTimeMillis();        int size = list.size();        for (int i = 0; i &lt;size; i++) &#123;            list.get(i);        &#125;        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;    private static void ite(List&lt;Integer&gt; list) &#123;        long s1 = System.currentTimeMillis();        Iterator&lt;Integer&gt; ite = list.iterator();        while (ite.hasNext()) &#123;            ite.next();        &#125;        long s2 = System.currentTimeMillis();        System.out.println(&quot;cost time: &quot; + (s2-s1));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合之Collections-工具类.md</title>
      <link href="/2022/03/20/java-ji-he-zhi-collections-gong-ju-lei/"/>
      <url>/2022/03/20/java-ji-he-zhi-collections-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<p>Collections 工具类常用方法:</p><p>排序<br>查找,替换操作<br>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)<br>###1.5.1. 排序操作</p><p>void reverse(List list)//反转<br>void shuffle(List list)//随机排序<br>void sort(List list)//按自然排序的升序排序<br>void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑</p><pre><code>        ArrayList&lt;Integer&gt; objects = new ArrayList&lt;&gt;();        objects.add(33);        objects.add(21);        objects.add(66);        objects.add(1);        Collections.sort(objects, new Comparator&lt;Integer&gt;() &#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                return o2-o1;            &#125;        &#125;);        System.out.println(objects);</code></pre><p>void swap(List list, int i , int j)//交换两个索引位置的元素<br>void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</p><p>###1.5.2. 查找,替换操作</p><p>int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List内元素必须是有大小顺序的<br>int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)<br>int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)<br>void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。<br>int frequency(Collection c, Object o)//统计元素出现次数<br>int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).<br>boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素</p><p>###1.5.3. 同步控制<br>Collections 提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</p><p>方法如下：</p><p>synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。<br>synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。<br>synchronizedMap(Map&lt;K,V&gt; m) //返回由指定映射支持的同步（线程安全的）Map。<br>synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合之如何决定使用HashMap还是TreeMap？.md</title>
      <link href="/2022/03/20/java-ji-he-zhi-ru-he-jue-ding-shi-yong-hashmap-huan-shi-treemap/"/>
      <url>/2022/03/20/java-ji-he-zhi-ru-he-jue-ding-shi-yong-hashmap-huan-shi-treemap/</url>
      
        <content type="html"><![CDATA[<p>HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。<br>HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。<br>HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。<br>都是非线程安全。</p><p>###使用建议<br>（1）HashMap:适用于在Map中插入、删除和定位元素。<br>（2）Treemap:适用于按自然顺序或自定义顺序遍历键（key）。<br>（3）HashMap通常比TreeMap快一点（树和哈希表的数据结构使然），建议多使用HashMap,在需要排序的Map时候才用TreeMap.<br>（4）HashMap 非线程安全 TreeMap 非线程安全<br>（5）HashMap的结果是没有排序的，而TreeMap输出的结果是排好序的。</p><p>在HashMap中通过get（）来获取value,通过put（）来插入value,ContainsKey（）则用来检验对象是否已经存在。可以看出，和ArrayList的操作相比，HashMap除了通过key索引其内容之外，别的方面差异并不大。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合之大总结.md</title>
      <link href="/2022/03/20/java-ji-he-zhi-da-zong-jie/"/>
      <url>/2022/03/20/java-ji-he-zhi-da-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>Collection</p><p>|　　├AbstractCollection  对Collection接口的最小化抽象实现</p><p>|　　│ </p><p>|　　├List  有序集合</p><p>|　　│-├AbstractList  有序集合的最小化抽象实现 </p><p>|　　│-├ArrayList  基于数组实现的有序集合</p><p>|　　│-├LinkedList  基于链表实现的有序集合</p><p>|　　│-└Vector  矢量队列</p><p>|　　│　└Stack  栈，先进后出</p><p>|　　│</p><p>|　　├Set  不重复集合</p><p>|　　│├AbstractSet  不重复集合的最小化抽象实现</p><p>|　　│├HashSet  基于hash实现的不重复集合，无序</p><p>|　　│├LinkedHashSet  基于hash实现的不重复集合，有序</p><p>|　　│└SortedSet  可排序不重复集合</p><p>|　　│   └NavigableSet  可导航搜索的不重复集合</p><p>|　　│     └TreeSet  基于红黑树实现的可排序不重复集合</p><p>|　　│</p><p>|　　├Queue  队列</p><p>|　　│├AbstractQueue  队列的核心实现</p><p>|　　│├BlockingQueue  阻塞队列</p><p>|　　│└Deque  可两端操作线性集合</p><p>| </p><p>Map  键值映射集合</p><p>|　　├AbstractMap  键值映射集合最小化抽象实现</p><p>|　　├Hashtable  基于哈希表实现的键值映射集合，key、value均不可为null</p><p>|　　├HashMap  类似Hashtable，但方法不同步，key、value可为null</p><p>|　　   └LinkedHashMap  根据插入顺序实现的键值映射集合</p><p>|　　├IdentityHashMap  基于哈希表实现的键值映射集合，两个key引用相等==，认为是同一个key</p><p>|　　├SortedMap   可排序键值映射集合</p><p>|　　   └NavigableMap  可导航搜索的键值映射集合</p><p>|　   └WeakHashMap  弱引用建，不阻塞被垃圾回收器回收，key回收后自动移除键值对</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-218823be9d9a1e5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>可以比较的点：</p><ul><li>  有序、无序</li><li>  可重复、不可重复</li><li>  键、值是否可为null</li><li>  底层实现的数据结构（数组、链表、哈希…）</li><li>  线程安全性</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合基础操作.md</title>
      <link href="/2022/03/20/java-ji-he-ji-chu-cao-zuo/"/>
      <url>/2022/03/20/java-ji-he-ji-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>1、map 边遍历边删除</p><pre><code>   Iterator&lt;Entry&lt;String, Cache&gt;&gt; it = cacheMap.entrySet().iterator();        while (it.hasNext()) &#123;            Entry&lt;String, Cache&gt; next = it.next();            GuavaCache value = (GuavaCache)  next.getValue();            if (value.isEmpty(next.getKey())) &#123;                it.remove();            &#125;        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合测试验证遍历性能.md</title>
      <link href="/2022/03/20/java-ji-he-ce-shi-yan-zheng-bian-li-xing-neng/"/>
      <url>/2022/03/20/java-ji-he-ce-shi-yan-zheng-bian-li-xing-neng/</url>
      
        <content type="html"><![CDATA[<p>###foreach的编译后实现</p><p>对比源码和反编译后的代码</p><p>####使用foreach遍历List</p><pre><code>  // 源码   public static void main(String[] args) &#123;        ArrayList&lt;String&gt; arrayList = new ArrayList();        Collections.addAll(arrayList, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);        for (String s : arrayList) &#123;            System.out.println(s);        &#125;    &#125;    // 反编译后的代码    public static void main(String[] args) &#123;        ArrayList&lt;String&gt; arrayList = new ArrayList();        Collections.addAll(arrayList, new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;);        Iterator var2 = arrayList.iterator();        while(var2.hasNext()) &#123;            String s = (String)var2.next();            System.out.println(s);        &#125;    &#125;</code></pre><p>结论：对于遍历List，foreach底层还是调用的Iterator</p><p>###使用foreach遍历数组</p><pre><code>    //源码    public static void main(String[] args) &#123;        String[] arr = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;;        for (String s : arr) &#123;            System.out.println(s);        &#125;    &#125;  //反编译后 public static void main(String[] args) &#123;        String[] arr = new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;;        String[] var2 = arr;        int var3 = arr.length;        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;            String s = var2[var4];            System.out.println(s);        &#125;    &#125;</code></pre><p>结论：foreach遍历数组最后使用的是for循环</p><p>###RandomAccess接口的原理</p><p>可以看看jdk源码的注释文档</p><pre><code>/** * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that * they support fast (generally constant time) random access.  The primary * purpose of this interface is to allow generic algorithms to alter their * behavior to provide good performance when applied to either random or * sequential access lists. * * &lt;p&gt;The best algorithms for manipulating random access lists (such as * &lt;tt&gt;ArrayList&lt;/tt&gt;) can produce quadratic behavior when applied to * sequential access lists (such as &lt;tt&gt;LinkedList&lt;/tt&gt;).  Generic list * algorithms are encouraged to check whether the given list is an * &lt;tt&gt;instanceof&lt;/tt&gt; this interface before applying an algorithm that would * provide poor performance if it were applied to a sequential access list, * and to alter their behavior if necessary to guarantee acceptable * performance. * * &lt;p&gt;It is recognized that the distinction between random and sequential * access is often fuzzy.  For example, some &lt;tt&gt;List&lt;/tt&gt; implementations * provide asymptotically linear access times if they get huge, but constant * access times in practice.  Such a &lt;tt&gt;List&lt;/tt&gt; implementation * should generally implement this interface.  As a rule of thumb, a * &lt;tt&gt;List&lt;/tt&gt; implementation should implement this interface if, * for typical instances of the class, this loop: * &lt;pre&gt; *     for (int i=0, n=list.size(); i &amp;lt; n; i++) *         list.get(i); * &lt;/pre&gt; * runs faster than this loop: * &lt;pre&gt; *     for (Iterator i=list.iterator(); i.hasNext(); ) *         i.next(); * &lt;/pre&gt; * * &lt;p&gt;This interface is a member of the * &lt;a href=&quot;&#123;@docRoot&#125;/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @since 1.4 */</code></pre><ul><li><p>RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。也就是说，<code>实现了这个接口的集合是支持 快速随机访问 策略的。</code></p></li><li><p>如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。</p></li><li><p>实现RandomAccess接口的集合类<br>java.util.ArrayList、java.util.Vector、java.util.Stack（以为继承自Vector）、java.util.Arrays.ArrayList、java.util.concurrent.CopyOnWriteArrayList、java.util.RandomAccessSubList、java.util.Collections.SingletonList、java.util.Collections.CopiesList、java.util.ArrayList.SubList</p></li><li><p>没有实现RandomAccess接口的集合类<br>java.util.LinkedList</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合容器常用操作.md</title>
      <link href="/2022/03/20/java-ji-he-rong-qi-chang-yong-cao-zuo/"/>
      <url>/2022/03/20/java-ji-he-rong-qi-chang-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>1、快速构建集合容器</p><ul><li>List<pre><code>List&lt;Integer&gt; sList = Arrays.asList(1, 2, 3);</code></pre><code>这样构建出来的不是真正的List，不可以add；</code><br>或者可以这样<pre><code>ArrayList&lt;String&gt; arrayList = new ArrayList();Collections.addAll(arrayList, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);</code></pre></li><li>Map<pre><code>Map&lt;Integer, Integer&gt; newsEventMap = new HashMap() &#123;&#123;    for (int i = 0; i < 100; i++) &#123;        put(i, i);    &#125;&#125;&#125;;</code></pre></li></ul><p>2、集合容器的非空判断<br><code>需要判断集合是否为null和集合内容的size是否为0</code></p><ul><li>List验证不为空：<pre><code>List list = null;if(null != list &amp;&amp; list.size() &gt; 0 )&#123;  System.out.println(&quot;list is not empty&quot;);&#125;else&#123;  System.out.println(&quot;list is empty&quot;);&#125;</code></pre>或者使用工具类<pre><code>List list = new ArrayList();if (org.apache.commons.collections.CollectionUtils.isNotEmpty(list)) &#123;  System.out.println(&quot;list is not empty&quot;);&#125; else &#123;  System.out.println(&quot;list is empty&quot;);&#125;</code></pre></li><li>Map验证不为空：<pre><code>Map hashMap = null;if( null != hashMap &amp;&amp; hashMap.size() &gt; 0 )&#123;  System.out.println(&quot;map is not empty&quot;);&#125;else&#123;  System.out.println(&quot;map is empty&quot;);&#125;</code></pre>或者使用工具类<pre><code>if(org.apache.commons.collections.MapUtils.isNotEmpty(new HashMap()))&#123;  System.out.println(&quot;list is not empty&quot;);&#125;else&#123;  System.out.println(&quot;list is empty&quot;);&#125;</code></pre></li></ul><p>3、List转数组</p><ul><li>错误的写法，会报错<pre><code>String[] arr = (String[]) arrayList.toArray();</code></pre><img src="https://upload-images.jianshu.io/upload_images/13965490-851633f890b46fff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>正确的写法<pre><code>String[] arr = arrayList.toArray(new String[arrayList.size()]);</code></pre></li></ul><p>4、数组转List</p><pre><code>Integer[] arr = &#123;1,2,3,4,5&#125;;ArrayList arrayList = new ArrayList(Arrays.asList(arr));</code></pre><p>5、List截取</p><ul><li>按下标截取subList<pre><code>ArrayList&lt;String&gt; arrayList = new ArrayList();Collections.addAll(arrayList, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);List&lt;String&gt; subList = arrayList.subList(0, 3);//其中subList(0, 3)取得的是下标为0到3的元素System.out.println(subList);//[1, 2, 3]</code></pre></li></ul><p>6、容器元素排序</p><ul><li>Array<pre><code>Integer[] arr = &#123;23,44,1,2,3,43,54,&#125;;Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;  @Override  public int compare(Integer o1, Integer o2) &#123;      return o1-o2;  &#125;&#125;);System.out.println(Arrays.asList(arr));</code></pre></li><li>List</li></ul><p>正序</p><pre><code>List&lt;Integer&gt; intList = Arrays.asList(2, 3, 1);Collections.sort(intList);System.out.println(intList);</code></pre><p>倒序</p><pre><code>List&lt;Integer&gt; intList = Arrays.asList(2, 3, 1);Collections.sort(intList, new Comparator&lt;Integer&gt;() &#123;    @Override    public int compare(Integer o1, Integer o2) &#123;        // 返回值为int类型，大于0表示正序，小于0表示逆序        return o2 - o1;    &#125;&#125;);System.out.println(intList);</code></pre><p>7、List<Object> 转 List<String><br>    List<String> strs = (List<String>)(List)objects;</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合的-Fail-Fast-Iterators-和-Fail-safe-Iterators.md</title>
      <link href="/2022/03/20/java-ji-he-de-fail-fast-iterators-he-fail-safe-iterators/"/>
      <url>/2022/03/20/java-ji-he-de-fail-fast-iterators-he-fail-safe-iterators/</url>
      
        <content type="html"><![CDATA[<p>引用 <a href="https://www.codejava.net/java-core/collections/understanding-collections-and-thread-safety-in-java">https://www.codejava.net/java-core/collections/understanding-collections-and-thread-safety-in-java</a></p><h3 id="Fail-Fast-Iterators"><a href="#Fail-Fast-Iterators" class="headerlink" title="Fail-Fast Iterators"></a>Fail-Fast Iterators</h3><ul><li>迭代器遍历集合，过程中对集合对象的内容进行了修改( add、remove、update），则会抛出ConcurrentModificationException</li><li>java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改，迭代过程中被修改</li></ul><p>###测试代码</p><pre><code>import java.util.*;/** * This test program illustrates how a collection&#39;s iterator fails fast * and throw ConcurrentModificationException * @author www.codejava.net * */public class IteratorFailFastTest &#123;    private List&lt;Integer&gt; list = new Vector&lt;&gt;();    public IteratorFailFastTest() &#123;        for (int i = 0; i &lt; 10_000; i++) &#123;            list.add(i);        &#125;    &#125;    public void runUpdateThread() &#123;        Thread thread1 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                for (int i = 10_000; i &lt; 20_000; i++) &#123;                    list.add(i);                &#125;            &#125;        &#125;);        thread1.start();    &#125;    public void runIteratorThread() &#123;        Thread thread2 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                ListIterator&lt;Integer&gt; iterator = list.listIterator();                while (iterator.hasNext()) &#123;                    Integer number = iterator.next();                    System.out.println(number);                &#125;            &#125;        &#125;);        thread2.start();    &#125;    public static void main(String[] args) &#123;        IteratorFailFastTest tester = new IteratorFailFastTest();        tester.runIteratorThread();        tester.runUpdateThread();    &#125;&#125;</code></pre><p>抛出ConcurrentModificationException异常<br><img src="https://upload-images.jianshu.io/upload_images/13965490-bae5b7a19cfa283d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###Fail-safe Iterators </p><ul><li>先copy原有集合内容，在copy的集合上进行遍历</li><li>迭代器并不能访问到修改后的内容</li><li>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><ul><li>java.util.concurrent.CopyOnWriteArrayList代替原来的java.utils.Vector<br>~~~<br>import java.util.*;<br>import java.util.concurrent.CopyOnWriteArrayList;</li></ul><p>/**</p><ul><li><p>This test program illustrates how a collection’s iterator fails fast</p></li><li><p>and throw ConcurrentModificationException</p></li><li><p>@author <a href="http://www.codejava.net/">www.codejava.net</a></p></li><li></li><li><p>/<br>public class IteratorFailFastTest {</p><p>  private List<Integer> list = new CopyOnWriteArrayList<Integer>();</p><p>  public IteratorFailFastTest() {</p><pre><code>  for (int i = 0; i &lt; 10_000; i++) &#123;      list.add(i);  &#125;</code></pre><p>  }</p><p>  public void runUpdateThread() {</p><pre><code>  Thread thread1 = new Thread(new Runnable() &#123;      @Override      public void run() &#123;          for (int i = 10_000; i &lt; 20_000; i++) &#123;              list.add(i);          &#125;      &#125;  &#125;);  thread1.start();</code></pre><p>  }</p></li></ul><pre><code>public void runIteratorThread() &#123;    Thread thread2 = new Thread(new Runnable() &#123;        @Override        public void run() &#123;            ListIterator&lt;Integer&gt; iterator = list.listIterator();            while (iterator.hasNext()) &#123;                Integer number = iterator.next();                System.out.println(number);            &#125;        &#125;    &#125;);    thread2.start();&#125;public static void main(String[] args) &#123;    IteratorFailFastTest tester = new IteratorFailFastTest();    tester.runIteratorThread();    tester.runUpdateThread();&#125;</code></pre><p>}</p><pre><code>- 正常执行![image.png](https://upload-images.jianshu.io/upload_images/13965490-c7299ea60ffe9b88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合类特征总结.md</title>
      <link href="/2022/03/20/java-ji-he-lei-te-zheng-zong-jie/"/>
      <url>/2022/03/20/java-ji-he-lei-te-zheng-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>1、要有全都有，要无全都无（指的是顺序和是否重复）<br>ArrayList 有序，可重复<br>HashSet/HashMap 无序，不可重复</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合结构.md</title>
      <link href="/2022/03/20/java-ji-he-jie-gou/"/>
      <url>/2022/03/20/java-ji-he-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>###1.1.3. 集合框架底层数据结构总结<br>先来看一下 Collection 接口下面的集合。</p><p>####1.1.3.1. List<br>Arraylist： Object[]数组<br>Vector：Object[]数组<br>LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)<br>####1.1.3.2. Set<br>HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素<br>LinkedHashSet：LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的<br>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)<br>再来看看 Map 接口下面的集合。</p><p>####1.1.3.3. Map<br>HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p><p>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》<br>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</p><p>TreeMap： 红黑树（自平衡的排序二叉树）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合问题基础.md</title>
      <link href="/2022/03/20/java-ji-he-wen-ti-ji-chu/"/>
      <url>/2022/03/20/java-ji-he-wen-ti-ji-chu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md#111-java-%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md#111-java-%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88</a></p><h3 id="说说-List-Set-Map-三者的区别？"><a href="#说说-List-Set-Map-三者的区别？" class="headerlink" title="说说 List,Set,Map 三者的区别？"></a>说说 List,Set,Map 三者的区别？</h3><p>List(对付顺序的好帮手)<br>Set(注重独一无二的性质)<br>Map(用 Key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，”y”代表 value；Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的<code>哈希值</code>决定的。说HashSet无序其实也是有序的，只是根据哈希值排的序，这根本没有意义。</p><p>如下HashSet两次打印都是：</p><blockquote><p>[afafa2, afafa1, afafa4, afafa3]<br>[afafa2, afafa1, afafa4, afafa3]</p></blockquote><pre><code>        Set&lt;String&gt; set = new HashSet&lt;&gt;();        set.add(&quot;afafa1&quot;);        set.add(&quot;afafa2&quot;);        set.add(&quot;afafa3&quot;);        set.add(&quot;afafa4&quot;);        System.out.println(set);        System.out.println(set);</code></pre><p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p><p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p><p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><p>###Arraylist 与 LinkedList 区别?<br>1、是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>2、底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 <code>双向链表</code> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p><p>3、插入和删除是否受元素位置的影响：ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</p><p>4、LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</p><p>5、是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p><p>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><p>6、内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合问题基础之List.md</title>
      <link href="/2022/03/20/java-ji-he-wen-ti-ji-chu-zhi-list/"/>
      <url>/2022/03/20/java-ji-he-wen-ti-ji-chu-zhi-list/</url>
      
        <content type="html"><![CDATA[<p>###Arraylist 和 Vector 的区别?<br>ArrayList 是 List 的主要实现类，底层使用 Object[ ]存储，适用于频繁的查找工作，线程不安全 ；<br>Vector 是 List 的古老实现类，底层使用Object[ ] 存储，线程安全的。</p><h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h3><p>1、是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p><p>2、底层数据结构： Arraylist 底层使用的是<code>Object 数组</code>；LinkedList 底层使用的是 <code>双向链表</code> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p><p>3、插入和删除是否受元素位置的影响：<br>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的<code>末尾</code>，这种情况时间复杂度就是 O(1)。<strong>但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 <code>O(n-i)</code>。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</strong></p><p>LinkedList 采用链表存储，所以，如果是在<code>头尾</code>插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，**如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） <code>时间复杂度近似为 O(n)</code>**，因为需要先移动到指定位置再插入。</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-6a5deab5e66b7c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>4、是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p><p>5、内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会<strong>预留一定的容量空间（因为会到达0.75加载因子时会自动扩容。总会有一些剩余空间的）</strong>，<strong>而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</strong>。<code>LinkedList初始化不能指定初始容量</code>,所以也就不会自动扩容。</p><p>###补充内容:双向链表和双向循环链表<br>双向链表： 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。<br>另外推荐一篇把双向链表讲清楚的文章：<a href="https://juejin.im/post/5b5d1a9af265da0f47352f14">https://juejin.im/post/5b5d1a9af265da0f47352f14</a></p><p>双向循环链表： 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p>###补充内容:RandomAccess 接口<br>public interface RandomAccess {<br>}<br>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 binarySearch（) 方法中，它要判断传入的 list 是否 RamdomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法</p><pre><code>public static &lt;T&gt;int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)        return Collections.indexedBinarySearch(list, key);    else        return Collections.iteratorBinarySearch(list, key);&#125;</code></pre><p>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。**链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)**，所以不支持快速随机访问。ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><p>###说一说 ArrayList 的扩容机制吧</p><p>默认初始10  、原来的 1.5倍、第一次add才会将容量设置为10个（懒汉）；<br>底层使用Arrays.copy扩容；<br>最大容量是 Integer.Max - 8 或者 Integer.Max ；</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合问题基础之Set.md</title>
      <link href="/2022/03/20/java-ji-he-wen-ti-ji-chu-zhi-set/"/>
      <url>/2022/03/20/java-ji-he-wen-ti-ji-chu-zhi-set/</url>
      
        <content type="html"><![CDATA[<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null 值；</p><p>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；</p><p>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h3><p>以下内容摘自我的 Java 启蒙书《Head fist java》第二版：</p><p>当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p><blockquote><p>先判断hashcode，再判断equals()</p></blockquote><p>####hashCode()与 equals() 的相关规定：</p><p>1、如果两个对象相等，则 hashcode 一定也是相同的<br>2、两个对象相等,对两个 equals() 方法返回 true<br>3、两个对象有相同的 hashcode 值，它们也不一定是相等的</p><p>综上，equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖<br>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p><p>####==与 equals 的区别</p><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合问题基础之Map.md</title>
      <link href="/2022/03/20/java-ji-he-wen-ti-ji-chu-zhi-map/"/>
      <url>/2022/03/20/java-ji-he-wen-ti-ji-chu-zhi-map/</url>
      
        <content type="html"><![CDATA[<p>###HashMap 和 Hashtable 的区别</p><p>1、线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p><p>2、效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p><p>3、对 Null key 和 Null value 的支持： HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</p><p>4、初始容量大小和每次扩充容量大小的不同 ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap 默认的初始化大小为 16</code>。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为<code> 2 的幂次方大小</code>（仅仅大于元素个数的<code>2的最小公倍数</code>；HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p><pre><code>    public HashMap(int initialCapacity, float loadFactor) &#123;        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;         //initialCapacity=1,threshold =2;        //initialCapacity=2,threshold =2;        //initialCapacity=3,threshold =4;        //initialCapacity=4，threshold =4        //initialCapacity=5，threshold =8        //initialCapacity=6，threshold =8        //initialCapacity=7，threshold =8        //initialCapacity=8，threshold =8        //initialCapacity=9，threshold =16        this.threshold = tableSizeFor(initialCapacity);    &#125;</code></pre><pre><code>    static final int tableSizeFor(int cap) &#123;        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    &#125;</code></pre><p>5、底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（<strong>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p><p>###HashMap 和 HashSet 区别<br>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><p>HashMap    HashSet<br>实现了 Map 接口    实现 Set 接口<br>存储键值对    仅存储对象<br>调用 put()向 map 中添加元素    调用 add()方法向 Set 中添加元素<br>HashMap 使用键（Key）计算 hashcode    HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</p><p>###HashMap 和 TreeMap 区别<br>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。</p><p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。<br>实现SortMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p><pre><code>import java.util.Comparator;import java.util.TreeMap;public class Person &#123;    private Integer age;    public Person(Integer age) &#123;        this.age = age;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public static void main(String[] args) &#123;        TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person person1, Person person2) &#123;                int num = person1.getAge() - person2.getAge();                return Integer.compare(num, 0);            &#125;        &#125;);        treeMap.put(new Person(3), &quot;person1&quot;);        treeMap.put(new Person(18), &quot;person2&quot;);        treeMap.put(new Person(35), &quot;person3&quot;);        treeMap.put(new Person(16), &quot;person4&quot;);        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;            System.out.println(personStringEntry.getValue());        &#125;);        treeMap.    &#125;&#125;</code></pre><p>输出:<br>person1<br>person4<br>person2<br>person3<br>可以看出，TreeMap 中的元素已经是按照 Person 的 age 字段的升序来排列了。</p><p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p><pre><code>TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;((person1, person2) -&gt; &#123;  int num = person1.getAge() - person2.getAge();  return Integer.compare(num, 0);&#125;);</code></pre><p>综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素<code>根据键排序的能力</code>以及对集合内元素的<code>搜索</code>的能力。</p><p>###HashMap 的长度为什么是 2 的幂次方<br>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p>这个算法应该如何设计呢？</p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</p><h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的 <code>Rehash</code> 会造成元素之间会形成一个<code>循环链表</code>。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p><h3 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap 有哪几种常见的遍历方式?</h3><p>迭代器 EntrySet  <code> 提倡使用，据说性能最佳；</code></p><p> HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，我们应该尽量使用迭代器（Iterator）来遍历 EntrySet 的遍历方式来操作 Map 集合，这样就会既安全又高效了。</p><pre><code>public class HashMapTest &#123;    public static void main(String[] args) &#123;        // 创建并赋值 HashMap        Map&lt;Integer, String&gt; map = new HashMap();        map.put(1, &quot;Java&quot;);        map.put(2, &quot;JDK&quot;);        map.put(3, &quot;Spring Framework&quot;);        map.put(4, &quot;MyBatis framework&quot;);        map.put(5, &quot;Java中文社群&quot;);        // 遍历        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();        while (iterator.hasNext()) &#123;            Map.Entry&lt;Integer, String&gt; entry = iterator.next();            System.out.println(entry.getKey());            System.out.println(entry.getValue());        &#125;    &#125;&#125;</code></pre><p>###ConcurrentHashMap 和 Hashtable<br>的区别主要体现在实现线程安全的方式上不同。</p><p>1、底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，<code>数组+链表/红黑二叉树</code>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，<strong>链表则是主要为了解决哈希冲突而存在的</strong>；</p><p>2、实现线程安全的方式（重要）：<br> ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用<code>synchronized 和 CAS</code>来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；<br>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><p>###ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</p><p>JDK1.7（上面有示意图）<br>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。<br>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。<br>static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {<br>}<br>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p><p>JDK1.8 （上面有示意图）<br><strong>ConcurrentHashMap 取消了 Segment 分段锁</strong>，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。<code>Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</code></p><p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8-map和flatMap区别.md</title>
      <link href="/2022/03/20/java8-map-he-flatmap-qu-bie/"/>
      <url>/2022/03/20/java8-map-he-flatmap-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><strong>我们先来了解什么是流的扁平化</strong></p><p>对比下面两个例子，观察他们的输出结果<br>eg1</p><pre><code>   public static void main(String[] args) &#123;        List&lt;String&gt; list = Arrays.asList(&quot;A,a&quot;, &quot;B,b&quot;,&quot;C,c&quot;);        List&lt;String[]&gt; collect = list.stream().map(s -&gt; s.split(&quot;,&quot;)).collect(Collectors.toList());        System.out.println(JSON.toJSONString(collect));    &#125;</code></pre><blockquote><p>[[“A”,”a”],[“B”,”b”],[“C”,”c”]]</p></blockquote><p>eg2</p><pre><code>   public static void main(String[] args) &#123;        List&lt;String&gt; list = Arrays.asList(&quot;A,a&quot;, &quot;B,b&quot;,&quot;C,c&quot;);        List&lt;String&gt; collect = list.stream().map(s -&gt; s.split(&quot;,&quot;)).flatMap(Arrays::stream)            .collect(Collectors.toList());        System.out.println(collect);    &#125;</code></pre><blockquote><p>[A, a, B, b, C, c]</p></blockquote><p>eg2只是比eg1多个一步flatMap(Arrays::stream)。这样他们两个的结果就不相同了。<br>map返回了List&lt;String[]&gt;，而flatMap返回了 List<String>。flatMap返回值维度比map小了一个级别。</p><p>整个过程可以简单示意如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-c74c6c9f87feab06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8-新特性之LocalDate.md</title>
      <link href="/2022/03/20/java8-xin-te-xing-zhi-localdate/"/>
      <url>/2022/03/20/java8-xin-te-xing-zhi-localdate/</url>
      
        <content type="html"><![CDATA[<p>这是对java.util.Date强有力的补充，解决了 Date 类的大部分痛点：</p><ul><li>非线程安全</li><li>时区处理麻烦</li><li>各种格式化、和时间计算繁琐</li><li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li></ul><p>java.util.Date 既包含日期又包含时间，而 java.time 把它们进行了分离：</p><ul><li>LocalDateTime.class //日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</li><li>LocalDate.class //日期 format: yyyy-MM-dd</li><li>LocalTime.class //时间 format: HH:mm:ss</li></ul><p>###格式化时间format</p><pre><code>    public static void main(String[] args) &#123;        //format yyyy-MM-dd        LocalDate date = LocalDate.now();        System.out.println(String.format(&quot;date format : %s&quot;, date));        //format HH:mm:ss        LocalTime time = LocalTime.now().withNano(0);        System.out.println(String.format(&quot;time format : %s&quot;, time));        //format yyyy-MM-dd HH:mm:ss        LocalDateTime dateTime = LocalDateTime.now();        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String format = dateTimeFormatter.format(dateTime);        System.out.println(String.format(&quot;dateTime format : %s&quot;, format));    &#125;</code></pre><p>###字符串/数字转时间parse</p><pre><code>    public static void main(String[] args) &#123;        LocalDate date = LocalDate.of(2021, 1, 26);        System.out.println(date);        LocalDate parse = LocalDate.parse(&quot;2021-01-26&quot;);        System.out.println(parse);        LocalTime time = LocalTime.of(12, 12, 22);        LocalTime parse1 = LocalTime.parse(&quot;12:12:22&quot;);        System.out.println(time);        System.out.println(parse1);        LocalDateTime dateTime = LocalDateTime.of(2021, 1, 26, 12, 12, 22);        LocalDateTime parse2 = LocalDateTime.parse(&quot;2021-01-26T12:12:22&quot;);        System.out.println(dateTime);        System.out.println(parse2);    &#125;</code></pre><p>###计算年龄</p><pre><code>    public static void main(String[] args) &#123;        LocalDate date1 = LocalDate.now();        LocalDate date2 = LocalDate.of(1997, 6, 27);        int age = date2.until(date1).getYears();        System.out.println(age);    &#125;</code></pre><p>###date与LocalDate</p><pre><code>1.Date转换成LocalDate    public static LocalDate date2LocalDate(Date date) &#123;        if(null == date) &#123;            return null;        &#125;        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();    &#125;2.LocalDate转换成Date    public static Date localDate2Date(LocalDate localDate) &#123;        if(null == localDate) &#123;            return null;        &#125;        ZonedDateTime zonedDateTime = localDate.atStartOfDay(ZoneId.systemDefault());        return Date.from(zonedDateTime.toInstant());    &#125;2.LocalDateTime转换成Date    public static Date localDateTime2Date(LocalDateTime localDateTime) &#123;        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());    &#125;3.LocalDate格式化    public static String formatDate(Date date) &#123;        LocalDate localDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();        return localDate.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));    &#125;</code></pre><p>java.time.temporal.TemporalAdjusters 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p><p>###JDBC 和 java8<br>现在 jdbc 时间类型和 java8 时间类型对应关系是<br>Date —&gt; LocalDate<br>Time —&gt; LocalTime<br>TimesSamp —&gt; LocalDateTime</p><p>而之前统统对应 Date，也只有 Date。</p><p>获取指定时间</p><pre><code>        Calendar calendar2 = Calendar.getInstance();        calendar2.set(calendar2.get(Calendar.YEAR), calendar2.get(Calendar.MONTH), calendar2.get(Calendar.DAY_OF_MONTH),                17, 00, 00);        final DateTime of = DateTime.of(calendar2);        LocalDateTime ldt = LocalDateTime.of(LocalDate.now(), LocalTime.of(17,0));        System.out.println(ldt);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8-新特性之函数式接口Function、Consumer、Supplier、Predicate.md</title>
      <link href="/2022/03/20/java8-xin-te-xing-zhi-han-shu-shi-jie-kou-function-consumer-supplier-predicate/"/>
      <url>/2022/03/20/java8-xin-te-xing-zhi-han-shu-shi-jie-kou-function-consumer-supplier-predicate/</url>
      
        <content type="html"><![CDATA[<p>java8引入了四大函数式接口：Function、Consumer、Supplier、Predicate；这几个接口在Optional类中有大量应用，之前我们刚好学习了Optional的用法 <a href="https://www.jianshu.com/p/3b23034416f9%E3%80%82%E8%BF%99%E6%AC%A1%E5%9C%A8%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89%E4%BA%86%E3%80%82">https://www.jianshu.com/p/3b23034416f9。这次在这里可以举一反三了。</a></p><p>###还有一个Runnabel<br>既没有出参也没有入参<br>###Function&lt;T, R&gt; <br>Function&lt;T, R&gt; T：入参类型，R：出参类型</p><pre><code>    public static void main(String[] args) &#123;        // 定义Function        Function&lt;Integer, Integer&gt; func = p -&gt; p * 10;        //调用        Integer apply = func.apply(11);        System.out.println(apply);    &#125;</code></pre><p>Optional类中有:Optional.map()、Optional.flatMap()</p><pre><code>    public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;        Objects.requireNonNull(mapper);        if (!isPresent())            return empty();        else &#123;            return Optional.ofNullable(mapper.apply(value));        &#125;    &#125;</code></pre><p>###Consumer<T></p><blockquote><p>因为没有出参，常用于打印、发送短信等消费动作</p></blockquote><p>Consumer<T>  T：入参类型；没有出参</p><pre><code>  public static void main(String[] args) &#123;        // 定义Consumer        Consumer&lt;String&gt; consumer= p -&gt; System.out.println(p);        //调用        consumer.accept(&quot;18800008888&quot;);    &#125;</code></pre><p>Optional类中有: Optional.Consumer()</p><pre><code>    public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;        if (value != null)            consumer.accept(value);    &#125;</code></pre><p>##Supplier<T></p><blockquote><p>常用于业务“有条件运行”时，符合条件再调用获取结果的应用场景；运行结果须提前定义，但不运行。</p></blockquote><p>Supplier<T> T：出参类型；没有入参</p><pre><code>    public static void main(String[] args) &#123;       //定义        Supplier&lt;Integer&gt; supplier= () -&gt; 100;        //调用        Integer integer = supplier.get();        System.out.println(integer);    &#125;</code></pre><p>Optional类中有:Optional.orElseGet() 和 Optional.orElseThrow()</p><pre><code>    public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;        return value != null ? value : other.get();    &#125;    public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;        if (value != null) &#123;            return value;        &#125; else &#123;            throw exceptionSupplier.get();        &#125;    &#125;</code></pre><p>orElseGet、orElseThrow 中表达式运行的条件是：如果前面用了map(m-&gt;m.get(xx))，那么就是m.get(xx)为空时；如果前面用的filter(xxx) 那么就是xxx表达式返回false时。</p><p>###Predicate<T></p><p>Predicate<T> T：入参类型；出参类型是Boolean</p><pre><code>    public static void main(String[] args) &#123;        //定义Predicate        Predicate&lt;Integer&gt; predicate = p -&gt; p % 2 == 0;        //调用        predicate.test(100);    &#125;</code></pre><p>Optional类中有:Optional.filter()</p><pre><code>    public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123;        Objects.requireNonNull(predicate);        if (!isPresent())            return this;        else            return predicate.test(value) ? this : empty();    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8-流的异步迭代.md</title>
      <link href="/2022/03/20/java8-liu-de-yi-bu-die-dai/"/>
      <url>/2022/03/20/java8-liu-de-yi-bu-die-dai/</url>
      
        <content type="html"><![CDATA[<p>java 8 提供了parallelStream并行流，我们可以结合forEach方法轻松实现多线程的迭代</p><pre><code>        /**         * 串行流         */        Stream.of(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;, &quot;D&quot;).forEach(s-&gt;System.out.println(&quot;串行流 forEach:&quot;+s));        Stream.of(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;, &quot;D&quot;).forEachOrdered(s-&gt;System.out.println(&quot;串行流 forEachOrdered:&quot;+s));        /**         * 并行流         */        Stream.of(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;, &quot;D&quot;).parallel().forEach(s-&gt;System.out.println(&quot;并行流 forEach :&quot;+s));        Stream.of(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;, &quot;D&quot;).parallel().forEachOrdered(s-&gt;System.out.println(&quot;并行流 forEachOrdered:&quot;+s));</code></pre><p>forEachOrdered () 总是会按照元素给定的顺序执行操作，而 forEach () 方法是不确定的。</p><ul><li>在并行流中， forEach () 方法未必顺序执行，而 forEachOrdered () 永远顺序执行。</li><li>在顺序流中，两种方法相同。 </li><li>所以想要动作在每个情况下都有序执行，我们应该使用 forEachOrdered () 方法。<blockquote><p>parallel 遇到 forEach  就不会保证顺序了</p></blockquote></li></ul><p>###Stream.forEach ()<br>java文档中forEach 方法声明。</p><p>void forEach(Consumer&lt;? super T&gt; action)</p><ol><li><p>执行一个动作, 消费者为每个元素的流。</p></li><li><p>这是一个终端操作。</p></li><li><p>这个操作的行为是不确定的。</p></li><li><p>并行操作这种方法并不能保证顺序。</p></li></ol><p>###Stream.forEachOrdered ()<br>java文档中forEachOrdered 方法声明。</p><p>void forEachOrdered(Consumer&lt;? super T&gt; action)</p><ol><li><p>如果流具有定义的执行顺序，则以此流的执行顺序为此流的每个元素执行操作。</p></li><li><p>这是一个终端操作。</p></li><li><p>这种方法保证在顺序和并行流中按顺序执行。</p></li></ol><p>###parallel并行流里是其实是多线程迭代<br>而且包括主线程在内</p><pre><code>        /**         * 并行流         */        Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).parallel().forEach(s -&gt; &#123;                    System.out.println(Thread.currentThread().getName()+&quot; &quot;+s);                &#125;        );</code></pre><p>main C<br>main D<br>ForkJoinPool.commonPool-worker-2 B<br>ForkJoinPool.commonPool-worker-1 A</p><p>###缺陷<br>1、不能使用break和continue这两个关键字</p><p>foreach和普通的for循环是不同的，它不是普通的遍历，要想实现continue的效果，可以直接使用return即可；<br>但是如何实现break的效果呢，然而foreach是无法实现的，只要你使用它，就一定会遍历完的，除非你可以把它放进一个try中，通过抛出异常进行终止它。或者我们实现fillter一下，将不需要遍历的筛选出去。保证流中一定是我们需要遍历的</p><pre><code>        /**         * 并行流         */        Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).parallel().forEachOrdered(s -&gt; &#123;                    if (Objects.equals(s, &quot;A&quot;)) &#123;                        return;                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + s);                &#125;        );</code></pre><p>2、流的迭代非安全</p><pre><code>        ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();        strings.add(&quot;1&quot;);        strings.add(&quot;2&quot;);        strings.add(&quot;3&quot;);        strings.add(&quot;4&quot;);        strings.stream().forEach(e-&gt;&#123;            if(Objects.equals(e,&quot;1&quot;))&#123;                strings.remove(&quot;1&quot;);            &#125;        &#125;);        System.out.println(strings);</code></pre><p>以上程序的执行结果：</p><p>测试结果：Lambda 循环中删除数据非安全。Lambda 删除的正确方式：</p><pre><code>        ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();        strings.add(&quot;1&quot;);        strings.add(&quot;2&quot;);        strings.add(&quot;3&quot;);        strings.add(&quot;4&quot;);        strings.removeIf(s -&gt; Objects.equals(&quot;1&quot;, s));        strings.stream().forEach(s -&gt; &#123;            System.out.println(s);        &#125;);</code></pre><p>从上面的代码可以看出，可以先使用 Lambda 的 removeIf 删除多余的数据，再进行循环是一种正确操作集合的方式。</p><p>写法举例</p><pre><code>        for (Map&lt;String, Object&gt; map : supplierNoOption) &#123;            String supplierNo = (String) map.get(&quot;supplierNo&quot;);            if (StringUtils.equals(supplierNo, mbUndertakesOrderDto.getSupplierNo())) &#123;                map.put(&quot;isSelect&quot;, true);            &#125; else &#123;                map.put(&quot;isSelect&quot;, false);            &#125;        &#125;</code></pre><p>改为</p><pre><code>supplierNoOption.stream().forEach(map -&gt; map.put(&quot;isSelect&quot;, Objects.equals(map.get(&quot;supplierNo&quot;), mbUndertakesOrderDto.getSupplierNo())));</code></pre><p>3、并行流里由于使用多线程。则会造成线程不安全<br>虽然不会出现异常，但是会丢数据。如下使用ArrayList会丢数据，请用CopyOnWriteArrayList代替之</p><pre><code>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 99999; i++) &#123;            list.add(i);        &#125;        System.out.println(list.size());       / List&lt;Integer&gt; objects = new ArrayList&lt;&gt;();        List&lt;Integer&gt; objects = new CopyOnWriteArrayList&lt;&gt;();        list.parallelStream().forEach(m -&gt; &#123;            objects.add(m);        &#125;);        System.out.println(objects.size());        if (objects.size() &lt; list.size()) &#123;            System.out.println(&quot;丢数据了..&quot;);        &#125; else &#123;            System.out.println(&quot;没丢&quot;);        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8-箭头函数和方法引用、Lambda表达式.md</title>
      <link href="/2022/03/20/java8-jian-tou-han-shu-he-fang-fa-yin-yong-lambda-biao-da-shi/"/>
      <url>/2022/03/20/java8-jian-tou-han-shu-he-fang-fa-yin-yong-lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<pre><code>filter(p -&gt; p.getAge()&gt;18)</code></pre><p>p方法参数 -&gt; p.getAge()&gt;18 方法内容</p><p>这里是将整个箭头函数作为参数传递给map方法。map方法源码如下：</p><pre><code>   public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;        Objects.requireNonNull(mapper);        if (!isPresent())            return empty();        else &#123;            return Optional.ofNullable(mapper.apply(value));        &#125;    &#125;</code></pre><p>可以看到map方法的参数是：</p><blockquote><p>Function&lt;? super T, ? extends U&gt; mapper</p></blockquote><p>第一眼看成两个参数举个手~，其实只有一个类型为<code>Function&lt;? super T, ? extends U&gt;</code>的mapper参数;<br>故这就是箭头函数的类型<code>Function</code></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javax-validation和hibernate-validator参数校验.md</title>
      <link href="/2022/03/20/javax-validation-he-hibernate-validator-can-shu-xiao-yan-md/"/>
      <url>/2022/03/20/javax-validation-he-hibernate-validator-can-shu-xiao-yan-md/</url>
      
        <content type="html"><![CDATA[<h1 id="javax-validation和hibernate-validator参数校验"><a href="#javax-validation和hibernate-validator参数校验" class="headerlink" title="javax.validation和hibernate-validator参数校验"></a>javax.validation和hibernate-validator参数校验</h1><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>这两个包要同时导入！</p><pre><code>   &lt;dependency&gt;        &lt;groupId&gt;javax.validation&lt;/groupId&gt;        &lt;artifactId&gt;validation-api&lt;/artifactId&gt;        &lt;version&gt;2.0.1.Final&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;        &lt;version&gt;6.0.7.Final&lt;/version&gt;      &lt;/dependency&gt;</code></pre><p>Controller</p><pre><code>    @PostMapping(&quot;/tabletSign/pushInfo/patient&quot;)    public AjaxResult pushInfoPatient(@Valid @RequestBody BizPatient bizPatient) &#123;    &#125;</code></pre><p>JavaBean</p><pre><code>public class BizPatient &#123;    private static final long serialVersionUID = 1L;    @NotNull(message = &quot;id不能为空&quot;)    private Long patientId;&#125;</code></pre><h3 id="Validated和-Valid的区别"><a href="#Validated和-Valid的区别" class="headerlink" title="@Validated和@Valid的区别"></a>@Validated和@Valid的区别</h3><p><strong>在Controller中校验方法参数时，使用@Valid和@Validated并无特殊差异（若不需要分组校验的话）</strong><br>@Valid：标准JSR-303规范的标记型注解，用来标记验证属性和方法返回值，进行级联和递归校验<br>@Validated：Spring的注解，是标准JSR-303的一个变种（补充），提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制</p><p>方法级别：<br><strong>@Validated注解可以用于类级别</strong>，用于支持Spring进行方法级别的参数校验。**@Valid可以用在属性级别约束，用来表示级联校验。**<br>@Validated只能用在类、方法和参数上，而@Valid可用于方法、字段、构造器和参数上</p><h3 id="如何分组校验？"><a href="#如何分组校验？" class="headerlink" title="如何分组校验？"></a>如何分组校验？</h3><p>有时候我们需要在不同的Controller中校验不同的字段</p><p>Controller</p><pre><code>    @PostMapping(&quot;/tabletSign/pushInfo/patient&quot;)    public AjaxResult pushInfoPatient(        @Validated(BizPatient.SaveGroup.class) @RequestBody BizPatient bizPatient) &#123;    &#125;    @PostMapping(&quot;/tabletSign/patient/signerInfo&quot;)    public AjaxResult getSignerInfo(        @Validated(BizPatient.SelectGroup.class) @RequestBody BizPatient bizPatient) &#123;    &#125;</code></pre><p>JavaBean</p><pre><code>public class BizPatient &#123;    private static final long serialVersionUID = 1L;    /**     * $column.columnComment     */    //非空判断    @NotNull(groups = &#123;SaveGroup.class, SelectGroup.class&#125;, message = &quot;patientId 不能为空&quot;)    private Long patientId&#125;</code></pre><h3 id="如何校验关联对象？"><a href="#如何校验关联对象？" class="headerlink" title="如何校验关联对象？"></a>如何校验关联对象？</h3><pre><code>    @PostMapping(value = &quot;/saveOrUpdate&quot;)    public GbmResult saveOrUpdate(@RequestBody @Validated GdVo gdVo) &#123;    &#125;@Datapublic class GdVo &#123;    @Valid    private GdAfterSalesDto gdAfterSalesDto;    @Valid    private List&lt;GdProcessRecordDto&gt; gdProcessRecordDto;&#125;</code></pre><h3 id="校验List"><a href="#校验List" class="headerlink" title="校验List"></a>校验List</h3><p>Controller类上加@Validated</p><pre><code>@Validatedpublic class ZskKnowledgeController &#123;</code></pre><pre><code>@PostMapping(value = &quot;/saveOrUpdateZskAccessories&quot;)    public GbmResult saveOrUpdateZskAccessories(@RequestBody @Valid List&lt;ZskAccessoriesListType&gt; zskKnowledgeVoList) &#123;</code></pre><h3 id="手动校验工具类"><a href="#手动校验工具类" class="headerlink" title="手动校验工具类"></a>手动校验工具类</h3><p>有时候注解不生效，我们可以手动校验</p><pre><code>import org.springframework.validation.BindingResult;import javax.validation.ConstraintViolation;import javax.validation.Validation;import javax.validation.Validator;import java.util.Set;import java.util.stream.Collectors;public class ValidParameterUtils &#123;    private static Validator validator;    static &#123;        validator = Validation.buildDefaultValidatorFactory().getValidator();    &#125;    public static void validParameter(BindingResult validResult)&#123;        if (validResult.hasErrors())&#123;            throw new GBMException(validResult.getFieldError().getDefaultMessage(),GbmResultCode.PARAMETER_EXCEPTION.code());        &#125;    &#125;    public static void validateEntity(Object object, Class&lt;?&gt;... groups)            throws GBMException &#123;        Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolations = validator.validate(object, groups);        if (!constraintViolations.isEmpty()) &#123;            StringBuilder msg = new StringBuilder();            for(ConstraintViolation&lt;Object&gt; constraint:  constraintViolations)&#123;                msg.append(constraint.getMessage()).append(&quot;  &quot;);            &#125;            throw new GBMException(msg.toString(),GbmResultCode.FAIL.code());        &#125;    &#125;    /**     * @Des 返回错误信息     * @Author yinkai     * @Date 2022/2/28 9:24     */    public static String validateEntityRString(Object object, Class&lt;?&gt;... groups) &#123;        Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolations = validator.validate(object, groups);        return constraintViolations.stream().map(ConstraintViolation::getMessage).collect(Collectors.joining(&quot;  &quot;));    &#125;&#125;</code></pre><p>使用</p><pre><code>public class ZskQuestionsAndAnswersVo &#123;    @NotNull(groups = &#123;AddGroup.class&#125;, message = &quot;knowledgeId为空&quot;)    private Long knowledgeId;    @Length(max = 100, min = 1, message = &quot;问题必须在1-100字符之间&quot;)    @NotBlank(groups = &#123;AddGroup.class&#125;, message = &quot;problemContent为空&quot;)    private String problemContent;    @Length(max = 500, min = 1, message = &quot;回答必须在1-500字符之间&quot;)    @NotBlank(groups = &#123;AddGroup.class&#125;, message = &quot;answer为空&quot;)    private String answer;&#125;</code></pre><pre><code>    @PostMapping(value = &quot;/addQuestionsAndAnswers&quot;)    public GbmResult addQuestionsAndAnswers(@RequestParam(&quot;img&quot;) MultipartFile[] img,                                            @RequestParam(&quot;vedio&quot;) MultipartFile[] vedio,                                            @Valid ZskQuestionsAndAnswersVo zskQuestionsAndAnswersVo) &#123;        ValidParameterUtils.validateEntity(zskQuestionsAndAnswersVo,AddGroup.class);    &#125;</code></pre><p>还需定义全局异常处理器</p><pre><code>@RestControllerAdvice@Order(100)public class GBMExceptionHandler &#123;    private Logger logger = LoggerFactory.getLogger(getClass());    //处理Get请求中 使用@Valid 验证路径中请求实体校验失败后抛出的异常    @ExceptionHandler(org.springframework.validation.BindException.class)    @ResponseBody    public GbmResult BindExceptionHandler(BindingResult e) &#123;        String message = e.getAllErrors().stream().map(DefaultMessageSourceResolvable::getDefaultMessage).collect(Collectors.joining());        return GbmResult.error(GbmResultCode.PARAMETER_EXCEPTION.getCode(),message);    &#125;</code></pre><h3 id="注解含义"><a href="#注解含义" class="headerlink" title="注解含义"></a>注解含义</h3><p>@Pattern(regexp = “1[3|4|5|7|8][0-9]\d{8}”,message = “手机号码格式不正确”)<br>    @NotEmpty(message =”returnAndExchangeInformation 不能为空”)<br>@NotNull(message =”knowledgeId 不能为空”)<br>    @Digits(integer = 10, fraction = 2, message = “补发运费格式错误”)<br>    @Length(max = 50, min = 1, message = “配件名称必须在1-50字符之间”)<br>@AssertFalse    该值必须为False<br>@AssertTrue    该值必须为True<br>@DecimalMax(value，inclusive)    被注释的元素必须是一个数字，其值必须小于等于指定的最大值 ，inclusive表示是否包含该值<br>@DecimalMin(value，inclusive)    被注释的元素必须是一个数字，其值必须大于等于指定的最小值 ，inclusive表示是否包含该值<br>@Digits    限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction<br>@Email    该值必须为邮箱格式<br>@Future    被注释的元素必须是一个将来的日期<br>@FutureOrPresent    被注释的元素必须是一个现在或将来的日期<br>@Max(value)    被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@Min(value)    被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@Negative    该值必须小于0<br>@NegativeOrZero    该值必须小于等于0<br>@NotBlank    该值不为空字符串，例如“ ”<br>@NotEmpty    该值不为空字符串<br>@NotNull    该值不为Null<br>@Null    该值必须为Null<br>@Past    被注释的元素必须是一个过去的日期<br>@PastOrPresent    被注释的元素必须是一个过去或现在的日期<br>@Pattern(regexp)    匹配正则<br>@Positive    该值必须大于0<br>@PositiveOrZero    该值必须大于等于0<br>@Size(min,max)    数组大小必须在[min,max]这个区间</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>手动实现一个自定义注解，做到灵活指定字符串字段只包含数字、字母、特殊符号、中文的校验</p><pre><code>import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.*;@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint(        validatedBy = &#123;ContainCharValidator.class&#125;)public @interface ContainChar &#123;    String message() default &quot;&quot;;    Class&lt;?&gt;[] groups() default &#123;&#125;;    //必须包含这个，否则报错    //javax.validation.ConstraintDefinitionException: HV000074: com.gbm.cloud.treasure.entity.zsk.ContainChar contains Constraint annotation, but does not contain a payload parameter.    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;    ContainCharEnum[] value() default &#123;ContainCharEnum.CHINESE, ContainCharEnum.NUMBER, ContainCharEnum.LETTER, ContainCharEnum.SYMBOL&#125;;&#125;</code></pre><pre><code>/** * @Des * @Author yinkai * @Date 2022/3/1 14:38 */public class ContainCharValidator implements ConstraintValidator&lt;ContainChar, String&gt; &#123;    private String message;    private ContainCharEnum[] values;    private Class&lt;?&gt;[] groups;    @Override    public void initialize(ContainChar constraintAnnotation) &#123;        this.message = constraintAnnotation.message();        this.values = constraintAnnotation.value();        this.groups = constraintAnnotation.groups();    &#125;    /**     * @Des 遍历，全都不包含才返回false     * @Author yinkai     * @Date 2022/3/1 13:49     */    public boolean isValid2(String value, ConstraintValidatorContext context) &#123;        for (ContainCharEnum containCharEnum : values) &#123;            switch (containCharEnum) &#123;                case CHINESE:                    if (!CHINESE.getPattern().matcher(value).find()) &#123;                        //禁止默认消息返回                        context.disableDefaultConstraintViolation();                        //自定义返回消息                        context.buildConstraintViolationWithTemplate(message+&quot;不包含&quot;+containCharEnum).addConstraintViolation();                        return false;                    &#125;                    break;                case NUMBER:                    if (!NUMBER.getPattern().matcher(value).find()) &#123;                        //禁止默认消息返回                        context.disableDefaultConstraintViolation();                        //自定义返回消息                        context.buildConstraintViolationWithTemplate(message+&quot;不包含&quot;+containCharEnum).addConstraintViolation();                        return false;                    &#125;                    break;                case SYMBOL:                    if (!SYMBOL.getPattern().matcher(value).find()) &#123;                        //禁止默认消息返回                        context.disableDefaultConstraintViolation();                        //自定义返回消息                        context.buildConstraintViolationWithTemplate(message+&quot;不包含&quot;+containCharEnum).addConstraintViolation();                        return false;                    &#125;                    break;                case LETTER:                    if (!LETTER.getPattern().matcher(value).find()) &#123;                        //禁止默认消息返回                        context.disableDefaultConstraintViolation();                        //自定义返回消息                        context.buildConstraintViolationWithTemplate(message+&quot;不包含&quot;+containCharEnum).addConstraintViolation();                        return false;                    &#125;                    break;                default:                    break;            &#125;        &#125;        return true;    &#125;    //遍历，全都不包含才返回false || 包含之外的就返回false    // !(包含一个 &amp;&amp; 只包含内部)    @Override    public boolean isValid(String value, ConstraintValidatorContext context) &#123;        HashSet&lt;Boolean&gt; booleans = new HashSet&lt;&gt;(2);        StringBuilder stringBuilder = new StringBuilder();        for (ContainCharEnum containCharEnum : values) &#123;            booleans.add(containCharEnum.getPattern().matcher(value).find());            stringBuilder.append(containCharEnum);        &#125;        //不包含true--&gt;全都是false--&gt;全都不包含        if (!booleans.contains(Boolean.TRUE)) &#123;            //禁止默认消息返回            context.disableDefaultConstraintViolation();            //自定义返回消息            context.buildConstraintViolationWithTemplate(message + value + &quot;不包含 &quot; + stringBuilder).addConstraintViolation();            return false;        &#125;        Set&lt;ContainCharEnum&gt; noFindSet = Arrays.stream(values()).filter(m -&gt; !ArrayUtil.contains(values, m)).collect(Collectors.toSet());        for (ContainCharEnum containCharEnum : noFindSet) &#123;            if (containCharEnum.getPattern().matcher(value).find()) &#123;                //禁止默认消息返回                context.disableDefaultConstraintViolation();                //自定义返回消息                context.buildConstraintViolationWithTemplate(message + value + &quot;不能包含 &quot; + containCharEnum).addConstraintViolation();                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><pre><code>public enum ContainCharEnum &#123;    CHINESE(0, &quot;中文&quot;,Pattern.compile(&quot;[\u4E00-\u9FA5|\\！|\\，|\\。|\\（|\\）|\\《|\\》|\\“|\\”|\\？|\\：|\\；|\\【|\\】]&quot;)),    NUMBER(1, &quot;数字&quot;, Pattern.compile(&quot;[0-9]&quot;)),    LETTER(2, &quot;字母&quot;,Pattern.compile(&quot;.*[a-zA-Z]+.*&quot;)),    SYMBOL(3, &quot;特殊符号&quot;,Pattern.compile(&quot;.*[`~!@#$%^&amp;*()+=|&#123;&#125;&#39;:;&#39;,\\[\\]·.&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。，、？\\\\]+.*&quot;));    @EnumValue//标记数据库存的值是code    private Integer code;    @JsonValue    private String desc;    private Pattern pattern;    ContainCharEnum(Integer code, String desc,Pattern pattern) &#123;        this.code = code;        this.desc = desc;        this.pattern = pattern;    &#125;    @Override    public String toString() &#123;        return desc;    &#125;    public int getValue() &#123;        return code;    &#125;    public Pattern getPattern() &#123;        return pattern;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java中continue-外层循环.md</title>
      <link href="/2022/03/20/java-zhong-continue-wai-ceng-xun-huan/"/>
      <url>/2022/03/20/java-zhong-continue-wai-ceng-xun-huan/</url>
      
        <content type="html"><![CDATA[<pre><code>     List&lt;Product&gt; allProducts = new ArrayList&lt;&gt;(treeSet);        List&lt;Product&gt; addProducts = new ArrayList&lt;&gt;();        a:for (Product product : allProducts) &#123;            for (Product existProduct : existProductList) &#123;                if (comparator.compare(existProduct,product)==0)&#123;                    product.setSpu(existProduct.getSpu());                    continue a;                &#125;            &#125;            product.setSpu(codeGenerator.getSpu(brandIdMap.get(product.getBrandNo()),catIdMap.get(product.getCatNo())));            product.setReplaceSendTag(supplierMap.get(product.getSupplierNo()).getReplaceSendTag());            product.setReplaceSendEmail(supplierMap.get(product.getSupplierNo()).getReplaceSendEmail());            product.setReplaceSendTimes(supplierMap.get(product.getSupplierNo()).getReplaceSendTimes());            product.setReplaceSendFrequency(supplierMap.get(product.getSupplierNo()).getReplaceSendFrequency());            product.setRemark(supplierMap.get(product.getSupplierNo()).getReplaceSendRemark());            product.setTermsNoArray(String.join(&quot;,&quot;, terms.stream().map(AfterSaleTermsDto::getTermsNo).collect(Collectors.toList())));            addProducts.add(product);        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中-long可以自动转型为float。即使float4字节，long8字节.md</title>
      <link href="/2022/03/20/java-zhong-long-ke-yi-zi-dong-zhuan-xing-wei-float-ji-shi-float4-zi-jie-long8-zi-jie/"/>
      <url>/2022/03/20/java-zhong-long-ke-yi-zi-dong-zhuan-xing-wei-float-ji-shi-float4-zi-jie-long8-zi-jie/</url>
      
        <content type="html"><![CDATA[<pre><code>        long zz = 1111111111111111111L;        double d = zz;        float f = zz;        //false        System.out.println(Double.valueOf(d).equals(f));</code></pre><p>首先范围上讲float范围要大，另外，float精度要低，用的是幂指数方式表示数值，小数精度为7位。long表示更精确一些，没有估计数值。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中pojo对象首字母大写导致无法赋值问题.md</title>
      <link href="/2022/03/20/java-zhong-pojo-dui-xiang-shou-zi-mu-da-xie-dao-zhi-wu-fa-fu-zhi-wen-ti/"/>
      <url>/2022/03/20/java-zhong-pojo-dui-xiang-shou-zi-mu-da-xie-dao-zhi-wu-fa-fu-zhi-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>命名规范(文末附有java命名规范)中指出，属性变量命名应采用<strong>驼峰命名</strong>的方式，即首字母小写，其他单词首字母大写；<br>但有时候我们对接<strong>三方的接口</strong>时，想要封装实体类来接受，但是发现接收到的参数的变量首字母是大写的或者其他，<br><strong>并没有遵循驼峰命名的规范</strong>，这个时候出现的问题就是，用我们封装的对象接收数据时，发现<strong>参数并没有赋上值</strong>。</p><p>脑袋大，那么<strong>不符合命名规范的变量</strong>怎么赋值呢。</p><h4 id="符合java命名规范的驼峰命名，首字母小写"><a href="#符合java命名规范的驼峰命名，首字母小写" class="headerlink" title="符合java命名规范的驼峰命名，首字母小写"></a>符合java命名规范的驼峰命名，首字母小写</h4><pre><code> /** * 符合java命名规范的驼峰命名，首字母小写 */private Integer id; public Integer getId() &#123;           return id;&#125; public void setId(Integer id) &#123;      this.id = id;&#125;</code></pre><h4 id="不符合命名规范的大致分为以下几种情况："><a href="#不符合命名规范的大致分为以下几种情况：" class="headerlink" title="不符合命名规范的大致分为以下几种情况："></a>不符合命名规范的大致分为以下几种情况：</h4><p>1、首字母大写；<br>2、 第二个字母大写；<br>3、 第一、二个字母大写；<br>4、所有字母都大写</p><p>下面是具体每种情况的赋值方式（注意红色标注）</p><p>####首字母大写</p><pre><code>/** * 首字母大写 */    private String UserName;      public String getUserName() &#123;         return UserName;    &#125; public void setUserName(String userName) &#123;        UserName = userName;    &#125;</code></pre><h4 id="第二个字母大写"><a href="#第二个字母大写" class="headerlink" title="第二个字母大写"></a>第二个字母大写</h4><pre><code>    private String pAssword; public String getpAssword() &#123; return pAssword;    &#125; public void setpAssword(String pAssword) &#123; this.pAssword = pAssword;    &#125;</code></pre><h4 id="第一、二个字母都大写"><a href="#第一、二个字母都大写" class="headerlink" title="第一、二个字母都大写"></a>第一、二个字母都大写</h4><pre><code>/** * 第一、二个字母都大写 */    private String GEnder; public String getGEnder() &#123; return GEnder;    &#125; public void setGEnder(String GEnder) &#123; this.GEnder = GEnder;    &#125;</code></pre><h4 id="所有字母都大写"><a href="#所有字母都大写" class="headerlink" title="所有字母都大写"></a>所有字母都大写</h4><pre><code> /** * 所有字母都大写     * @return     */    private String URL; public String getURL() &#123; return URL;    &#125; public void setURL(String URL) &#123; this.URL = URL;    &#125;</code></pre><h3 id="java命名规范："><a href="#java命名规范：" class="headerlink" title="java命名规范："></a><strong>java命名规范：</strong></h3><p>1、 项目名全部小写</p><p>2、 包名全部小写</p><p>3、 类名首字母大写，如果类名由多个单词组成，每个单词的首字母都要大写。<br>　　如：public class MyFirstClass{}<br>4、 变量名、方法名首字母小写，如果名称由多个单词组成，每个单词的首字母都要大写。<br>　　如：int index=0;<br>      　　 public void toString(){}<br>5、 常量名全部大写<br>　　如：public static final String GAME_COLOR=”RED”;</p><p>6、所有命名规则必须遵循以下规则：<br>　　1)、名称只能由字母、数字、下划线、$符号组成<br>　　2)、不能以数字开头<br>　　3)、名称不能使用JAVA中的关键字。<br>　　4)、坚决不允许出现中文及拼音命名。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基本数据类型.md</title>
      <link href="/2022/03/20/java-ji-ben-shu-ju-lei-xing/"/>
      <url>/2022/03/20/java-ji-ben-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？<br>Java 中有 8 种基本数据类型，分别为：</p><p>6 种数字类型 ：byte、short、int、long、float、double<br>1 种字符类型：char<br>1 种布尔型：boolean。<br>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p>基本类型    位数    字节    默认值<br>int    32       4    0<br>short    16    2    0<br>long    64    8    0L<br>byte    8    1    0<br>char    16    2    ‘u0000’<br>float    32    4    0f<br>double    64    8    0d<br>boolean    1        false</p><p>另外，对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><p>注意：</p><p>1、ava 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。<br>2、char a = ‘h’char :单引号，String a = “hello” :双引号。</p><p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。</p><p>包装类型不赋值就是 Null ，而基本类型有默认值且不是 Null。</p><p>另外，这个问题建议还可以先从 JVM 层面来分析。</p><p>基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p><p>《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型<strong>（boolean、byte、char、short、int、float、long、double）</strong>、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础之-基本类型值与包装类对象null的比较会导致空指针.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-ji-ben-lei-xing-zhi-yu-bao-zhuang-lei-dui-xiang-null-de-bi-jiao-hui-dao-zhi-kong-zhi-zhen/"/>
      <url>/2022/03/20/java-ji-chu-zhi-ji-ben-lei-xing-zhi-yu-bao-zhuang-lei-dui-xiang-null-de-bi-jiao-hui-dao-zhi-kong-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p>int  a=1；<br>if(a==null){<br>}</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java能存多大的整数？.md</title>
      <link href="/2022/03/20/java-neng-cun-duo-da-de-zheng-shu/"/>
      <url>/2022/03/20/java-neng-cun-duo-da-de-zheng-shu/</url>
      
        <content type="html"><![CDATA[<p>无限，内存有多大，他就能存多大的数。<br>使用BigInteger </p><pre><code>    BigInteger bigInteger = new BigInteger(&quot;9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999&quot;);        System.out.println(bigInteger);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java小技巧2，使用枚举而不是if-else或者Switch来做数据字典兑换.md</title>
      <link href="/2022/03/20/java-xiao-ji-qiao-2-shi-yong-mei-ju-er-bu-shi-if-else-huo-zhe-switch-lai-zuo-shu-ju-zi-dian-dui-huan/"/>
      <url>/2022/03/20/java-xiao-ji-qiao-2-shi-yong-mei-ju-er-bu-shi-if-else-huo-zhe-switch-lai-zuo-shu-ju-zi-dian-dui-huan/</url>
      
        <content type="html"><![CDATA[<p>定义枚举</p><pre><code>package com.gbm.cloud.treasure.enums;/** * @Author: hjh * @Date: 2021/7/7 17:54 * @Description: 商品状态枚举 */public enum MgbGoodsStateEnum &#123;//    ALL(0,&quot;全部&quot;),    UP(1,&quot;已上架&quot;),    DOWN(2,&quot;已下架&quot;),    ;    private Integer index;    private String msg;    MgbGoodsStateEnum(int index, String msg) &#123;        this.index = index;        this.msg = msg;    &#125;    public Integer getIndex() &#123;        return index;    &#125;    public void setIndex(Integer code) &#123;        this.index = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public static String getMsgByIndex(int index) &#123;        for (MgbGoodsStateEnum mgbGoodsStateEnum : values()) &#123;            if (mgbGoodsStateEnum.getIndex().equals(index)) &#123;                return mgbGoodsStateEnum.getMsg();            &#125;        &#125;        return null;    &#125;&#125;</code></pre><p>使用            vo.setStateName(MgbGoodsStateEnum.getMsgByIndex(vo.getState()));</p><pre><code>        List&lt;MgbGoodsVo&gt; records = mgbGoodsVoPage.getRecords();        for (MgbGoodsVo vo:records) &#123;            //获取品类名称            //一级            vo.setCatRootName(productCategoryMap.get(vo.getCatRootNo()));            //二级            vo.setCatParentName(productCategoryMap.get(vo.getCatParentNo()));            //三级            vo.setCatChildName(productCategoryMap.get(vo.getCatChildNo()));            //上架渠道            vo.setChannelName(channelMap.get(vo.getChannelKey()));            //销量            //商品状态            vo.setStateName(MgbGoodsStateEnum.getMsgByIndex(vo.getState()));            //获取0扣点采集价和代发价//            getZeroPointsPrice(vo);        &#125;</code></pre><blockquote><p>注意，这样使用枚举一定要从0开始。ordinal总是从0开始匹配的！从1开始的话会导致错开一位</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合之-NavigableMap导航Map接口.md</title>
      <link href="/2022/03/20/java-ji-he-zhi-navigablemap-dao-hang-map-jie-kou/"/>
      <url>/2022/03/20/java-ji-he-zhi-navigablemap-dao-hang-map-jie-kou/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/cgsyck/article/details/108462189">https://blog.csdn.net/cgsyck/article/details/108462189</a></p><p>###一、返回key<br>####1、根据指定key大小返回符合要求的key<br>higherKey 返回最接近的大于指定key的key</p><pre><code>        NavigableMap&lt;Integer,Integer&gt; original = new TreeMap&lt;Integer,Integer&gt;();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        Integer ceilingKey = original.higherKey(2);        System.out.println(ceilingKey);//3</code></pre><p>lowerKey 返回最接近的小于指定key的key</p><pre><code>        NavigableMap&lt;Integer,Integer&gt; original = new TreeMap&lt;Integer,Integer&gt;();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        Integer ceilingKey = original.lowerKey(2);        System.out.println(ceilingKey);//1</code></pre><p>ceilingKey 返回最接近的大于等于指定key的key</p><pre><code>        NavigableMap&lt;Integer,Integer&gt; original = new TreeMap&lt;Integer,Integer&gt;();        original.put(1, 1);        original.put(3, 3);        original.put(4, 4);        System.out.println(original.ceilingKey(2));//3        System.out.println(original.ceilingKey(3));//3</code></pre><p>floorKey返回最接近的小于等于指定key的key</p><pre><code>        NavigableMap&lt;Integer,Integer&gt; original = new TreeMap&lt;Integer,Integer&gt;();        original.put(1, 1);        original.put(3, 3);        original.put(4, 4);        System.out.println(original.floorKey(2));//1        System.out.println(original.floorKey(3));//3</code></pre><p>####2、返回倒序的key集合<br>descendingKeySet 返回key倒序NavigableSet</p><pre><code>        NavigableMap original = new TreeMap();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        original.put(4, 4);        original.put(5, 5);        //[5, 4, 3, 2, 1] 返回key倒序排列的key集合NavigableSet        System.out.println(original.descendingKeySet());</code></pre><p>###3、返回第一个key<br>firstKey</p><pre><code>        NavigableMap original = new TreeMap();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        //1 获取第一个key        System.out.println(original.firstKey());</code></pre><p>###4、返回第一个key、最后一个key<br>firstKey、lastKey</p><pre><code>    NavigableMap original = new TreeMap();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        //1 获取第一个key        System.out.println(original.firstKey());        //3 获取最后一个key        System.out.println(original.lastKey());</code></pre><p>###二、返回Map<br>####1、根据key大小返回符合要求的Map视图</p><p>1、tailMap 返回大于（可选择是否包含等于）指定key的Map视图</p><pre><code>        NavigableMap original = new TreeMap();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        SortedMap headmap1 = original.tailMap(1);        //&#123;1=1, 2=2, 3=3&#125; 默认true包含等于        System.out.println(headmap1);        //&#123;1=1, 2=2, 3=3&#125; fasle不包含        NavigableMap headmap2 = original.tailMap(1, false);        System.out.println(headmap2);</code></pre><p>2、headMap 返回小于（可选择是否包含等于）指定key的Map视图</p><pre><code>        NavigableMap original = new TreeMap();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        SortedMap headmap1 = original.headMap(3);        // &#123;1=1, 2=2&#125; 默认false，不包含等于        System.out.println(headmap1);        //&#123;1=1, 2=2, 3=3&#125; true包含等于        NavigableMap headmap2 = original.headMap(3, true);        System.out.println(headmap2);</code></pre><blockquote><p>注意tailMap 、headMap  的inclusive默认值是不同的；tailMap默认true包含等于，headMap默认false，不包含等于。</p></blockquote><p>####2、返回符合指定范围key大小的Map视图<br>subMap</p><pre><code>        NavigableMap original = new TreeMap();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        original.put(4, 4);        original.put(5, 5);        //&#123;2=2, 3=3&#125; 默认fromInclusive为true， toInclusive为 false；        System.out.println(original.subMap(2, 4));        //&#123;2=2, 3=3, 4=4&#125;        System.out.println(original.subMap(2, true, 4, true));</code></pre><p>####3、返回key倒序排列的NavigableMap<br>descendingMap </p><pre><code>        NavigableMap original = new TreeMap();        original.put(1, 1);        original.put(2, 2);        original.put(3, 3);        original.put(4, 4);        original.put(5, 5);        //&#123;5=5, 4=4, 3=3, 2=2, 1=1&#125; 返回key倒序排列的NavigableMap        NavigableMap navigableMap = original.descendingMap();        //操作会互相影响        navigableMap.put(6,6);        //&#123;1=1, 2=2, 3=3, 4=4, 5=5, 6=6&#125;        System.out.println(original);        //操作会互相影响        original.put(7,7);        //&#123;7=7, 6=6, 5=5, 4=4, 3=3, 2=2, 1=1&#125;        System.out.println(navigableMap);</code></pre><blockquote><p>注意：仍然是同一个map，操作会互相影响。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合之数据结构特征.md</title>
      <link href="/2022/03/20/java-ji-he-zhi-shu-ju-jie-gou-te-zheng/"/>
      <url>/2022/03/20/java-ji-he-zhi-shu-ju-jie-gou-te-zheng/</url>
      
        <content type="html"><![CDATA[<p>###集合类型（后缀）<br>1、List<br>可重复、有序（按插入顺序排序）、支持随机访问get(index)<br>2、Set<br>不可重复、不支持随机访问<br>3、Map<br>key-value形式；key不可重复，value可重复。</p><p>###集合特征（前缀）<br>1、Hash<br>无序；<br>Hash的 containsKey、get、put 和 remove 的时间复杂度是O(1)，这些操作性能强于Tree O(log n)；</p><p>2、Linked<br>有序（按插入顺序排序）；<br>Linked进行remove、add操作效率高于Array;</p><p>3、Tree<br>排序（可自定义排序）、不可以指定集合初始容量; 代表：TreeMap、TreeSet；</p><p>4、Array<br>Array随机get(index)访问效率高于Linked</p><p>###性能比较<br><img src="https://upload-images.jianshu.io/upload_images/13965490-b784c2010561f016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合类之-有序set集合LinkedHashSet、TreeSet.md</title>
      <link href="/2022/03/20/java-ji-he-lei-zhi-you-xu-set-ji-he-linkedhashset-treeset/"/>
      <url>/2022/03/20/java-ji-he-lei-zhi-you-xu-set-ji-he-linkedhashset-treeset/</url>
      
        <content type="html"><![CDATA[<blockquote><p>set 特征是去重；list特征是有序。有没有既有序又去重的集合呢？还真有！</p></blockquote><p>###LinkedHashSet</p><blockquote><p>LinkedHashSet（有序）通过链表的形式保证有序；它的有序指的是<code>插入顺序</code>。</p></blockquote><p>顾名思义，LinkedHashSet包含了三个数据结构要素：Linked、Hash、Set。<br>set集合不可重复，没有get方法。Linked 保证插入顺序。</p><p>这样的话，LinkedHashSet 就是有序、不重复、初始化不可指定大小（初始大小只能是0）、不能使用get(index)进行随机访问。</p><p>###TreeMap、TreeSet<br>TreeSet（有序），可以使用比较器：Comparable（内部）与Comparator（外部），通过Collections.sort()进行排序；<br>内部比较器-对应类上面实现comparable的接口，重写compare的方法；<br> 例如：Collections.sort(set);<br>外部比较器–对应类上面，编写内部静态类-比较器，实现对应的comparator接口；<br> 例如：Collections.sort(set, new AscAgeComparator());</p><p> 注意：set集合中保存对象的时候，去重，要重写对象的hashcode()和equals()方法</p><blockquote><p>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 O(log n)，HashMap的时间复杂度是O(1)，可见没有排序需求的情况下HashMap的性能更好。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk1-8--Map的一些新方法新特性.md</title>
      <link href="/2022/03/20/jdk1-8-map-de-yi-xie-xin-fang-fa-xin-te-xing/"/>
      <url>/2022/03/20/jdk1-8-map-de-yi-xie-xin-fang-fa-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<p>前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 stream（）方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。</p><p>此外,Maps 支持各种新的和有用的方法来执行常见任务。</p><p>putIfAbsent 返回最新value，原value为空则覆盖新值</p><pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123;    map.putIfAbsent(i, &quot;val&quot; + i);&#125;</code></pre><p>forEach接受一个 consumer 来对 map 中的每个元素操作。</p><pre><code>map.forEach((id, val) -&gt; System.out.println(val));//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9</code></pre><p>此示例显示如何使用函数在 map 上计算代码：</p><pre><code>map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3);             // val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9);     // falsemap.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);map.containsKey(23);    // truemap.computeIfAbsent(3, num -&gt; &quot;bam&quot;);map.get(3);             // val33</code></pre><p>接下来展示如何在Map里删除一个键值全都匹配的项：</p><pre><code>map.remove(3, &quot;val3&quot;);map.get(3);             // val33map.remove(3, &quot;val33&quot;);map.get(3);             // null</code></pre><p>指定Default的value：</p><pre><code>map.getOrDefault(42, &quot;not found&quot;);  // not found</code></pre><p>对Map的元素做合并也变得很容易了：</p><pre><code>map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9);             // val9map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9);             // val9concat</code></pre><p>Merge 做的事情是如果键名不存在则插入，否则对原键对应的值做合并操作并重新插入到map中。Merge 和put 覆盖是不同的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk1-8新特性之--Comparator.md</title>
      <link href="/2022/03/20/jdk1-8-xin-te-xing-zhi-comparator/"/>
      <url>/2022/03/20/jdk1-8-xin-te-xing-zhi-comparator/</url>
      
        <content type="html"><![CDATA[<p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p><pre><code>Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);comparator.compare(p1, p2);             // &gt; 0comparator.reversed().compare(p1, p2);  // &lt; 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk1-8新特性之-interface-新增default，和static修饰的方法.md</title>
      <link href="/2022/03/20/jdk1-8-xin-te-xing-zhi-interface-xin-zeng-default-he-static-xiu-shi-de-fang-fa/"/>
      <url>/2022/03/20/jdk1-8-xin-te-xing-zhi-interface-xin-zeng-default-he-static-xiu-shi-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>新 interface 的方法可以用default 或 static修饰，这样就可以有方法体，实现类也不必重写此方法。一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。</p><ul><li>default修饰的方法，是普通实例方法，可以用this调用，可以被子类继承、重写。相当于是一个接口的默认实现，实现类即使不去实现default修饰的方法也不会报错。（这个特性可以让我们不用去写空实现）</li><li>static修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用Interface调用。</li></ul><p>我们来看一个实际的例子。</p><pre><code>public interface InterfaceNew &#123;    static void sm() &#123;        System.out.println(&quot;static sm&quot;);    &#125;    static void sm2() &#123;        System.out.println(&quot;static sm2&quot;);    &#125;    default void def() &#123;        System.out.println(&quot;default def&quot;);    &#125;    default void def2() &#123;        System.out.println(&quot;default def2&quot;);    &#125;    void f();&#125;class A implements InterfaceNew &#123;    /**     * def和def2不是必须要实现的     *///    @Override//    public void def() &#123;////    &#125;//    @Override//    public void def2() &#123;////    &#125;    /**     * f必须要实现     */    @Override    public void f() &#123;        System.out.println(&quot;A.f()&quot;);    &#125;    public static void main(String[] args) &#123;        InterfaceNew a = new A();        //调用 普通        a.f();        //调用 default        a.def();        a.def2();        //调用static        InterfaceNew.sm();        InterfaceNew.sm2();    &#125;&#125;</code></pre><pre><code>public interface InterfaceNew &#123;    static void sm() &#123;        System.out.println(&quot;interface提供的方式实现&quot;);    &#125;    static void sm2() &#123;        System.out.println(&quot;interface提供的方式实现&quot;);    &#125;    default void def() &#123;        System.out.println(&quot;interface default方法&quot;);    &#125;    default void def2() &#123;        System.out.println(&quot;interface default2方法&quot;);    &#125;    //须要实现类重写    void f();&#125;public interface InterfaceNew1 &#123;    default void def() &#123;        System.out.println(&quot;InterfaceNew1 default方法&quot;);    &#125;&#125;</code></pre><p>如果有一个类既实现了 InterfaceNew 接口又实现了 InterfaceNew1接口，它们都有def()，并且 InterfaceNew 接口和 InterfaceNew1接口没有继承关系的话，这时就必须重写def()。不然的话，编译的时候就会报错：<code>java: 类 A从类型 InterfaceNew 和 InterfaceNew1 中继承了def2() 的不相关默认值</code>。</p><pre><code>class A implements InterfaceNew,InterfaceNew1 &#123;    /**     * def和def2不是必须要实现的     *///    @Override//    public void def() &#123;////    &#125;//    @Override//    public void def2() &#123;////    &#125;    /**     * f必须要实现     */    @Override    public void f() &#123;        System.out.println(&quot;A.f()&quot;);    &#125;    public static void main(String[] args) &#123;        InterfaceNew a = new A();        //调用 普通        a.f();        //调用 default        a.def();        a.def2();        //调用static        InterfaceNew.sm();        InterfaceNew.sm2();    &#125;&#125;</code></pre><p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong><br>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”<br>其实它们还是有区别的</p><p>interface 和 class 的区别，好像是废话，主要有：</p><ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符<br>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</li></ul><p>开始我们也提到，interface 新增default，和static修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代abstract class。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而降之替换。</p><p>记住接口永远和类不一样。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk1-8新特性总结.md</title>
      <link href="/2022/03/20/jdk1-8-xin-te-xing-zong-jie/"/>
      <url>/2022/03/20/jdk1-8-xin-te-xing-zong-jie/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/new-features/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.md#localdatetime%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/new-features/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.md#localdatetime%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4</a></p><p>Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 java8 之前版本的老程序员，比如我。</p><p>为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；<code>java.util.HashMap</code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看<a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍</a>。</p><p>Interface &amp; functional Interface<br>Lambda<br>Stream<br>Optional<br>Date time-api<br>这些都是开发当中比较常用的特征。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一致使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk9-java-util-Optional-提供了else分支：-ifPresentOrElse.md</title>
      <link href="/2022/03/20/jdk9-java-util-optional-ti-gong-liao-else-fen-zhi-ifpresentorelse/"/>
      <url>/2022/03/20/jdk9-java-util-optional-ti-gong-liao-else-fen-zhi-ifpresentorelse/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda特性.md</title>
      <link href="/2022/03/20/lambda-te-xing/"/>
      <url>/2022/03/20/lambda-te-xing/</url>
      
        <content type="html"><![CDATA[<p>1、捕获调用方法的变量<br>这里有一条规则：lambda 表达式中捕获的变量必须实际上是最终变量 ( effectivelyfinal。)<br>实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。在这里，text 总是指示<br>同一个 String 对象，所以捕获这个变量是合法的。不过，i 的值会改变，因此不能捕获。</p><p>2、this</p><pre><code>public class ApplicationO&#123;public void init() &#123;ActionListener listener * event -&gt; &#123;System.out.println(this.toStringO); &#125;</code></pre><p>表达式 this.toStringO 会调用 Application 对象的 toString方法， 而不是 ActionListener 实<br>例的方法。在 lambda 表达式中， this 的使用并没有任何特殊之处。lambda 表达式的作用域嵌<br>套在 init 方法中，与出现在这个方法中的其他位置一样， lambda 表达式中 this 的含义并没有<br>变化。</p><p>3、变量作用域</p><p>lambda 表达式的体与嵌套块有相同的作用域；这里同样适用命名冲突和遮蔽的有关规则。在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream()-anyMatch-和stream()--noneMatch、allMatch.md</title>
      <link href="/2022/03/20/stream-anymatch-he-stream-nonematch-allmatch/"/>
      <url>/2022/03/20/stream-anymatch-he-stream-nonematch-allmatch/</url>
      
        <content type="html"><![CDATA[<p>anyMatch 对应Predicate方法， 返回布尔值</p><p>anyMatch 与fitter类似。fitter过滤，anyMatch 匹配；<br>如果不使用anyMatch ，那么只能写 一个for循环加一个if。<br>这样几乎既可以消除for循环了</p><pre><code>        Student stu1 = new Student(01, 19, &quot;张三&quot;);        Student stu2 = new Student(02, 23, &quot;李四&quot;);        Student stu3 = new Student(01, 28, &quot;王五&quot;);        List&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(stu1);        list.add(stu2);        list.add(stu3);        boolean isOk=false;        // 判断学生年龄是否有大于27岁的        for (Student student : list) &#123;            Integer age = student.getAge();            if(age&gt;27)&#123;                isOk = true;                break;            &#125;        &#125;</code></pre><blockquote><p>在一个集合里判断里面的元素是否达成某个条件</p></blockquote><pre><code>  @Data    @AllArgsConstructor    static    class Student&#123;        private Integer id;        private Integer age;        private String name;    &#125;    public static void main(String[] args) &#123;        Student stu1 = new Student(01, 19, &quot;张三&quot;);        Student stu2 = new Student(02, 23, &quot;李四&quot;);        Student stu3 = new Student(01, 28, &quot;王五&quot;);        List&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(stu1);        list.add(stu2);        list.add(stu3);        // 判断学生年龄是否有大于27岁的        boolean anyMatchFlag = list.stream().anyMatch(student -&gt; student.getAge() &gt; 27);        System.out.println(anyMatchFlag);    &#125;</code></pre><p>用的好的：</p><pre><code>    request.getFieldValues().stream()      .map(oneFieldValues -&gt; readOneFieldValues(oneFieldValues, request.getKey()))      .peek(map -&gt; checkRequest(map.values().stream().anyMatch(StringUtils::isNotBlank), MSG_NO_EMPTY_VALUE))      .flatMap(map -&gt; map.entrySet().stream())      .peek(entry -&gt; valuesByFieldKeys.put(entry.getKey(), entry.getValue()))      .forEach(entry -&gt; checkRequest(fieldKeys.contains(entry.getKey()), &quot;Unknown field key &#39;%s&#39; for setting &#39;%s&#39;&quot;, entry.getKey(), request.getKey()));</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list-=-new-ObjectMapper()-convertValue(list,-new-TypeReference-List-Jg.md</title>
      <link href="/2022/03/20/list-new-objectmapper-convertvalue-list-new-typereference-list-jg/"/>
      <url>/2022/03/20/list-new-objectmapper-convertvalue-list-new-typereference-list-jg/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream()-flatMap用法和stream()-map的区别.md</title>
      <link href="/2022/03/20/stream-flatmap-yong-fa-he-stream-map-de-qu-bie/"/>
      <url>/2022/03/20/stream-flatmap-yong-fa-he-stream-map-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>flatMap在流里面还有流时使用</p></blockquote><ul><li>flatMap可以扁平化流，把流给压扁</li><li>flatMap的参数只能是流对象</li><li>flatMap相当于把操作流的主题从第一个转为（第二个）第一个对象的属性流<br>~~~<pre><code>  HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();  List&lt;String&gt; strings1 = new ArrayList&lt;&gt;();  strings1.add(&quot;A&quot;);  strings1.add(&quot;B&quot;);  strings1.add(&quot;C&quot;);</code></pre></li></ul><pre><code>    List&lt;String&gt; strings2 = new ArrayList&lt;&gt;();    strings2.add(&quot;e&quot;);    strings2.add(&quot;f&quot;);    strings2.add(&quot;g&quot;);    List&lt;String&gt; strings3 = new ArrayList&lt;&gt;();    strings3.add(&quot;b&quot;);    strings3.add(&quot;n&quot;);    strings3.add(&quot;m&quot;);    map.put(&quot;1&quot;,strings1);    map.put(&quot;2&quot;,strings2);    map.put(&quot;3&quot;,strings3);    List&lt;String&gt; collect = map.values().stream().flatMap(Collection::stream).collect(Collectors.toList());    System.out.println(collect);</code></pre><pre><code>&gt;[A, B, C, e, f, g, b, n, m]- map.values()是Collection， flatmap() 参数 传入Collection::stream，- flatmap 收集 HashMap&lt;String, List&lt;String&gt;&gt;的value中的所有List元素，单独组成一个List###List&lt;List&gt; 的扁平化</code></pre><pre><code>    List&lt;List&lt;String&gt;&gt; strings = new ArrayList&lt;&gt;();    List&lt;String&gt; strings1 = new ArrayList&lt;&gt;();    strings1.add(&quot;A&quot;);    strings1.add(&quot;B&quot;);    strings1.add(&quot;C&quot;);    strings.add(strings1);    List&lt;String&gt; strings2 = new ArrayList&lt;&gt;();    strings2.add(&quot;e&quot;);    strings2.add(&quot;f&quot;);    strings2.add(&quot;g&quot;);    strings.add(strings2);    List&lt;String&gt; strings3 = new ArrayList&lt;&gt;();    strings3.add(&quot;b&quot;);    strings3.add(&quot;n&quot;);    strings3.add(&quot;m&quot;);    strings.add(strings3);    List&lt;String&gt; collect = strings.stream().flatMap(List::stream).collect(Collectors.toList());    System.out.println(collect);</code></pre><pre><code>&gt;[A, B, C, e, f, g, b, n, m]写到好的例子：将类集合interfaces、Method 传入。遍历interfaces，匹配类的getMethods（方法数组）的方法名、参数列表。匹配到了，取第一个方法数组中的方法，add到methods （List) 中</code></pre><pre><code>public static void main(String[] args) &#123;    Class&lt;? extends ImgbUndertakesOrderListener&gt; aClass = ImgbUndertakesOrderListener.class;    ArrayList&lt;Class&gt; list = new ArrayList&lt;&gt;();    list.add(aClass);    Method method = Arrays.stream(aClass.getMethods()).findFirst().orElse(null);    getMethodAndInterfaceDeclarations(method,list);&#125;static Collection&lt;Method&gt; getMethodAndInterfaceDeclarations(Method method, Collection&lt;Class&gt; interfaces) &#123;    final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();    methods.add(method);    // we search for matching method by iteration and comparison vs getMethod to avoid repeated NoSuchMethodException    // being thrown, while interface typically only define a few set of methods to check.    interfaces.stream()            .map(Class::getMethods)            .flatMap(Arrays::stream)            .filter(m -&gt; m.getName().equals(method.getName()) &amp;&amp; Arrays.equals(m.getParameterTypes(), method.getParameterTypes()))            .findFirst()            .ifPresent(methods::add);    return methods;&#125;</code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream()-peek的用法和-与-stream()-map区别.md</title>
      <link href="/2022/03/20/stream-peek-de-yong-fa-he-yu-stream-map-qu-bie/"/>
      <url>/2022/03/20/stream-peek-de-yong-fa-he-yu-stream-map-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>peek对应Consumer   没返回值，map对应Function  有返回值</p><pre><code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;).peek(u -&gt; u.toUpperCase())                .forEach(e -&gt; System.out.print(e+&quot;\t&quot;));        Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;).map(u -&gt; u.toUpperCase())                .forEach(e -&gt; System.out.print(e+&quot;\t&quot;));</code></pre><blockquote><p>one    two    three    four    ONE    TWO    THREE    FOUR    </p></blockquote><p>可以发现peek不会对流有所改变，而map却是更改了流</p><p>再看下面代码</p><pre><code>    List&lt;Integer&gt; list1 = Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;).map(String::hashCode).collect(Collectors.toList());   List&lt;String&gt; list2 = Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;).peek(String::hashCode).collect(Collectors.toList());</code></pre><blockquote><p>map对流有修改，生成的List泛型是Integer，而peek还是String</p></blockquote><p>因此，peek适合做一些中间操作。比如打印日志。将值set到其他对象。但是对m参数进行set也是能影响流的结果</p><pre><code>    @Data    @AllArgsConstructor    private static class ff &#123;        private Integer id;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        List&lt;ff&gt; tempList = new ArrayList&lt;&gt;();        List&lt;ff&gt; list2 = Stream.of( new ff(1),  new ff(2),  new ff(3),  new ff(4)).peek(m -&gt; &#123;            Integer id = m.getId();            m.setId(++id);            tempList.add(m);        &#125;).collect(Collectors.toList());        System.out.println(list2);        System.out.println(tempList);    &#125;&#125;</code></pre><p>下面的反例，这样用map是错误的。可以直接使用peek.这样就不用return了！</p><blockquote><p>.map(indexName -&gt; { LOG.debug(“Marking index {} to be reopened using alias.”, indexName); return indexName; })</p></blockquote><pre><code>  public void upgrade() &#123;        this.indexSetService.findAll()            .stream()            .map(mongoIndexSetFactory::create)            .flatMap(indexSet -&gt; getReopenedIndices(indexSet).stream())            .map(indexName -&gt; &#123; LOG.debug(&quot;Marking index &#123;&#125; to be reopened using alias.&quot;, indexName); return indexName; &#125;)            .forEach(indices::markIndexReopened);    &#125;</code></pre><p>例子2</p><pre><code>    @AllArgsConstructor    @Data    private static class Student&#123;        private Integer id;        private Integer age;        private String name;    &#125;    public static void main(String[] args) &#123;        HashMap&lt;String, Integer&gt; stringStringHashMap = new HashMap&lt;&gt;();        stringStringHashMap.put(&quot;张三&quot;, 100);        Student stu1 = new Student(1, 19, &quot;张三&quot;);        Student stu2 = new Student(2, 23, &quot;李四&quot;);        Student stu3 = new Student(3, 28, &quot;王五&quot;);        List&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(stu1);        list.add(stu2);        list.add(stu3);        List&lt;Student&gt; collect = list.stream().filter(student-&gt;ToolUtil.isNotEmpty(stringStringHashMap.get(student.getName()))).peek(student -&gt; &#123;            Integer num = stringStringHashMap.get(student.getName());            student.setAge(num);        &#125;).collect(Collectors.toList());        System.out.println(collect);    &#125;</code></pre><p>###peek、foreach区别<br>peek不会中断流，后面可以对流继续操作，foreach会中断流，只能进行遍历</p><pre><code>void forEach(Consumer&lt;? super T&gt; action);Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream-集合操作提升.md</title>
      <link href="/2022/03/20/stream-ji-he-cao-zuo-ti-sheng/"/>
      <url>/2022/03/20/stream-ji-he-cao-zuo-ti-sheng/</url>
      
        <content type="html"><![CDATA[<p>###对比二者 list转map<br>1、两个都是list转map</p><p>第一个Collectors.toMap有去重含义</p><pre><code> Map&lt;Integer, JgOrderStateMate&gt; mateMap = mateList.stream().collect(Collectors.toMap(JgOrderStateMate::getOrderState, m -&gt; m, (v1, v2) -&gt; v2));</code></pre><p>第二个Collectors.groupingBy有分组含义</p><pre><code>  Map&lt;String, List&lt;CertInfoPO&gt;&gt; collect = certSet.stream().collect(Collectors.groupingBy(CertInfoPO::getIdentityNumber));</code></pre><p>2、Collectors.groupingBy 和mysql的 groupby的区别<br>mysql的 groupby无法直接得到Map&lt;String, List<CertInfoPO>&gt; 这种形式</p><p>3、案例：逗号分割字符串转Map</p><pre><code> List&lt;String&gt; strings = Arrays.asList(&quot;aaaa,bbbb,cccc&quot;, &quot;ddddd,eeeee&quot;);        Map&lt;String, List&lt;String&gt;&gt; collect = strings.stream().collect(Collectors.toMap(key -&gt; key, key -&gt; Arrays.asList(key.split(&quot;,&quot;)), (v1, v2) -&gt; v1));        System.out.println(collect);</code></pre><p>4、转TreeMap</p><pre><code> TreeMap&lt;Long, String&gt; treeMap = new TreeMap&lt;&gt;();     TreeMap&lt;Long, String&gt; map = treeMap.entrySet().stream()                                                    .collect(Collectors.toMap(entry -&gt; entry.getKey(), entry -&gt; entry.getValue(), (oldValue, newValue) -&gt; newValue, TreeMap::new));</code></pre><p>5、转hutu的 TableMap</p><pre><code>            TableMap&lt;String[], String&gt; collect = commodityRegion.stream().collect(Collectors.toMap(entry -&gt; StringUtils.split(entry.getCommoditySku(), Constant.COMMA), m -&gt; new StringBuilder(m.getProvinceName()).append(m.getCityName()).append(m.getAreaName()).toString(), (v1, v2) -&gt; v2, new Supplier&lt;TableMap&lt;String[], String&gt;&gt;() &#123;                @Override                public TableMap&lt;String[], String&gt; get() &#123;                    return new TableMap(commodityRegion.size());                &#125;            &#125;));</code></pre><p>6、 t -&gt; t =&gt; Function.identity()</p><p>7、转List</p><pre><code>     // Accumulate names into a List     List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());</code></pre><p>8、转TreeSet</p><pre><code>     // Accumulate names into a TreeSet     Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));</code></pre><p>9、集合字符串拼接 join</p><pre><code>     // Convert elements to strings and concatenate them, separated by commas     String joined = things.stream()                           .map(Object::toString)                           .collect(Collectors.joining(&quot;, &quot;));</code></pre><p>10、sum </p><pre><code>     // Compute sum of salaries of employee     int total = employees.stream()                          .collect(Collectors.summingInt(Employee::getSalary)));</code></pre><p>11、分组</p><pre><code>// Group employees by department     Map&lt;Department, List&lt;Employee&gt;&gt; byDept         = employees.stream()                    .collect(Collectors.groupingBy(Employee::getDepartment));</code></pre><p>12、分组统计</p><pre><code>// Compute sum of salaries by department     Map&lt;Department, Integer&gt; totalByDept         = employees.stream()                    .collect(Collectors.groupingBy(Employee::getDepartment,                                                   Collectors.summingInt(Employee::getSalary)));</code></pre><p>13、分两组</p><pre><code>     // Partition students into passing and failing     Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing =         students.stream()                 .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</code></pre><p>14、得到数组</p><pre><code>        //用法1，得到Object数组        Object[] objects = Stream.generate(ThreadLocalRandom.current()::nextLong)            .skip(900).limit(1000).toArray();        System.out.println(objects);        //用法2,指定数组类型        Long[] integers = new Long[1000];        Stream.generate(ThreadLocalRandom.current()::nextLong)            .skip(900).limit(1000).toArray(value -&gt;integers);        System.out.println(integers);</code></pre><p>15、Stream.generate 快捷生成数据列表<br>这里是使用ThreadLocalRandom随机整形生成数据</p><pre><code>    public static void main(String[] args) &#123;        List&lt;Integer&gt; collect = Stream.generate(Main::getAnInt)            .limit(1000)            .collect(Collectors.toList());        //[) 前闭后开        System.out.println(collect);    &#125;    private static int getAnInt() &#123;        // 1~10        return ThreadLocalRandom.current().nextInt(1,11);    &#125;</code></pre><p>16、Stream.generate 可以构造自己的对象列表</p><pre><code>    public static void main(String[] args) &#123;        List&lt;User&gt; collect = Stream.generate(Main::getNewUser)            .limit(1000)            .collect(Collectors.toList());        //[) 前闭后开        System.out.println(collect);    &#125;    private static User getNewUser() &#123;        return new User(StrUtil.genGetter(RandomUtil.randomString( 10)),ThreadLocalRandom.current().nextInt(0,101));    &#125;</code></pre><p>17、mapping和map现在来看是差不多的</p><pre><code>        List&lt;String[]&gt; collect = Stream.of(&quot;name,111:age,20&quot;, &quot;name,222:age,21&quot;).collect(mapping(m -&gt; m.split(&quot;,&quot;), Collectors.toList()));        System.out.println(collect);        List&lt;String[]&gt; collect1 = Stream.of(&quot;name,111:age,20&quot;, &quot;name,222:age,21&quot;).map(m -&gt; m.split(&quot;,&quot;)).collect(Collectors.toList());        System.out.println(collect1);;</code></pre><p>用string list 构造 实体 list</p><pre><code> List&lt;JgWarehouseOrder&gt; collect = updateMap.keySet().stream().collect(mapping(m -&gt; getOrder(m), toList()));    private static JgWarehouseOrder getOrder(String platformOrderNo) &#123;        return  new JgWarehouseOrder().setPlatformOrderNo(platformOrderNo);    &#125;</code></pre><p>18、reduce 归约合并</p><p>//两两合并<br>Optional<T> reduce(BinaryOperator<T> accumulator)<br>//两两合并，带初始值的<br>T reduce(T identity, BinaryOperator<T> accumulator)<br>//先转化元素类型再两两合并，带初始值的<br><U> U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator<U> combiner)</p><p>示例</p><pre><code>List&lt;Integer&gt; demo = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);//数字转化为字符串，然后使用“-”拼接起来String data = demo.stream().reduce(&quot;0&quot;, (u, t) -&gt; u + &quot;-&quot; + t, (s1, s2) -&gt; s1 + &quot;-&quot; + s2);System.out.println(data);</code></pre><p>——-result——–<br>0-1-2-3-4-5-6-7-8</p><p>19、flatMap扁平化的应用：分割多个地址集合成，单个地址集合</p><pre><code>        //按地区        Set&lt;JgRulaEmbargo&gt; towSet = setMap.get(Constant.NUMBER_ONE);        if (ToolUtil.isNotEmpty(towSet)) &#123;            //将多个地址分割            Set&lt;String&gt; addressSet = towSet.stream().filter(m -&gt; ToolUtil.isNotEmptyAll(m.getDetailedAddress()))                    .flatMap(m -&gt; Arrays.stream(org.apache.commons.lang.StringUtils.split(m.getDetailedAddress(), Constant.SEMICOLON))).collect(toSet());            region.addAll(addressSet);        &#125;</code></pre><p>20、一个List转另一个List</p><pre><code>    List&lt;ZskAccessoriesListDtoError&gt; errorList = dataMap.values().stream()                .filter(ToolUtil::isNotEmpty)                .filter(m -&gt; ToolUtil.isNotEmpty(m.getErrMsg())).collect(Collectors.mapping(e -&gt; ZskAccessoriesListDtoError.builder().errMsg(e.getErrMsg())                        .accessoryName(e.getAccessoryName())                        .spu(e.getSpu())                        .price(e.getPrice())                        .reissuedFreight(e.getReissuedFreight())                        .specifications(e.getSpecifications())                        .specifications(e.getDefectsLiabilityPeriod()).build(), Collectors.toList()));</code></pre><p>21、分组排序<br>对组内元素再进行排序。<br>一时想不到什么一步到位得好方法。</p><p>1、先排序后分组可以实现一样得效果。<br>按分组字段1级排序，按排序字段2级排序即可</p><pre><code>       List&lt;MgbDictData&gt; list = ((MgbDictDataRepository) mgbDictDataService.getBaseMapper()).getGdDict();        DATAGROUPS = list.stream()                .sorted(Comparator.nullsFirst(Comparator.comparing(MgbDictData::getDictType)                .thenComparing(MgbDictData::getDictSort)                .thenComparing(MgbDictData::getDictValue)))                .collect(Collectors.groupingBy(MgbDictData::getDictType));</code></pre><p>22、groupingBy 和toMap同时使用，得到HashMap&lt;String, Map&lt;String, String&gt;&gt;</p><blockquote><p>List-&gt; List groupingBy -&gt; Map<List>–&gt;List toMap–&gt;Map<Map></p></blockquote><pre><code>        List&lt;MgbDictData&gt; list = ((MgbDictDataRepository) mgbDictDataService.getBaseMapper()).getGdDict();  HashMap&lt;String, Map&lt;String, String&gt;&gt; collect = list.stream()                .sorted(Comparator.nullsFirst(Comparator.comparing(MgbDictData::getDictType)                        .thenComparing(MgbDictData::getDictSort)                        .thenComparing(MgbDictData::getDictValue)))                .collect(Collectors.groupingBy(MgbDictData::getDictType, HashMap::new, Collectors.toMap(MgbDictData::getDictValue, MgbDictData::getDictLabel, (v1, v2) -&gt; v2)));</code></pre><p>再进一步：使用treeMap实现设置顺序</p><pre><code>  List&lt;MgbDictData&gt; list = ((MgbDictDataRepository) mgbDictDataService.getBaseMapper()).getGdDict();        DATAGROUPS = list.stream()                .collect(Collectors.groupingBy(MgbDictData::getDictType, HashMap::new, Collectors.toMap(MgbDictData::getDictValue, MgbDictData::getDictLabel, (v1, v2) -&gt; v2,                        () -&gt; new TreeMap&lt;&gt;(Comparator.comparingInt(value -&gt; &#123;                            if (NumberUtil.isNumber(value)) &#123;                                return Integer.valueOf(value);                            &#125; else &#123;                                return 0;                            &#125;                        &#125;)))                ));</code></pre><p>23、其他的<br>1、Map&lt;String, DictTypeEnum&gt;转  Map&lt;Integer, List<DictTypeEnum>&gt;</p><pre><code> private static Map&lt;String, DictTypeEnum&gt; enumDataMap;        Map&lt;Integer, List&lt;DictTypeEnum&gt;&gt; collect = enumDataMap.entrySet().stream().map(Map.Entry::getValue).collect(Collectors.groupingBy(DictTypeEnum::getIndex));</code></pre><p>2、Map&lt;String, DictTypeEnum&gt; 转  Map&lt;Integer, Map&lt;String, DictTypeEnum&gt;&gt;</p><pre><code>      enumDataMapMap = enumMap.values().stream()                .filter(m -&gt; !ToolUtil.isAllEmpty(m.getParentDictType(), m.getIndex())).collect(Collectors.groupingBy(DictTypeEnum::getIndex, HashMap::new, Collectors.toMap(DictTypeEnum::getDictType, Function.identity(), (v1, v2) -&gt; v2)));</code></pre><p>3、Map&lt;String, List<MgbDictData>&gt;  转 Map&lt;String, Map&lt;String, MgbDictData&gt;&gt;  </p><pre><code>    private static Map&lt;String, Map&lt;String, MgbDictData&gt;&gt; dictTypeMap;   dictTypeMap = dataGroups.values().stream().flatMap(List::stream)                .collect(Collectors.groupingBy(MgbDictData::getDictType, HashMap::new, Collectors.toMap(MgbDictData::getDictValue, Function.identity(), (v1, v2) -&gt; v2)));</code></pre><p>4、Map&lt;String, List<MgbDictData>&gt;  转  Map&lt;String, MgbDictData&gt;</p><pre><code> private static Map&lt;String, List&lt;MgbDictData&gt;&gt; dataGroups;        uuidDictMap = dataGroups.values().stream().flatMap(List::stream).collect(Collectors.toMap(MgbDictData::getUuid, Function.identity(), (v1, v2) -&gt; v2));</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream操作对原集合的影响？.md</title>
      <link href="/2022/03/20/stream-cao-zuo-dui-yuan-ji-he-de-ying-xiang/"/>
      <url>/2022/03/20/stream-cao-zuo-dui-yuan-ji-he-de-ying-xiang/</url>
      
        <content type="html"><![CDATA[<p>1、arrayList内部复合类型<br>修改符合类型对象数据会影响原来的。毕竟是一个对象</p><pre><code>        ArrayList&lt;JgWarehouseOrder&gt; arrayList = new ArrayList();        JgWarehouseOrder order1 = new JgWarehouseOrder();        order1.setId(1L);        arrayList.add(order1);        List&lt;JgWarehouseOrder&gt; collect = arrayList.stream().map(e -&gt; e.setId(e.getId() + 1)).collect(toList());        //2        System.out.println(arrayList);        //2        System.out.println(collect);</code></pre><p>2、arrayList内部是Integer，不会修改到原来的</p><pre><code>       ArrayList&lt;Integer&gt; arrayList = new ArrayList();        arrayList.add(1);        List&lt;Integer&gt; collect = arrayList.stream().map(e -&gt; e + 1).collect(toList());        //1        System.out.println(arrayList);        //2        System.out.println(collect);</code></pre><p>3、arrayList内部是String，不会修改到原来的</p><pre><code>       ArrayList&lt;String&gt; arrayList = new ArrayList();        arrayList.add(&quot;1&quot;);        List&lt;String&gt; collect = arrayList.stream().map(e -&gt; e + &quot;xxx&quot;).collect(toList());        //1        System.out.println(arrayList);        //1xxx        System.out.println(collect);</code></pre><p>4、直接在循环里给原集合add元素是不安全的</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream其它的.md</title>
      <link href="/2022/03/20/stream-qi-ta-de/"/>
      <url>/2022/03/20/stream-qi-ta-de/</url>
      
        <content type="html"><![CDATA[<pre><code>         HashMap&lt;String, Integer&gt; stringStringHashMap = new HashMap&lt;&gt;();        stringStringHashMap.put(&quot;张三&quot;, 100);        Student stu1 = new Student(01, 19, &quot;张三&quot;,null);        Student stu2 = new Student(02, 23, &quot;李四&quot;,null);        Student stu3 = new Student(01, 28, &quot;王五&quot;,null);        List&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(stu1);        list.add(stu2);        list.add(stu3);        Student student = list.stream().findFirst().orElse(null);        Student student1 = list.stream().findAny().orElse(null);        list.stream().max((o1, o2) -&gt; 0);        list.stream().sorted((o1, o2) -&gt; 0);        list.stream().limit(0);        list.stream().skip(1);        list.stream().distinct();        list.stream().min((o1, o2) -&gt; 0);        list.stream().toArray();        list.stream().filter();        list.stream().count();        list.stream().min((o1, o2) -&gt; 0);            //总数据            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).average()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).boxed()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).sequential()                 int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).spliterator()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).summaryStatistics()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).isParallel()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).toArray()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).asDoubleStream()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).asLongStream()                                int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).mapToDouble()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).mapToLong()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).mapToObj()            int sum = orderList.stream().mapToInt(JgWarehouseOrder::getNum).allMatch()</code></pre><pre><code>    public static void main(String[] args) &#123;        List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5, 6);        ArrayList&lt;String&gt; result = numList.stream().reduce(new ArrayList&lt;String&gt;(), (a, b) -&gt; &#123;            a.add(&quot;element-&quot; + Integer.toString(b));            return a;        &#125;, (a, b) -&gt; null);        System.out.println(result);    &#125;</code></pre><p>skip 0 limit 10 ,  就类似于mysql limit 0,10 </p><pre><code> final List&lt;Kuaidi100Vo.DataBean&gt; addList = resultList.stream().skip(0).limit(num).collect(Collectors.toList());</code></pre><p>求和</p><pre><code>BigDecimal:BigDecimal bb =list.stream().map(Plan::getAmount).reduce(BigDecimal.ZERO,BigDecimal::add);int、double、long:double max = list.stream().mapToDouble(User::getHeight).sum();</code></pre><p>###分组求和、分组求最值、分组求数量。就类似于sql里的分组</p><pre><code>        String collect = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).map(Object::toString).collect(Collectors.joining(&quot;,&quot;));        System.out.println(collect);        //HashSet        Set&lt;Object&gt; collect1 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(Collectors.toSet());        System.out.println(collect1);        //ArrayList        List&lt;Object&gt; collect2 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(Collectors.toList());        System.out.println(collect2);        //ConcurrentMap        ConcurrentMap&lt;Integer, Object&gt; collect3 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(Collectors.toConcurrentMap(m -&gt; m.hashCode(), m -&gt; m, (v1, v2) -&gt; v2));        System.out.println(collect3);        Double collect4 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(Collectors.averagingInt(new ToIntFunction&lt;Object&gt;() &#123;            @Override            public int applyAsInt(Object value) &#123;                return value.hashCode();            &#125;        &#125;));        System.out.println(collect4);        /**         * 分组         */        //分成2组，使用 Collectors.partitioningBy效率更高        Map&lt;Boolean, List&lt;Object&gt;&gt; collect5 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(Collectors.partitioningBy(m -&gt; m instanceof String));        System.out.println(collect5);        //分成多组        Map&lt;? extends Class&lt;?&gt;, List&lt;Object&gt;&gt; collect6 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(groupingBy(Object::getClass));        System.out.println(collect6);        //分组，统计组内元素的数量        Map&lt;? extends Class&lt;?&gt;, Long&gt; collect7 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(groupingBy(Object::getClass, Collectors.counting()));        System.out.println(collect7);        //分组，求和组内元素        Map&lt;? extends Class&lt;?&gt;, Integer&gt; collect8 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(groupingBy(Object::getClass, summingInt(Object::hashCode)));        System.out.println(collect8);        //分组，取最值组内元素        Map&lt;? extends Class&lt;?&gt;, Optional&lt;Object&gt;&gt; collect9 = Stream.of(1, new Object(), &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;).collect(groupingBy(Object::getClass, maxBy(Comparator.comparing(Object::hashCode))));        System.out.println(collect9);                //自定义的聚合操作 reducing        String s = Stream.of(&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;)                .collect(reducing((x, y) -&gt; x+y)).get();        System.out.println(s);</code></pre><p>###使用流简易构造连续的数组</p><pre><code>        int[] ints = Stream.iterate(1, k -&gt; ++k)            .limit(100).flatMapToInt(stream -&gt; IntStream.of(stream)).toArray();        long[] longs = Stream.iterate(1, k -&gt; ++k)            .limit(100).flatMapToLong(stream -&gt; LongStream.of(stream)).toArray();        double[] doubles = Stream.iterate(1, k -&gt; ++k)            .limit(100).flatMapToDouble(stream -&gt; DoubleStream.of(stream)).toArray();        List&lt;String&gt; collect = Stream.iterate(1, k -&gt; ++k)            .limit(100).map(m -&gt; String.valueOf(m)).collect(Collectors.toList());        String[] strings = collect.toArray(new String[0]);        System.out.println(strings);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>two.md</title>
      <link href="/2022/03/20/two/"/>
      <url>/2022/03/20/two/</url>
      
        <content type="html"><![CDATA[<hr><p>title: mysql 使用mysqld_multi在一台机器上安装多个mysql实例（多实例安装）<br>top: true<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2021-05-02 19:08:12<br>password:<br>summary:<br>tags:<br>categories:</p><hr><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld-multi.html">https://dev.mysql.com/doc/refman/5.7/en/mysqld-multi.html</a></p><p>多实例安装即是一台服务器安装多个mysql实例；这样可以充分利用硬件资源；通过mysqld_multi程序即可。</p><p>例如我们现在有一台配置较高的机器：32C，512G，8SSD做RIAND5，而4C 8G才是主流服务器配置。这么一台服务器仅仅跑一个mysql是非常奢侈的。现在我们就可以在这台机器上同时部署三个mysql实例：mysqld3306、mysqld3307、mysqld3308。</p><h2 id="mysqld-multi配置"><a href="#mysqld-multi配置" class="headerlink" title="mysqld_multi配置"></a>mysqld_multi配置</h2><p>1、配置mysqld_multi节点；mysqld_safe启动、mysqladmin停止、mysqld_multi.log日志（有问题都可以到这里排查）。<br>2、配置三个实例：mysqld3306、mysqld3307、mysqld3308；分别指定port、datadir、socket。<br>3、此时的[mysqld]节点下的配置是mysqld3306、mysqld3307、mysqld3308三个实例所共享的。<br>4、[client] 节点配置了默认客户端连接参数。我这里配置了root用户、密码还有指定socket为/tmp/mysql.sock3306。则随后可以直接使用mysql命令连接到mysql3306实例而不需要额外指定参数。</p><pre><code>[mysqld]user = mysqlbasedir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64log_error=error.logplugin-load=validate_password.so[mysqld_multi]mysqld=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld_safemysqladmin=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqladminlog=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/mysqld_multi.log[mysqld3306]port=3306datadir=/mdata/mysql57-3306socket= /tmp/mysql.sock3306[mysqld3307]port=3307datadir=/mdata/mysql57-3307socket= /tmp/mysql.sock3307[mysqld3308]port=3308datadir=/mdata/mysql57-3308socket= /tmp/mysql.sock3308[client]user=rootpassword=1111aaA_socket= /tmp/mysql.sock3306[mysql]prompt=(\\u@\\h) [\\d]&gt;\\</code></pre><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>1、以mysqld3306实例为例，初始化数据如下。注意指定datadir。</p><pre><code>[root@localhost bin]# ./mysqld --initialize --datadir=/mdata/mysql57-3306</code></pre><blockquote><p>注意：[mysqld]下配置了plugin-load=validate_password.so 密码插件的话就不能使用–initialize-insecure，请使用–initialize。否则初始化后密码是空的，然后连不上。</p></blockquote><p>mysqld3306实例生成密码如下：</p><pre><code>[root@localhost mysql57-3306]# cat error.log 2021-05-01T03:22:15.245117Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2021-05-01T03:22:16.562503Z 0 [Warning] InnoDB: New log files created, LSN=457902021-05-01T03:22:16.692390Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2021-05-01T03:22:16.750221Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 6e1b5ce4-aa2c-11eb-befe-000c292882e9.2021-05-01T03:22:16.751331Z 0 [Warning] Gtid table is not ready to be used. Table &#39;mysql.gtid_executed&#39; cannot be opened.2021-05-01T03:22:17.412496Z 0 [Warning] CA certificate ca.pem is self signed.2021-05-01T03:22:17.657496Z 1 [Note] A temporary password is generated for root@localhost: Ye-7i!4-gtw)</code></pre><p>2、使用mysqld_multi 命令启动实例，start后面跟的3306和[mysqld3306]中的3306对应起来，这里可以使用任何名字。如[mysqld1]就这样启动：./mysqld_multi start 1。</p><pre><code>[root@localhost bin]# ./mysqld_multi start 3306</code></pre><p>3、查看状态</p><pre><code>[root@localhost bin]# ./mysqld_multi report 3306Reporting MySQL serversMySQL server from group: mysqld3306 is running</code></pre><p>4、查看进程。如下启动mysqld3306 实例后就出现了两个进程：mysqld_safe 和 mysqld 。</p><pre><code>[root@localhost bin]# ps -ef |grep mysqlroot      11675      1  0 10:55 pts/0    00:00:00 /bin/sh /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld_safe --port=3306 --datadir=/mdata/mysql57-3306 --socket=/tmp/mysql.sock3306mysql     11827  11675  2 10:55 pts/0    00:00:00 /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld --basedir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64 --datadir=/mdata/mysql57-3306 --plugin-dir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/lib/plugin --user=mysql --log-error=error.log --pid-file=localhost.localdomain.pid --socket=/tmp/mysql.sock3306 --port=3306root      11874   7035  0 10:55 pts/0    00:00:00 grep --color=auto mysql</code></pre><p>5、继续初始化和启动其它进程。<br>./mysqld_multi start 3307<br>./mysqld_multi start 3308</p><p>6、最终的mysql相关进程有6个。如下，分别3个mysqld、3个mysqld_safe 。</p><pre><code>[root@localhost bin]# ps -ef |grep mysqlroot      11675      1  0 10:55 pts/0    00:00:00 /bin/sh /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld_safe --port=3306 --datadir=/mdata/mysql57-3306 --socket=/tmp/mysql.sock3306mysql     11827  11675  0 10:55 pts/0    00:00:00 /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld --basedir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64 --datadir=/mdata/mysql57-3306 --plugin-dir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/lib/plugin --user=mysql --log-error=error.log --pid-file=localhost.localdomain.pid --socket=/tmp/mysql.sock3306 --port=3306root      11948      1  0 10:56 pts/0    00:00:00 /bin/sh /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld_safe --port=3307 --datadir=/mdata/mysql57-3307 --socket=/tmp/mysql.sock3307mysql     12104  11948  2 10:56 pts/0    00:00:00 /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld --basedir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64 --datadir=/mdata/mysql57-3307 --plugin-dir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/lib/plugin --user=mysql --log-error=error.log --pid-file=localhost.localdomain.pid --socket=/tmp/mysql.sock3307 --port=3307root      12199      1  0 10:57 pts/0    00:00:00 /bin/sh /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld_safe --port=3308 --datadir=/mdata/mysql57-3308 --socket=/tmp/mysql.sock3308mysql     12352  12199  7 10:57 pts/0    00:00:00 /home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/bin/mysqld --basedir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64 --datadir=/mdata/mysql57-3308 --plugin-dir=/home/mysql5.7/mysql-5.7.33-linux-glibc2.12-x86_64/lib/plugin --user=mysql --log-error=error.log --pid-file=localhost.localdomain.pid --socket=/tmp/mysql.sock3308 --port=3308root      12398   7035  0 10:57 pts/0    00:00:00 grep --color=auto mysql</code></pre><p>7、 netstat -anl 看下端口。3306、3307、3308 都被占用了。</p><pre><code>[root@localhost tmp]# netstat -anlActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address           Foreign Address         State      tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     tcp        0      0 192.168.6.128:22        192.168.6.1:1042        ESTABLISHEDtcp        0      0 192.168.6.128:22        192.168.6.1:1410        ESTABLISHEDtcp        0      0 192.168.6.128:22        192.168.6.1:2135        ESTABLISHEDtcp        0      0 192.168.6.128:22        192.168.6.1:1043        ESTABLISHEDtcp6       0      0 :::3306                 :::*                    LISTEN     tcp6       0      0 :::3307                 :::*                    LISTEN     tcp6       0      0 :::3308                 :::*                    LISTEN     tcp6       0      0 :::22                   :::*                    LISTEN     udp        0      0 127.0.0.1:323           0.0.0.0:*                          udp6       0      0 ::1:323                 :::*                               Active UNIX domain sockets (servers and established)Proto RefCnt Flags       Type       State         I-Node   Pathunix  2      [ ACC ]     STREAM     LISTENING     75933    /tmp/mysql.sock3306unix  3      [ ]         DGRAM                    11503    /run/systemd/notifyunix  2      [ ACC ]     STREAM     LISTENING     48932    /tmp/mysql.sock3307unix  2      [ ]         DGRAM                    11505    /run/systemd/cgroups-agentunix  2      [ ACC ]     STREAM     LISTENING     19191    /run/systemd/privateunix  2      [ ACC ]     STREAM     LISTENING     76809    /tmp/mysql.sock3308unix  2      [ ]         DGRAM                    33496    </code></pre><p>8、连接后修改密码。<br>使用sock连接。如mysql3306则指定/tmp/mysql.sock3306。<br>并set password = ‘1111aaA_’; 修改当前用户密码。</p><pre><code>[root@localhost bin]# ./mysql -S /tmp/mysql.sock3306 -pEnter password: ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)[root@localhost bin]# ./mysql -S /tmp/mysql.sock3306 -pYe-7i!4-gtw)-bash: !4: event not found[root@localhost bin]# ./mysql -S /tmp/mysql.sock3306 -p&#39;Ye-7i!4-gtw)&#39;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 6Server version: 5.7.33Copyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.(root@localhost) [(none)]&gt;set password = &#39;1111aaA_&#39;;</code></pre><p>9、随后可以直接输入mysql登录了。</p><pre><code>[root@localhost /]# mysqlWelcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 9Server version: 5.7.33 MySQL Community Server (GPL)Copyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.(root@localhost) [(none)]&gt;\s--------------mysql  Ver 14.14 Distrib 5.7.33, for linux-glibc2.12 (x86_64) using  EditLine wrapperConnection id:        9Current database:    Current user:        root@localhostSSL:            Not in useCurrent pager:        stdoutUsing outfile:        &#39;&#39;Using delimiter:    ;Server version:        5.7.33 MySQL Community Server (GPL)Protocol version:    10Connection:        Localhost via UNIX socketServer characterset:    latin1Db     characterset:    latin1Client characterset:    utf8Conn.  characterset:    utf8UNIX socket:        /tmp/mysql.sock3306Uptime:            14 min 19 secThreads: 2  Questions: 22  Slow queries: 0  Opens: 106  Flush tables: 1  Open tables: 99  Queries per second avg: 0.025--------------</code></pre><p>拓展：<br>1、同理，其它的mysql3307、mysql3308也是一样的操作。另外想要直接使用mysql -S /tmp/mysql.sock3307、mysql -S /tmp/mysql.sock3308 直接登录。那么需要将其它两个实例的密码都改为1111aaA_。</p><p>2、有人喜欢使用mysqld –defaults-file=/etc/my.cnf 的defaults-file参数来指定特定的my.cnf配置文件来实现多实例安装。但是这样的话实例一多就不好管理了。所以推荐使用mysqld_multi。</p><p>3、多实例IO竞争问题怎么解决？<br>对于资源管理、资源调度问题可以通过操作系统层面的技术解决。<br>LXC<br>docker<br>Cgroup</p><p>4、MHA、keepalive 这些集群软件请不要使用多实例安装，这种高可用软件肯定是要部署到多个机器上。</p><p>5、每次初始化会不会对已经存在的实例有影响？<br>初始化实例时请指定datadir：<br>./mysqld –initialize –datadir=/mdata/mysql57-3306<br>当然不指定的话，就算原来目录已经存在数据。那么此次执行会失败的。并不会对已经存在的数据目录产生影响。</p><pre><code>[root@localhost bin]# ./mysqld --initialize --datadir=/mdata/mysql57-33082021-05-01T04:18:01.028139Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2021-05-01T04:18:01.029870Z 0 [ERROR] --initialize specified but the data directory has files in it. Aborting.2021-05-01T04:18:01.029901Z 0 [ERROR] Aborting</code></pre><p>6、使用mysqld_multi stop 3306 停止实例时可能会失败，因为实际上是去调用mysqladmin来停止，mysqladmin会去读取[client]下的用户名和密码 ，若不符合自然是关闭不了。可以选择使用kill来停止，或者去修改[client]配置。</p><pre><code>[root@localhost bin]# ./mysqld_multi stop 3307[root@localhost bin]# ./mysqld_multi report 3307Reporting MySQL serversMySQL server from group: mysqld3307 is running</code></pre><p>7、选择单机多实例，还是建立多个虚拟机？<br>这就是不同的资源调度的方式。<br>像淘宝的RDS云数据库就是使用LXC Container 来进行资源隔离的，其实就是安装多个实例，这种方式性能会更好。当然虚拟机也有它的好处。</p><p>8、一个实例建立多个数据库。或者多个数据库分别放到不同实例下。<br>这个还是得看业务。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个类的构造方法的作用是什么--若一个类没有声明构造方法，该程序能正确执行吗--为什么-.md</title>
      <link href="/2022/03/20/yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me/"/>
      <url>/2022/03/20/yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me/</url>
      
        <content type="html"><![CDATA[<p>构造方法主要作用是完成对类对象的初始化工作。</p><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一定不能忽略编译器给我们的警告！.md</title>
      <link href="/2022/03/20/yi-ding-bu-neng-hu-lue-bian-yi-qi-gei-wo-men-de-jing-gao/"/>
      <url>/2022/03/20/yi-ding-bu-neng-hu-lue-bian-yi-qi-gei-wo-men-de-jing-gao/</url>
      
        <content type="html"><![CDATA[<p>这些警告内包含一些起到影响程序结果的关键意义内容；如<br>Objects.equals 比较Long和Integer<br><img src="https://upload-images.jianshu.io/upload_images/13965490-85d8db3ce824e1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不可变集合的魅力.md</title>
      <link href="/2022/03/20/bu-ke-bian-ji-he-de-mei-li/"/>
      <url>/2022/03/20/bu-ke-bian-ji-he-de-mei-li/</url>
      
        <content type="html"><![CDATA[<p>用如此多的接口和抽象类来实现数量并不多的具体集合类似乎没有太大必要。通过使用视图<br>( views) 可以获得其他的实现了 Collection 接口和 Map 接口的对象。视图技术在集框架中有许多非常有用的应用。下面将讨论这些应用。</p><p>###几种创建不可变集合的方式<br>1、Collections.singleton 单个<br>2、List::of 多个 Java 9<br>4、Arrays::asList 多个<br>4、Collections.nCopies 多个相同的<br>5、Stream.of(item).collect(Collectors.toList); 多个</p><p>Collections::singletonList的性能要比List::of的性能略好一些；下一个Arrays::asList，速度大约是它的两倍，吞吐量是它的60％。相比之下，Stream API提供的两种方法测试结果非常糟糕。</p><p>Collections::singleton 和List::of都是创建单元列表的绝佳选择。如果使用的Java版本支持这两种方法（Java 9及更高版本），我建议使用List：of，因为它使用方便、代码可读性强且不可变性更好</p><p>###Collections.singleton<br>1、在只需读取的单个元素集合场景中，我们可以使用Collections.singleton 优化内存<br>2、去除list中的null<br>在这里使用Collections.singletonLis 比 new 一个List更节省空间</p><pre><code>        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;abc&quot;);        list.add(null);        list.add(&quot;def&quot;);        list.add(null);        list.removeAll(Collections.singletonList(null));        //[abc, def]        System.out.println(list);</code></pre><h3 id="Collections-nCopies"><a href="#Collections-nCopies" class="headerlink" title="Collections.nCopies"></a>Collections.nCopies</h3><p>nCopies方法可以用来给list填充null，存储代价很小。这是视图技术的一种巧妙应用。<br>List<Object> myList = new ArrayList&lt;&gt;(200);<br>List<Object> objects = Collections.nCopies(100, null);<br>myList.addAll(objects);</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么-Java-中只有值传递？.md</title>
      <link href="/2022/03/20/wei-shi-me-java-zhong-zhi-you-zhi-chuan-di/"/>
      <url>/2022/03/20/wei-shi-me-java-zhong-zhi-you-zhi-chuan-di/</url>
      
        <content type="html"><![CDATA[<p>首先，我们回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。</p><p><strong>按值调用(call by value)</strong> 表示方法接收的是调用者提供的值，<strong>按引用调用（call by reference)</strong> 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p><p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong>下面通过 3 个例子来给大家说明</strong></p><blockquote><p><strong>example 1</strong></p></blockquote><pre class="line-numbers language-source-java"><code class="language-source-java">public static void main(String[] args) &#123;    int num1 = 10;    int num2 = 20;    swap(num1, num2);    System.out.println("num1 = " + num1);    System.out.println("num2 = " + num2);&#125;public static void swap(int a, int b) &#123;    int temp = a;    a = b;    b = temp;    System.out.println("a = " + a);    System.out.println("b = " + b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果：</strong></p><pre><code>a = 20b = 10num1 = 10num2 = 20</code></pre><p><strong>解析：</strong></p><p><a href="https://camo.githubusercontent.com/8943d6a83be198245233aafea4f5c7bb44fe8beaf24734c4cac105a1fe3cb8f3/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f32323139313334382e6a7067"><img src="https://upload-images.jianshu.io/upload_images/13965490-2c64273991d5696a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="example 1 "></a> </p><p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><blockquote><p><strong>example 2</strong></p></blockquote><pre class="line-numbers language-source-java"><code class="language-source-java">    public static void main(String[] args) &#123;        int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;        System.out.println(arr[0]);        change(arr);        System.out.println(arr[0]);    &#125;    public static void change(int[] array) &#123;        // 将数组的第一个元素变为0        array[0] = 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果：</strong></p><pre><code>10</code></pre><p><strong>解析：</strong></p><p><a href="https://camo.githubusercontent.com/60fabb689c7bb65a3372b5e57f0dc7b0ea70351cbc05c2da30109ec229a0af89/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f333832353230342e6a7067"><img src="https://upload-images.jianshu.io/upload_images/13965490-49c236ecae608e28?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="example 2"></a> </p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><blockquote><p><strong>example 3</strong></p></blockquote><pre class="line-numbers language-source-java"><code class="language-source-java">public class Test &#123;    public static void main(String[] args) &#123;        // TODO Auto-generated method stub        Student s1 = new Student("小张");        Student s2 = new Student("小李");        Test.swap(s1, s2);        System.out.println("s1:" + s1.getName());        System.out.println("s2:" + s2.getName());    &#125;    public static void swap(Student x, Student y) &#123;        Student temp = x;        x = y;        y = temp;        System.out.println("x:" + x.getName());        System.out.println("y:" + y.getName());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果：</strong></p><pre><code>x:小李y:小张s1:小张s2:小李</code></pre><p><strong>解析：</strong></p><p>交换之前：</p><p><a href="https://camo.githubusercontent.com/513c21abd7aa74f29610968795fac651c43118d0e3a9e74328b52759ca31059f/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f38383732393831382e6a7067"><img src="https://upload-images.jianshu.io/upload_images/13965490-d3563fb68486a933?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a> </p><p>交换之后：</p><p><a href="https://camo.githubusercontent.com/8daaeed5b14a5233a93555d30964edbabec994f347a1bf120c3bfb4423df397d/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f33343338343431342e6a7067"><img src="https://upload-images.jianshu.io/upload_images/13965490-6b9f677e43258723?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a> </p><p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p><blockquote><p><strong>总结</strong></p></blockquote><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p><p>下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>  一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>  一个方法可以改变一个对象参数的状态。</li><li>  一个方法不能让对象参数引用一个新的对象。</li></ul><p><strong>参考：</strong></p><p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么时候使用-java-util-Optional？.md</title>
      <link href="/2022/03/20/shi-me-shi-hou-shi-yong-java-util-optional/"/>
      <url>/2022/03/20/shi-me-shi-hou-shi-yong-java-util-optional/</url>
      
        <content type="html"><![CDATA[<ul><li>map.get()</li><li>list.get()</li><li>xxx.get()</li></ul><p>非常厉害的用法：<br>把Map的元素value转Boolean，转File</p><pre><code>    public static void configure(Map&lt;String, String&gt; options) &#123;        Boolean useCache = Optional.ofNullable(options.get(&quot;cache&quot;)).map(Boolean::parseBoolean).orElse(true);        File fileRoot = Optional.ofNullable(options.get(&quot;fileRoot&quot;)).map(File::new).orElse(null);    &#125;</code></pre><pre><code>private Double calculateAverageGrade(Map&lt;String, List&lt;Integer&gt;&gt; gradesList, String studentName)      throws Exception &#123;    return Optional.ofNullable(gradesList.get(studentName))        .map(list -&gt; list.stream().collect(Collectors.averagingDouble(x -&gt; x)))        .orElseThrow(() -&gt; new Exception(&quot;Student not found - &quot; + studentName));  &#125;</code></pre><pre><code>            @Override            public OptionalDouble getValueFromAggregationQueryResult(Object value)            &#123;                return Optional.ofNullable(value)                        .map(Number.class::cast)                        .map(Number::doubleValue)                        .map(OptionalDouble::of)                        .orElseGet(OptionalDouble::empty);            &#125;</code></pre><p>自己的用法：<br>改写前：</p><pre><code>       String areaDetail = jgOriginalOrder.getAreaDetail();        if (ToolUtil.isNotEmpty(areaDetail)) &#123;            List&lt;Map&lt;String, String&gt;&gt; mList = AddressResolutionUtil.addressResolution(areaDetail);            if (ToolUtil.isNotEmpty(mList)) &#123;                Map&lt;String, String&gt; stringStringMap = mList.get(0);                if (ToolUtil.isNotEmpty(stringStringMap)) &#123;                    jgOriginalOrder.setProvince(stringStringMap.get(ImportOrderByExcelListener.PROVINCE));                    jgOriginalOrder.setCity(stringStringMap.get(ImportOrderByExcelListener.CITY));                    jgOriginalOrder.setArea(stringStringMap.get(ImportOrderByExcelListener.COUNTY));                &#125;            &#125;        &#125;</code></pre><p>改写后</p><pre><code>        Optional.ofNullable(jgOriginalOrder.getAreaDetail()).filter(ToolUtil::isNotEmpty)                .map(AddressResolutionUtil::addressResolution).filter(ToolUtil::isNotEmpty)                .map(list -&gt; list.get(0)).ifPresent(map -&gt; &#123;                    jgOriginalOrder.setProvince(map.get(ImportOrderByExcelListener.PROVINCE));                    jgOriginalOrder.setCity(map.get(ImportOrderByExcelListener.CITY));                    jgOriginalOrder.setArea(map.get(ImportOrderByExcelListener.COUNTY));                &#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码性能.md</title>
      <link href="/2022/03/20/dai-ma-xing-neng/"/>
      <url>/2022/03/20/dai-ma-xing-neng/</url>
      
        <content type="html"><![CDATA[<p>1、使用空集合来返回避免性能消耗<br>空集合能用来做返回值也只能用来做返回值！还要确保下层调用不是使用这个list进行操作<br>Collections.emptyList()、emptyMap()<br>以下代码来自apache2.0</p><pre><code>public static List&lt;BlockNode&gt; bitSetToBlocks(MethodNode mth, BitSet bs) &#123;        int size = bs.cardinality();        if (size == 0) &#123;            return Collections.emptyList();        &#125;        List&lt;BlockNode&gt; blocks = new ArrayList&lt;&gt;(size);        for (int i = bs.nextSetBit(0); i &gt;= 0; i = bs.nextSetBit(i + 1)) &#123;            BlockNode block = mth.getBasicBlocks().get(i);            blocks.add(block);        &#125;        return blocks;    &#125;</code></pre><p>2、<code>重要</code> 使用并行流的迭代比普通循环性能要好，里面使用ofNullable进行null值校验。下面的代码才是新式代码！</p><pre><code>        List&lt;JqReturnExchange&gt; records = page.getRecords();        records.parallelStream().forEach(returnExchange -&gt; &#123;            Integer auditStateInt = Optional.ofNullable(returnExchange)                    .map(JqReturnExchange::getAuditState)                    .map(AuditState::getCode).orElse(0);            returnExchange.setAuditStateInt(auditStateInt);        &#125;);</code></pre><p>3、正则表达式可以预编译，提供性能</p><pre><code>private static final Pattern pattern = Pattern.compile(regexRule); private void func(...) &#123;    Matcher m = pattern.matcher(content);    if (m.matches()) &#123;        ...    &#125;&#125;</code></pre><p>4、在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。<br>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”);</p><p>5、循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、<br>获取数据库连接，进行不必要的<code> try-catch 操作</code><strong>（这个 try-catch 是否可以移至循环体外）。</strong></p><p>6、<code>重要</code> 禁止再循环中访问数据库。尽量使用in操作批量查询来代替多次的sql查询。<br>一次数据库网络IO就要 100ms，10次就是1秒钟了。一次批量如果有100个。那么就是10秒钟！想想什么概念<br>吧</p><p>7、多个网络访问可以使用多线程优化</p><p>8、能用实体类就不要图方便用HashMap。HashMap是个大对象！一个空的HashMap就占48字节；<br>一些人一般喜欢在contraller参数和mybatis的参数，返回结果都用HashMap。这样太浪费资源了。如果数据量一大<br>List<Map> 动则占用几G。 48字节、假设10个字段、100万条记录。那么占0.4G</p><p>9、<code>重要</code> 应该避免嵌套的for循环！<br>使用stream等诸多操作来代替之，使用Hash优化，类似mysql的 index nested loop join。<br>小表驱动大表，外边的集合尽量小，里面的集合尽量大；里面的集合转为HashMap，匹配时直接map.get(xxx)<br>时间复杂度从O(n平方)变为 n</p><p>10、有些对象只需要初始化一次，后面就复用这个实例就行了。<br>注意有没有线程安全问题，不要在方法中初始化赋值！这样就每次请求都会new新对象浪费资源</p><p>11、集合初始化一定指定初始容量。防止扩容array.copy次数多。效率低</p><p>12、如果有多个 = 某个字段的查询。尝试直接通过in得到批量数据。把循环查询数据库变为1次</p><p>mysql</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用-try-with-resources-代替try-catch-finally调用close关闭资源.md</title>
      <link href="/2022/03/20/shi-yong-try-with-resources-dai-ti-try-catch-finally-diao-yong-close-guan-bi-zi-yuan/"/>
      <url>/2022/03/20/shi-yong-try-with-resources-dai-ti-try-catch-finally-diao-yong-close-guan-bi-zi-yuan/</url>
      
        <content type="html"><![CDATA[<p>类似于InputStream、OutputStream 、Scanner 、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句：</p><pre><code>        //读取文本文件的内容        Scanner scanner = null;        try &#123;            scanner = new Scanner(new File(&quot;D://read.txt&quot;));            while (scanner.hasNext()) &#123;                System.out.println(scanner.nextLine());            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (scanner != null) &#123;                scanner.close();            &#125;        &#125;</code></pre><p>这样做是不是很麻烦？既要进行资源非空判断还要对close进行捕获异常，弄不好就可能有资源忘了关闭。<br>在 JDK 1.7 之后的 try-with-resources 可以完美解决这个问题。<br>改造上面的代码:</p><pre><code>    public static void main(String[] args) &#123;        try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) &#123;            while (scanner.hasNext()) &#123;                System.out.println(scanner.nextLine());            &#125;        &#125; catch (FileNotFoundException fnfe) &#123;            fnfe.printStackTrace();        &#125;finally &#123;            System.out.println(&quot;执行finally&quot;);        &#125;    &#125;</code></pre><p>其实try-with-resources写法会自动加上close的代码，反编译一下：</p><pre><code>    public static void main(String[] args) &#123;        try &#123;            Scanner scanner = new Scanner(new File(&quot;test.txt&quot;));            Throwable var2 = null;            try &#123;                while(scanner.hasNext()) &#123;                    System.out.println(scanner.nextLine());                &#125;            &#125; catch (Throwable var20) &#123;                var2 = var20;                throw var20;            &#125; finally &#123;                if (scanner != null) &#123;                    if (var2 != null) &#123;                        try &#123;                            scanner.close();                        &#125; catch (Throwable var19) &#123;                            var2.addSuppressed(var19);                        &#125;                    &#125; else &#123;                        scanner.close();                    &#125;                &#125;            &#125;        &#125; catch (FileNotFoundException var22) &#123;            var22.printStackTrace();        &#125; finally &#123;            System.out.println(&quot;执行finally&quot;);        &#125;    &#125;</code></pre><ul><li>自动生成了关闭资源的finally 代码块；</li><li>而且将scanner.close()抛出的异常和new Scanner()抛出异常，addSuppressed合并到了一起。解决了<code>异常屏蔽</code>；从JDK 1.7开始，Throwable 类新增了 addSuppressed 方法，支持将一个异常附加到另一个异常身上，从而避免异常屏蔽。</li><li>在try-with-resources后面定义的finally 代码块自动加到了最外层。</li></ul><p>如果有多个资源呢，如何处理？<br>通过使用分号分隔，可以在try-with-resources块中声明多个资源。</p><pre><code>       try (BufferedInputStream bin = new BufferedInputStream(            new FileInputStream(new File(&quot;test.txt&quot;)));            BufferedOutputStream bout = new BufferedOutputStream(                new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;            int b;            while ((b = bin.read()) != -1) &#123;                bout.write(b);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;</code></pre><p>###自定义AutoClosable 实现<br>这个try-with-resources结构里不仅能够操作java内置的类。你也可以在自己的类中实现java.lang.AutoCloseable接口，然后在try-with-resources结构里使用这个类。</p><p>AutoClosable 接口仅仅有一个方法，接口定义如下：</p><pre><code>public interface AutoClosable &#123;    public void close() throws Exception;&#125;</code></pre><p>未实现AutoCloseable接口的类无法使用在try-with-resources结构的try中，编译会报错：</p><pre><code>java: 不兼容的类型: try-with-resources 不适用于变量类型    (java.io.File无法转换为java.lang.AutoCloseable)</code></pre><p>任何实现了这个接口的方法都可以在try-with-resources结构中使用。</p><p>下面是一个简单的例子：</p><pre><code>public class MyAutoClosable implements AutoCloseable &#123;    public void doSome() &#123;        System.out.println(&quot;doSome&quot;);    &#125;    @Override    public void close() throws Exception &#123;        System.out.println(&quot;closed&quot;);    &#125;&#125;</code></pre><pre><code>    public static void main(String[] args) &#123;        try (MyAutoClosable myAutoClosable = new MyAutoClosable()) &#123;            myAutoClosable.doSome();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(&quot;finally执行&quot;);        &#125;    &#125;</code></pre><p>doSome<br>closed<br>finally执行</p><p>使用try-with-resources以后就不要担心使用资源不关闭了。</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股文.md</title>
      <link href="/2022/03/20/ba-gu-wen/"/>
      <url>/2022/03/20/ba-gu-wen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gitee.com/SnailClimb/JavaGuide">https://gitee.com/SnailClimb/JavaGuide</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类.md</title>
      <link href="/2022/03/20/nei-bu-lei/"/>
      <url>/2022/03/20/nei-bu-lei/</url>
      
        <content type="html"><![CDATA[<p>###局部内部类<br>如果仔细地阅读一下 TalkingClock 示例的代码就会发现， TimePrinter 这个类名字只在<br>start 方法中创建这个类型的对象时使用了一次。<br>当遇到这类情况时， 可以在一个方法中定义局部类。</p><pre><code>public void start0 &#123;class TiiePrinter inpleients ActionListener&#123;public void actionPerforaed(ActionEvent event) &#123;Systei.out.println(&quot;At the tone, the tine is &quot; + new DateO)；if (beep) Toolkit.getDefaul tToolki10•beep(): &#125; &#125;ActionListener listener = new TimePrinter();Timer t = new Timer(interva1, listener); t.start(); &#125;</code></pre><p>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部<br>类的块中。<br>局部类有一个优势， 即对外部世界可以完全地隐藏起来。 即使 TalkingClock 类中的其他<br>代码也不能访问它。除 start 方法之外， 没有任何方法知道 TimePrinter 类的存在<br>###匿名内部类<br>直接new一个接口，进行实现</p><p>###静态内部类</p><p>有时候， 使用内部类只是为了把一个类隐藏在另外一个类的内部，<strong>并不需要内部类引用外围类对象</strong>。为此，可以将内部类声明为 static, 以便取消产生的引用。<br>在内部类不需要访问外围类对象的时候， 应该使用静态内部类。 有些程序员用嵌套类 （nested class) 表示静态内部类。 </p><p>与常规内部类不同，静态内部类可以有静态域和方法。</p><p>声明在接口中的内部类自动成为 static 和 public 类。</p><p>使用场景：<br>当然， Pair 是一个十分大众化的名字。在大型项目中， 除了定义包含一对字符串的 Pair<br>类之外， 其他程序员也很可能使用这个名字。这样就会产生名字冲突。解决这个问题的办法<br>是将 Pair 定义为 ArrayAlg 的内部公有类。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兼容windows和linux的磁盘路径写法.md</title>
      <link href="/2022/03/20/jian-rong-windows-he-linux-de-ci-pan-lu-jing-xie-fa/"/>
      <url>/2022/03/20/jian-rong-windows-he-linux-de-ci-pan-lu-jing-xie-fa/</url>
      
        <content type="html"><![CDATA[<p>这样写<br>  String path = File.separator + “home” + File.separator + “file” + File.separator;</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再谈-Comparator比较器.md</title>
      <link href="/2022/03/20/zai-tan-comparator-bi-jiao-qi/"/>
      <url>/2022/03/20/zai-tan-comparator-bi-jiao-qi/</url>
      
        <content type="html"><![CDATA[<p>###结合lambda使用<br>Arrays.sort(people, Comparator.comparing(Person::getName));</p><p>###设置次级排序</p><p>Collections.sort(list,Comparator.comparing(MachineInfo::getApp).thenComparing(MachineInfo::getIp).thenComparingInt(MachineInfo::getPort));</p><p>###comparinglnt 避免装箱的比较器<br>另外， comparing 和 thenComparing 方法都有变体形式，可以避免 int、 long 或 double 值<br>的装箱。要完成前一个操作， 还有一种更容易的做法：<br>Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getNameO -length()));</p><h3 id="空安全的比较器"><a href="#空安全的比较器" class="headerlink" title="空安全的比较器"></a>空安全的比较器</h3><p>如果键函数可以返回 null, 可 能 就 要 用 到 nullsFirst 和 nullsLast 适配器。这些静态方<br>法会修改现有的比较器，从而在遇到 null 值时不会抛出异常， 而是将这个值标记为小于或<br>大于正常值。</p><p>Arrays.sort(peopleList, comparing(Person::getMiddleName , nulIsFirst(naturalOrder())));</p><p>和其他结合使用</p><pre><code>DATAGROUPS = list.stream()                .sorted(Comparator.nullsFirst(Comparator.comparing(MgbDictData::getDictType)                .thenComparing(MgbDictData::getDictSort)                .thenComparing(MgbDictData::getDictValue)))                .collect(Collectors.groupingBy(MgbDictData::getDictType));</code></pre><h3 id="reverseOrder-逆序"><a href="#reverseOrder-逆序" class="headerlink" title="reverseOrder 逆序"></a>reverseOrder 逆序</h3><p>静态 reverseOrder 方法会提供自然顺序的逆序。要让比较器逆序比较， 可以使用 reversed<br>实例方法c 例如 naturalOrder().reversed() 等同于 reverseOrder()</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口应用---进一步剥离重复代码.md</title>
      <link href="/2022/03/20/han-shu-shi-jie-kou-ying-yong-jin-yi-bu-bo-chi-chong-fu-dai-ma/"/>
      <url>/2022/03/20/han-shu-shi-jie-kou-ying-yong-jin-yi-bu-bo-chi-chong-fu-dai-ma/</url>
      
        <content type="html"><![CDATA[<p>###Runnable 抽取<br>应用在try -catch 中，补货到多个异常。且存在相同的代码模块</p><p>原：</p><pre><code>   /**     * @Des 反射调用set; 返回true设置成功，返回false设置失败     * @Author yinkai     * @Date 2021/11/29 11:36     */    private static boolean setObjOnOrder(JgOriginalOrder order, String fieldName, String setObj, Map&lt;Integer, String&gt; allDataMap, Integer rowIndex, List&lt;Map&lt;Integer, String&gt;&gt; errObjList, String myAllField, Integer max) &#123;        Method method = ImportOrderByExcelListener.METHOD_MAP.get(fieldName);        if (ToolUtil.isEmpty(method)) &#123;            return true;        &#125;        /**         * 处理时间格式         */        boolean isEqualsDate = ToolUtil.equalsAny(fieldName, ImportOrderByExcelListener.CHAR_SEQUENCES2);        if (isEqualsDate) &#123;            try &#123;                DateTime date = com.gbm.cloud.common.util.DateUtil.parse(setObj);                ImportOrderByExcelListener.execute(method, order, date);            &#125; catch (DateException e) &#123;                ImportOrderByExcelListener.addErrorRow(allDataMap, errObjList, rowIndex, max, StrUtil.format(&quot;&#123;&#125;,&#123;&#125;=&#123;&#125; 时间格式错误&quot;, myAllField, fieldName, setObj));                return false;            &#125;        &#125;        /**         * 处理浮点格式         */        boolean isEqualsBigDecimal = ToolUtil.equalsAny(fieldName, ImportOrderByExcelListener.CHAR_SEQUENCES1);        if (isEqualsBigDecimal) &#123;            try &#123;                BigDecimal bigDecimal = new BigDecimal(setObj);                ImportOrderByExcelListener.execute(method, order, bigDecimal);            &#125; catch (NumberFormatException e) &#123;                ImportOrderByExcelListener.addErrorRow(allDataMap, errObjList, rowIndex, max, StrUtil.format(&quot;&#123;&#125;=&#123;&#125; 小数格式错误&quot;, myAllField, fieldName, setObj));                return false;            &#125;        &#125;        /**         * 处理整数格式         */        boolean isEqualsInteger = ToolUtil.equalsAny(fieldName, ImportOrderByExcelListener.CHAR_SEQUENCES);        if (isEqualsInteger) &#123;            try &#123;                int intObj = Integer.parseInt(setObj);                ImportOrderByExcelListener.execute(method, order, intObj);            &#125; catch (NumberFormatException e) &#123;                ImportOrderByExcelListener.addErrorRow(allDataMap, errObjList, rowIndex, max, StrUtil.format(&quot;&#123;&#125;=&#123;&#125; 整数格式错误&quot;, myAllField, fieldName, setObj));                return false;            &#125;        &#125;        ImportOrderByExcelListener.execute(method, order, setObj);        return true;    &#125;</code></pre><p>改写后: 一个方法拆成了三4个方法</p><pre><code>    /**     * @Des     * @Author yinkai     * @Date 2022/1/18 11:10     */    private static boolean runExecute(Runnable runnable, Integer rowIndex, List&lt;Map&lt;Integer, String&gt;&gt; errObjList, String myAllField, Integer max, String fieldName, String setObj, Map&lt;Integer, String&gt; allDataMap) &#123;        try &#123;            runnable.run();        &#125; catch (DateException e) &#123;            ImportOrderByExcelListener.addErrorRow(allDataMap, errObjList, rowIndex, max, StrUtil.format(ImportOrderByExcelListener.TIME_FORMAT_ERR_MESSAGE, myAllField, fieldName, setObj));            return false;        &#125; catch (NumberFormatException e) &#123;            ImportOrderByExcelListener.addErrorRow(allDataMap, errObjList, rowIndex, max, StrUtil.format(ImportOrderByExcelListener.BUMBER_FORMAT_ERR_MESSAGE, myAllField, fieldName, setObj));            return false;        &#125;        return true;    &#125;    /**     * @Des 反射调用set; 返回true设置成功，返回false设置异常     * @Author yinkai     * @Date 2021/11/29 11:36     */    private static boolean setObjOnOrder(JgOriginalOrder order, String fieldName, String setObj, Map&lt;Integer, String&gt; allDataMap, Integer rowIndex, List&lt;Map&lt;Integer, String&gt;&gt; errObjList, String myAllField, Integer max) &#123;        Method method = ImportOrderByExcelListener.METHOD_MAP.get(fieldName);        if (ToolUtil.isEmpty(method)) &#123;            return true;        &#125;        /**         * 需要格式化的字段         */        boolean ok = ImportOrderByExcelListener.setObjExcute(order, fieldName, setObj, allDataMap, rowIndex, errObjList, myAllField, max, method);        if (ok) &#123;            return true;        &#125;        /**         *其它字段         */        ok = ImportOrderByExcelListener.invokeExecute(method, order, setObj, fieldName, allDataMap, rowIndex, errObjList, myAllField, max, fieldName);        return ok;    &#125;    /**     * @Des     * @Author yinkai     * @Date 2022/1/18 11:11     */    private static boolean setObjExcute(JgOriginalOrder order, String fieldName, String setObjStr, Map&lt;Integer, String&gt; allDataMap, Integer rowIndex, List&lt;Map&lt;Integer, String&gt;&gt; errObjList, String myAllField, Integer max, Method method) &#123;        if (ObjectUtil.contains(ImportOrderByExcelListener.CHAR_SEQUENCES, fieldName)) &#123;            /**             * 处理整数格式，返回结果为true直接return跳出，否则继续执行             */            return ImportOrderByExcelListener.isaBoolean(order, fieldName, Integer.parseInt(setObjStr), setObjStr, allDataMap, rowIndex, errObjList, myAllField, max, method);        &#125; else if (ObjectUtil.contains(ImportOrderByExcelListener.CHAR_SEQUENCES1, fieldName)) &#123;            /**             * 处理浮点格式，返回结果为true直接return跳出，否则继续执行             */            return ImportOrderByExcelListener.isaBoolean(order, fieldName, new BigDecimal(setObjStr), setObjStr, allDataMap, rowIndex, errObjList, myAllField, max, method);        &#125; else if (ObjectUtil.contains(ImportOrderByExcelListener.CHAR_SEQUENCES2, fieldName)) &#123;            /**             * 处理时间格式，返回结果为true直接return跳出，否则继续执行             */            return ImportOrderByExcelListener.isaBoolean(order, fieldName, com.gbm.cloud.common.util.DateUtil.parse(setObjStr), setObjStr, allDataMap, rowIndex, errObjList, myAllField, max, method);        &#125;        return false;    &#125;    private static boolean isaBoolean(JgOriginalOrder order, String fieldName, Object setObj, String setObjStr, Map&lt;Integer, String&gt; allDataMap, Integer rowIndex, List&lt;Map&lt;Integer, String&gt;&gt; errObjList, String myAllField, Integer max, Method method) &#123;        return ImportOrderByExcelListener.runExecute(() -&gt; ImportOrderByExcelListener.invokeExecute(method, order, setObj, fieldName, allDataMap, rowIndex, errObjList, myAllField, max, fieldName), rowIndex, errObjList, myAllField, max, fieldName, setObjStr, allDataMap);    &#125;</code></pre><p>###使用场景2：将方法作为参数传递</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>受查视图、不可修改视图、子范围.md</title>
      <link href="/2022/03/20/shou-cha-shi-tu-bu-ke-xiu-gai-shi-tu-zi-fan-wei/"/>
      <url>/2022/03/20/shou-cha-shi-tu-bu-ke-xiu-gai-shi-tu-zi-fan-wei/</url>
      
        <content type="html"><![CDATA[<p>###受查视图</p><p>这样的泛型约束是失效的   </p><pre><code> List&lt;String&gt; list = new ArrayList&lt;&gt;(); List stList = list; //添加成功 stList.add(new Date());</code></pre><p>那应该如何保证赋值之后的集合仍然被泛型约束？<br>使用Collections.checkedList包装一下</p><pre><code>  List&lt;String&gt; list = new ArrayList&lt;&gt;();  List stList = Collections.checkedList(list,String.class);  // Attempt to insert class java.util.Date element into collection with element type class java.lang.String  stList.add(new Date());</code></pre><p>###不可修改视图<br>不希望集合被修改</p><pre><code>    List&lt;String&gt; list = new ArrayList&lt;&gt;();    List&lt;String&gt; strings = Collections.unmodifiableList(list);    //java.lang.UnsupportedOperationException    strings.add(&quot;123&quot;);</code></pre><p>###子范围<br>父子互相影响<br>        List<String> list = new ArrayList&lt;&gt;();<br>        list.add(“123”);<br>        List<String> strings = list.subList(0, 1);</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在一个静态方法内调用一个非静态成员为什么是非法的-.md</title>
      <link href="/2022/03/20/zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de/"/>
      <url>/2022/03/20/zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de/</url>
      
        <content type="html"><![CDATA[<p>这个需要结合 JVM 的相关知识，静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在何种情况下，Future-get()抛出ExecutionException或InterruptedException？.md</title>
      <link href="/2022/03/20/zai-he-chong-qing-kuang-xia-future-get-pao-chu-executionexception-huo-interruptedexception/"/>
      <url>/2022/03/20/zai-he-chong-qing-kuang-xia-future-get-pao-chu-executionexception-huo-interruptedexception/</url>
      
        <content type="html"><![CDATA[<p>ExecutionException和InterruptedException是两个非常不同的事情。</p><p>ExecutionException封装了正在执行的线程抛出的任何异常，所以如果你的线程是做某种IO导致抛出IOException异常的，那么它会被包装在一个ExecutionException中并被重新抛出。</p><p>InterruptedException不是任何出错的迹象。在那里给你一种让你的线程知道什么时候停止的方法，以便他们完成当前的工作并优雅地退出。假设我希望我的应用程序停止运行，但我不希望我的线程放弃他们正在做的事情（这是如果我让它们守护进程线程会发生什么）。因此，当应用程序正在关闭时，我的代码会在这些线程上调用中断方法，这些线程会在中断标志上设置中断标志，并在下一次线程处于等待或休眠状态时检查中断标志并引发InterruptedException，我可以使用它从线程参与的无限循环处理/休眠逻辑中解脱出来（如果线程不等待或休眠，它可以定期检查中断标志。）因此，它是一个用于更改逻辑流程的异常实例。记录它的唯一原因是在一个示例程序中向您展示发生了什么，或者如果您正在调试中断逻辑无法正常工作的问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坑-List的remove(Object-o-)-只是删除第一个匹配的元素.md</title>
      <link href="/2022/03/20/keng-list-de-remove-object-o-zhi-shi-shan-chu-di-yi-ge-pi-pei-de-yuan-su/"/>
      <url>/2022/03/20/keng-list-de-remove-object-o-zhi-shi-shan-chu-di-yi-ge-pi-pei-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>不是我们想象的那样删除所有的指定元素。如果想删除所有指定元素。请使用removeAll</p><pre><code>        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;abc&quot;);        list.add(&quot;def&quot;);        list.add(&quot;def&quot;);        list.remove(&quot;def&quot;);        //[abc, abc, def]        System.out.println(list);</code></pre><p>removeAll</p><pre><code>        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;abc&quot;);        list.add(&quot;def&quot;);        list.add(&quot;def&quot;);        list.removeAll(Collections.singleton(&quot;def&quot;));        //[abc, abc]        System.out.println(list);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型与包装数据类型的使用标准.md</title>
      <link href="/2022/03/20/ji-ben-shu-ju-lei-xing-yu-bao-zhuang-shu-ju-lei-xing-de-shi-yong-biao-zhun/"/>
      <url>/2022/03/20/ji-ben-shu-ju-lei-xing-yu-bao-zhuang-shu-ju-lei-xing-de-shi-yong-biao-zhun/</url>
      
        <content type="html"><![CDATA[<p>Reference:《阿里巴巴Java开发手册》</p><blockquote><p>【强制】所有的 POJO 类属性必须使用包装数据类型。<br>【强制】RPC 方法的返回值和参数必须使用包装数据类型。<br>【推荐】所有的局部变量使用基本数据类型。</p></blockquote><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p><p>说明 :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p>正例 : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p>反例 : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坑-滥用-File-deleteOnExit()内存泄露.md</title>
      <link href="/2022/03/20/keng-lan-yong-file-deleteonexit-nei-cun-xie-lu/"/>
      <url>/2022/03/20/keng-lan-yong-file-deleteonexit-nei-cun-xie-lu/</url>
      
        <content type="html"><![CDATA[<p>对不经常使用的黑盒api一定不能直接使用。最好去看下文档说明和使用注意。甚至是源码。<br>如果在使用delete的场景下用错了File.deleteOnExit()可以导致内存溢出宕机的生产事故！<br>这个方法如果只看字面意思很容易将它理解为：删除仅仅存在的文件，其实并不是这样的！如果要实现存在就删除，那么普通的File.delete()就可以做到。<br>###File.deleteOnExit() 导致内存泄露</p><pre><code>/**     * Requests that the file or directory denoted by this abstract     * pathname be deleted when the virtual machine terminates **虚拟机终止时删除路径名**.     * Files (or directories) are deleted in the reverse order that     * they are registered. Invoking this method to delete a file or     * directory that is already registered for deletion has no effect.     * Deletion will be attempted only for normal termination of the     * virtual machine, as defined by the Java Language Specification.     *     * &lt;p&gt; Once deletion has been requested, it is not possible to cancel the     * request.  This method should therefore be used with care**这种方法应该谨慎使用** .     *     * &lt;P&gt;     * Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as     * the resulting protocol cannot be made to work reliably. The     * &#123;@link java.nio.channels.FileLock FileLock&#125;     * facility should be used instead.     *     * @throws  SecurityException     *          If a security manager exists and its &lt;code&gt;&#123;@link     *          java.lang.SecurityManager#checkDelete&#125;&lt;/code&gt; method denies     *          delete access to the file     *     * @see #delete     *     * @since 1.2     */    public void deleteOnExit() &#123;        SecurityManager security = System.getSecurityManager();        if (security != null) &#123;            security.checkDelete(path);        &#125;        if (isInvalid()) &#123;            return;        &#125;        DeleteOnExitHook.add(path);    &#125;</code></pre><p>问题定位于 File.deleteOnExit() 方法的调用，导致内存泄漏。调用该方法只会将需要删除文件的路径，维护在类 DeleteOnExit 的一个 LinkedHashSet 中，在 JVM 关闭时，才会去真正执行删除文件操作。<br>这样导致 DeleteOnExitHook 这个对象越来越大，最终内存溢出。<br>File.delete() 与 File.deleteOnExit() 的区别：<br>当调用 delete() 方法时，直接删除文件，不管该文件是否存在，一经调用立即执行。</p><p>###那么这两种写法：的区别在哪？</p><p>1、if(file.exists()) file.deleteOnExit();<br>2、if(file.exists()) file.delete();</p><p>当调用delete()方法时，直接删除文件，不管该文件是否存在，一经调用立即执行；</p><p>当调用 deleteOnExit() 方法时，只是相当于对 deleteOnExit() 作一个声明，当程序运行结束，JVM 终止时才真正调用 deleteOnExit() 方法实现删除操作。</p><p>###File.deleteOnExit()场景<br>大概意思是在删除文件使用 File.deleteOnExit() 方法时，并不是立刻删除文件，而是将该文件路径维护在类 DeleteOnExit 的一个 LinkedHashSet 中，最后在 JVM 关闭的时候，才会去删除这里面的文件，这个方法不能用于长时间运行的服务。</p><p>程序有个需求需要创建临时文件，这个临时文件可能作为存储使用，但是程序运行结束后，这个文件应该就被删除了。在哪里做删除操作呢，需要监控程序关闭吗，如果有很多地方可以中止程序，这个删除操作需要都放置一份吗？其实只要这么写,程序结束后文件就会被自动删除了：</p><p>  File file=File.createTempFile(“tmp”,null);<br>  //这里对文件进行操作<br>  file.deleteOnExit();</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全优雅的使用SimpleDateFormat类处理时间.md</title>
      <link href="/2022/03/20/an-quan-you-ya-de-shi-yong-simpledateformat-lei-chu-li-shi-jian/"/>
      <url>/2022/03/20/an-quan-you-ya-de-shi-yong-simpledateformat-lei-chu-li-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>SimpleDateFormat是线程不安全的！所以不能因为想要公用一个实例而选择使用单例。</p><p>我们可以配合使用ThreadLocal来达到这个效果。</p><pre><code>package org.szwj.ca.identityauthsrv.util.common;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.Objects;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 日期工具类 * * @author yang.Liu * @see java.util.Map * @see java.text.DateFormat * @see java.lang.ThreadLocal * @see java.text.SimpleDateFormat */public class DateUtils &#123;    private static final Logger log = LoggerFactory.getLogger(DateUtils.class);    private DateUtils() &#123;    &#125;    /**     * Date转为字符串日期     *     * @param date       日期     * @param dateFormat 日期格式     */    public static String format(Date date, DateFormatEnum dateFormat) &#123;        return getDateFormat(dateFormat).format(date);    &#125;    /**     * Date转为默认字符串日期     *     * @param date 日期     */    public static String format(Date date) &#123;        return format(date, DateFormatEnum.DEFAULT_FORMAT);    &#125;    /**     * 字符串日期转为Date     *     * @param strDate 字符串日期     */    public static Date parse(String strDate) &#123;        return parse(strDate, DateFormatEnum.DEFAULT_FORMAT);    &#125;    /**     * 字符串日期转为Date     *     * @param strDate    字符串日期     * @param dateFormat 日期格式     */    public static Date parse(String strDate, DateFormatEnum dateFormat) &#123;        try &#123;            return getDateFormat(dateFormat).parse(strDate);        &#125; catch (ParseException e) &#123;            log.error(&quot;字符串日期转为Date异常&quot;, e);            return null;        &#125;    &#125;    /**     * Thread线程变量 + Map | 缓存 日期格式(K)，SimpleDateFormat(V)，提高效率     *     * @param dateFormat &#123;@link DateFormatEnum&#125; &#123;@link #TL()&#125;     */    private static DateFormat getDateFormat(DateFormatEnum dateFormat) &#123;        ThreadLocal&lt;Map&lt;DateFormatEnum, DateFormat&gt;&gt; TL = TL();        Map&lt;DateFormatEnum, DateFormat&gt; map = TL.get();        if (Objects.isNull(map)) &#123;            map = new HashMap&lt;&gt;();            TL.set(map);        &#125;        if (Objects.isNull(dateFormat)) &#123;            dateFormat = DateFormatEnum.DEFAULT_FORMAT;        &#125;        DateFormat ret = map.get(dateFormat);        if (Objects.isNull(ret)) &#123;            ret = new SimpleDateFormat(dateFormat.dateFormat);            map.put(dateFormat, ret);        &#125;        return ret;    &#125;    /**     * 时间格式化枚举，由于可读性，枚举对象声明未遵循常量大写规范～     */    public enum DateFormatEnum &#123;        DEFAULT_FORMAT(&quot;yyyy-MM-dd HH:mm:ss&quot;),        yyyy_MM_dd(&quot;yyyy-MM-dd&quot;),        yyyy(&quot;yyyy&quot;),        MM(&quot;MM&quot;),        dd(&quot;dd&quot;),        HH_mm_ss(&quot;HH:mm:ss&quot;),        HH(&quot;HH&quot;),        mm(&quot;mm&quot;),        ss(&quot;ss&quot;),        SSS(&quot;SSS&quot;),        yyyyMMddHHmmss(&quot;yyyyMMddHHmmss&quot;),        yyyy_MM_dd__HH_mm_ss__SSS(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;),        yyyyMMddHHmmssSSS(&quot;yyyyMMddHHmmssSSS&quot;),        ;        private final String dateFormat;        DateFormatEnum(String dateFormat) &#123;            this.dateFormat = dateFormat;        &#125;    &#125;    /**     * 静态内部类声明单例Thread线程变量     */    private static class SingletonHolder &#123;        private static final ThreadLocal&lt;Map&lt;DateFormatEnum, DateFormat&gt;&gt; TL = new ThreadLocal&lt;&gt;();    &#125;    /**     * 初始化调用     */    private static ThreadLocal&lt;Map&lt;DateFormatEnum, DateFormat&gt;&gt; TL() &#123;        return SingletonHolder.TL;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将大list分为包含100元素的小list.md</title>
      <link href="/2022/03/20/jiang-da-list-fen-wei-bao-han-100-yuan-su-de-xiao-list/"/>
      <url>/2022/03/20/jiang-da-list-fen-wei-bao-han-100-yuan-su-de-xiao-list/</url>
      
        <content type="html"><![CDATA[<pre><code>    @CacheEvict(value = &quot;HomeDeliveryExtension&quot;,key = &quot;#customIds&quot;, allEntries = false)    @Override    public void saveHomeDeliveryExtension(List&lt;HomeDeliveryExtension&gt; list,String customIds) &#123;        int listSize = list.size();        int listNumber = listSize / 2;        List&lt;List&lt;HomeDeliveryExtension&gt;&gt; allList = ListUtils.partition(list, listNumber==0?1:listNumber);        for (List&lt;HomeDeliveryExtension&gt; homeDeliveryExtensionList : allList) &#123;            if (CollectionUtils.isNotEmpty(homeDeliveryExtensionList)) &#123;                homeDeliveryExtensionDao.saveHomeDeliveryExtension(homeDeliveryExtensionList);            &#125;        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化.md</title>
      <link href="/2022/03/20/xu-lie-hua/"/>
      <url>/2022/03/20/xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/9dragon/p/10901448.html#h15">https://www.cnblogs.com/9dragon/p/10901448.html#h15</a></p><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li>  <strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li>  <strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>维基百科是如是介绍序列化的：</p><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-d8fbf364df51d70b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><a href="https://www.corejavaguru.com/java/serialization/interview-questions-1">https://www.corejavaguru.com/java/serialization/interview-questions-1</a></p><h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%8E%E4%B9%88%E5%8A%9E"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p><code>对于不想进行序列化的变量，使用</code>transient<code>关键字修饰。</code></p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。<code>transient</code> 只能修饰变量，不能修饰类和方法。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类可以实现接口，抽象类可以继承实体类.md</title>
      <link href="/2022/03/20/chou-xiang-lei-ke-yi-shi-xian-jie-kou-chou-xiang-lei-ke-yi-ji-cheng-shi-ti-lei/"/>
      <url>/2022/03/20/chou-xiang-lei-ke-yi-shi-xian-jie-kou-chou-xiang-lei-ke-yi-ji-cheng-shi-ti-lei/</url>
      
        <content type="html"><![CDATA[<p>抽象类可以实现接口：抽象类实现接口，可以不实现接口的方法。</p><pre><code>interface  Inter &#123;    void print();&#125;abstract class GG implements  Inter&#123;   abstract  void myFunction();&#125;abstract class HH extends GG&#123;&#125;class JJ extends HH &#123;    @Override    public void print() &#123;        System.out.println(&quot;接口方法&quot;);    &#125;    @Override    void myFunction() &#123;        System.out.println(&quot;抽象类方法&quot;);    &#125;    &#125;abstract class KK extends  JJ&#123;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员变量与局部变量的区别有哪些？.md</title>
      <link href="/2022/03/20/cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie/"/>
      <url>/2022/03/20/cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie/</url>
      
        <content type="html"><![CDATA[<p>1、从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p><p>2、从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p>3、从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p><p>4、从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰的官方网站.md</title>
      <link href="/2022/03/20/liao-xue-feng-de-guan-fang-wang-zhan/"/>
      <url>/2022/03/20/liao-xue-feng-de-guan-fang-wang-zhan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究下集合类指定初始容量的必要性.md</title>
      <link href="/2022/03/20/tan-jiu-xia-ji-he-lei-zhi-ding-chu-shi-rong-liang-de-bi-yao-xing/"/>
      <url>/2022/03/20/tan-jiu-xia-ji-he-lei-zhi-ding-chu-shi-rong-liang-de-bi-yao-xing/</url>
      
        <content type="html"><![CDATA[<p>以ArrayList为例，对比下指定初始容量和不指定两种情况对List.add性能的影响</p><pre><code>        /**         * 指定初始容量后：耗时 1030         */        ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();        final int N = 10000000;        list = new ArrayList&lt;Object&gt;(N);        long startTime1 = System.currentTimeMillis();        for (int i = 0; i &lt; N; i++) &#123;            list.add(i);        &#125;        long endTime1 = System.currentTimeMillis();        System.out.println(&quot;指定初始容量后：&quot; + (endTime1 - startTime1));</code></pre><pre><code>    /**         * 不指定容量：耗时 1432         */        ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();        final int N = 10000000;        list = new ArrayList&lt;Object&gt;();        long startTime1 = System.currentTimeMillis();        for (int i = 0; i &lt; N; i++) &#123;            list.add(i);        &#125;        long endTime1 = System.currentTimeMillis();        System.out.println(&quot;不指定容量：&quot; + (endTime1 - startTime1));</code></pre><blockquote><p>指定容量的List做add操作明显比不指定的快。</p></blockquote><p>###ensureCapacity方法</p><p>如果List的初始化不是自己掌握的，那么我们在add大量数据之前可以调用 list.ensureCapacity(N); 以减少增量重新分配的次数，提升List的add性能。</p><p>ArrayList.ensureCapacity 源码如下: </p><pre><code>    public void ensureCapacity(int minCapacity) &#123;        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)            // any size if not default element table            ? 0            // larger than default for default empty table. It&#39;s already            // supposed to be at default size.            : DEFAULT_CAPACITY;        if (minCapacity &gt; minExpand) &#123;            ensureExplicitCapacity(minCapacity);        &#125;    &#125;</code></pre><p>下面进行ensureCapacity测试</p><pre><code>        /**         * 不使用 ensureCapacity耗时 1916         */        ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();        final int N = 10000000;        long startTime = System.currentTimeMillis();        for (int i = 0; i &lt; N; i++) &#123;            list.add(i);        &#125;        long endTime = System.currentTimeMillis();        System.out.println(&quot;不使用ensureCapacity：&quot;+(endTime - startTime));</code></pre><pre><code>        /**         * 使用 ensureCapacity 耗时 1089         */        ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();        final int N = 10000000;        list = new ArrayList&lt;Object&gt;();        long startTime1 = System.currentTimeMillis();        list.ensureCapacity(N);        for (int i = 0; i &lt; N; i++) &#123;            list.add(i);        &#125;        long endTime1 = System.currentTimeMillis();        System.out.println(&quot;使用ensureCapacity方法后：&quot; + (endTime1 - startTime1));</code></pre><blockquote><p>答案显而易见</p></blockquote><p>何况，阿里手册上也有相关信息：</p><blockquote><p>【推荐】集合初始化时，指定集合初始值大小。<br>说明：HashMap 使用 HashMap(int initialCapacity) 初始化。<br>正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认<br>为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。<br>反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被<br>迫扩大，resize 需要重建 hash 表，严重影响性能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法延迟执行.md</title>
      <link href="/2022/03/20/fang-fa-yan-chi-zhi-xing/"/>
      <url>/2022/03/20/fang-fa-yan-chi-zhi-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造方法有哪些特点？是否可被-override-.md</title>
      <link href="/2022/03/20/gou-zao-fang-fa-you-na-xie-te-dian-shi-fou-ke-bei-override/"/>
      <url>/2022/03/20/gou-zao-fang-fa-you-na-xie-te-dian-shi-fou-ke-bei-override/</url>
      
        <content type="html"><![CDATA[<p>特点：</p><p>名字与类名相同。<br>没有返回值，但不能用 void 声明构造函数。<br>生成类的对象时自动执行，无需调用。<br>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正确使用-equals-方法.md</title>
      <link href="/2022/03/20/zheng-que-shi-yong-equals-fang-fa/"/>
      <url>/2022/03/20/zheng-que-shi-yong-equals-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>正确使用 equals 方法 Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。  举个例子：</p><p>  // 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常<br>String str = null; if (str.equals(“SnailClimb”)) {   … } else {   .. }<br>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><p>  “SnailClimb”.equals(str);// false  </p><p>不过更推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。 </p><pre><code> Objects.equals(null,&quot;SnailClimb&quot;);</code></pre><p>// false 我们看一下java.util.Objects#equals的源码就知道原因了。<br> public static boolean equals(Object a, Object b) {<br>  // 可以避免空指针异常。如果a=null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。<br> return (a == b) || (a != null &amp;&amp; a.equals(b));<br> } </p><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>  每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>  可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>  不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型边界.md</title>
      <link href="/2022/03/20/fan-xing-bian-jie/"/>
      <url>/2022/03/20/fan-xing-bian-jie/</url>
      
        <content type="html"><![CDATA[<p>###List list = new ArrayList(); 能添加各种类型的数据吗？</p><p>可以的，JDK1.5后随着泛型的加入，默认这也是一种泛型，叫raw type，由于它不限制存入的类型，所以能存任何类型的元素。大家其实可以把它当做JDK1.5以前的List，那时的List能指向任意类型的List，啥都能存。</p><p>###List<Object> list = new Array<Integer>()会报错吗？为什么？</p><p>会，因为这是一种简单泛型，强制左右两边一致。假设这种语法通过了，那么程序员就可以通过List<Object>往List<Integer>存入各种乱七八糟的元素，破坏了约束，同时取出时转型也会出问题。</p><p>###什么时候用 ? extends 又什么时候用 ？super</p><p>从两个维度考虑：1.指向范围 2.存取。</p><p><code>?</code>指向范围无限制，但完全无法存入元素，且取出的类型是Object。<br>如果你想编写一个通用方法接收List，那么使用List&lt;?&gt;会导致你接收参数后除了遍历元素外，无法往里插入元素（删除或许可以），且取出的元素是Object类型，意味着你无法调用元素的特有方法，只能使用Object的equals()等。</p><p>####上界<br><code>extends</code>允许指向子类型List，这一点可以用来控制入参类型。extends禁止往List存入任何元素，但取出的元素可以转为边界类型，此时可以调用边界类型的方法操作元素，比如List<Integer>、List<Long>传进来后，我仍然可以使用Number的方法，而不是干巴巴的几个Object的方法。</p><pre><code>class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Plate&lt;T&gt; &#123;    private T item;    public Plate(T t) &#123;        item = t;    &#125;    public void set(T t) &#123;        item = t;    &#125;    public T get() &#123;        return item;    &#125;&#125;class Main() &#123;    public static void main(String[] args) &#123;        /**         * 所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。         * 为了让泛型用起来更舒服，Sun的大脑袋们就想出了&lt;? extends T&gt;和&lt;? super T&gt;的办法，来让”水果盘子“和”苹果盘子“之间发生关系         */        //即使Apple是Fruit的子类，编译也不通过        Plate&lt;Fruit&gt; p = new Plate&lt;Apple&gt;(new Apple());  //Error        //使用? extends这样就行了        Plate&lt;? extends Fruit&gt; p = new Plate&lt;Apple&gt;(new Apple());        p.set(new Fruit());    //Error        p.set(new Apple());    //Error        Fruit newFruit1 = p.get();        Object newFruit2 = p.get();        Apple newFruit3 = p.get();    //Error    &#125;&#125;</code></pre><p>####下界<br><code>super</code>允许指向父类型List，也可以用来控制入参类型。super允许存入边界类型及其子类型元素，但取出来是Object，无法调用特定方法。</p><pre><code>    public static void main(String[] args) &#123;        Plate&lt;? super Fruit&gt; p = new Plate&lt;Fruit&gt;(new Fruit());        p.set(new Fruit());        p.set(new Apple());        Apple newFruit3 = p.get();    //Error        Fruit newFruit1 = p.get();    //Error    &#125;</code></pre><p>###PECS是什么？<br>编写一个通用方法时，如果要用通配符，应该考虑存入还是取出操作，如果有存入则使用super，如果有取出最好使用extends，因为它的返回值类型不是Object，稍微明确些。<br>存入和读取，有点像消费者和生产者，所以被称为PECS(Producer Extends Consumer Super)</p><p>###List&lt;?&gt;和List<Object>的区别？</p><p>指向性：List<?>指向任意类型List，而List<Object>是简单泛型，只能指向List<Object>存取：List<?>不能存任何东西，List<Object>可以存任何东西，但取出来都是Object</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较的坑所有荟萃.md</title>
      <link href="/2022/03/20/bi-jiao-de-keng-suo-you-hui-cui/"/>
      <url>/2022/03/20/bi-jiao-de-keng-suo-you-hui-cui/</url>
      
        <content type="html"><![CDATA[<pre><code>    public static void main(String[] args) &#123;        String a =&quot;abc&quot;;        String b =&quot;ab&quot;+&quot;c&quot;;//虚拟机会把&quot;ab&quot;+&quot;c&quot;直接看做&quot;abc&quot;        //true        System.out.println(a==b);        String a =&quot;abc&quot;;        String b =&quot;ab&quot;+new String(&quot;c&quot;);        //false        System.out.println(a==b);        Integer a = 128;        Integer b = 128;        false        System.out.println(a==b);        Integer a = 127;        Integer b = 127;        true        System.out.println(a==b);        工作中禁止使用float、double计算和比较        Double a = 1.0;        Double b = 1.0;        //true        System.out.println(a.equals(b));        //false        System.out.println(a ==b);        类型不同不可直接比较，需要转换再比        Integer a =1;        Long b =1l;        //false equals也会错，错误，类型不同        System.out.println(a.equals(b));        //不可比较，java: 不可比较的类型: java.lang.Integer和java.lang.Long        System.out.println(a==b);        //强转        long a = 1L;        Integer b = null;        //拆箱空指针        System.out.println(a == b);        BigDecimal a = new BigDecimal( &quot;0.1&quot;);        BigDecimal b = new BigDecimal( &quot;0.10&quot;);        //false        System.out.println(a==b);        //false equals也会错        System.out.println(a.equals(b));        //true 正确，BigDecimal用compareTo比较        System.out.println(a.compareTo(b));    &#125;</code></pre><p>源码</p><pre><code>    public static String toss(String a, String b) &#123;        return  a + b;    &#125;    public static void main(String[] args) &#123;        String toss = toss(&quot;111&quot;, &quot;222&quot;);        //true        System.out.println(&quot;111222&quot; == toss);        //true        System.out.println(&quot;111222&quot; == &quot;111&quot; + &quot;222&quot;);    &#125;</code></pre><p>编译后</p><pre><code>    public static String toss(String a, String b) &#123;        return a + b;    &#125;    public static void main(String[] args) &#123;        String toss = toss(&quot;111&quot;, &quot;222&quot;);        System.out.println(&quot;111222&quot; == toss);        //编译时就知道是true了        System.out.println(true);    &#125;</code></pre><p>再来看。字符串常量直接相加和用变量相加是有区别的。</p><ul><li>常量直接相加，存在编译器优化</li><li>变量相加不会加入到常量池</li></ul><pre><code>   String str1 = &quot;a&quot;;        String str2 = &quot;b&quot;;        String str3 = str1 + str2;        String str4 = &quot;ab&quot;;        //false        System.out.println(str3 == str4);        //true        System.out.println( &quot;ab&quot; == &quot;a&quot;+&quot;b&quot;);</code></pre><p>加入intern</p><p>在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。</p><pre><code>        String str1 = &quot;a&quot;;        String str2 = &quot;b&quot;;        String str3 = &quot;ab&quot;;        String str4 = str1 + str2;        String str5 = new String(&quot;ab&quot;);        //true        System.out.println(str5.equals(str3));        //false        System.out.println(str5 == str3);        //true        System.out.println(str5.intern() == str3);        //false，这个是易错点        System.out.println(str5.intern() == str4);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用-equals-来判断！！.md</title>
      <link href="/2022/03/20/fu-dian-shu-zhi-jian-de-deng-zhi-pan-duan-ji-ben-shu-ju-lei-xing-bu-neng-yong-lai-bi-jiao-bao-zhuang-shu-ju-lei-xing-bu-neng-yong-equals-lai-pan-duan/"/>
      <url>/2022/03/20/fu-dian-shu-zhi-jian-de-deng-zhi-pan-duan-ji-ben-shu-ju-lei-xing-bu-neng-yong-lai-bi-jiao-bao-zhuang-shu-ju-lei-xing-bu-neng-yong-equals-lai-pan-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><h3 id="BigDecimal-的用处"><a href="#BigDecimal-的用处" class="headerlink" title="BigDecimal 的用处"></a>BigDecimal 的用处</h3><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><pre><code>        float a = 1.0f - 0.9f;        float b = 0.9f - 0.8f;        System.out.println(a);        System.out.println(b);        // false        System.out.println(a == b);        System.out.println(a == b);        Float c = 1.0f - 0.9f;        Float d = 0.9f - 0.8f;        System.out.println(c);        System.out.println(d);        //false        System.out.println(Objects.equals(c,d));</code></pre><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><pre><code>BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);BigDecimal c = new BigDecimal(&quot;0.8&quot;);BigDecimal x = a.subtract(b); BigDecimal y = b.subtract(c); System.out.println(x); /* 0.1 */System.out.println(y); /* 0.1 */System.out.println(Objects.equals(x, y)); /* true */</code></pre><h3 id="BigDecimal-的大小比较"><a href="#BigDecimal-的大小比较" class="headerlink" title="BigDecimal 的大小比较"></a>BigDecimal 的大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p><pre><code>BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);System.out.println(a.compareTo(b));// 1</code></pre><h3 id="BigDecimal-保留几位小数"><a href="#BigDecimal-保留几位小数" class="headerlink" title="BigDecimal 保留几位小数"></a>BigDecimal 保留几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><pre><code>BigDecimal m = new BigDecimal(&quot;1.255433&quot;);BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);System.out.println(n);// 1.255&lt;/pre&gt;</code></pre><h3 id="BigDecimal-的使用注意事项"><a href="#BigDecimal-的使用注意事项" class="headerlink" title="BigDecimal 的使用注意事项"></a>BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-56ca015bd1d3ebf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p><pre><code>        //0.1000000000000000055511151231257827021181583404541015625        System.out.println(new BigDecimal(0.1));        //0.1        System.out.println(new BigDecimal(&quot;0.1&quot;));        //0.1        System.out.println(BigDecimal.valueOf(0.1));</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁止在-finally-中使用return.md</title>
      <link href="/2022/03/20/jin-zhi-zai-finally-zhong-shi-yong-return/"/>
      <url>/2022/03/20/jin-zhi-zai-finally-zhong-shi-yong-return/</url>
      
        <content type="html"><![CDATA[<p>###禁止在 finally 中使用return<br>当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><pre><code>public class Test &#123;    public static int f(int value) &#123;        try &#123;            return value * value;        &#125; finally &#123;            if (value == 2) &#123;                return 0;            &#125;        &#125;    &#125;&#125;</code></pre><p>如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><p>###try-catch-finally详解<br>try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。<br>catch块： 用于处理 try 捕获到的异常。<br>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</p><p>###在以下 3 种特殊情况下，finally 块不会被执行：</p><p>首先，try没有执行，那么finally也不会执行</p><ul><li>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行。</li><li>程序所在的线程死亡。</li><li>关闭 CPU。<br>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190%E3%80%82">https://github.com/Snailclimb/JavaGuide/issues/190。</a></li></ul><p>####Throwable 类常用方法<br>public string getMessage():返回异常发生时的简要描述<br>public string toString():返回异常发生时的<code>详细信息</code><br>public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同<br>public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息</p><blockquote><p>请使用e.toString() 打印详细信息而不是 e.getMessage()。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>能用实体类就不要图方便用HashMap.md</title>
      <link href="/2022/03/20/neng-yong-shi-ti-lei-jiu-bu-yao-tu-fang-bian-yong-hashmap/"/>
      <url>/2022/03/20/neng-yong-shi-ti-lei-jiu-bu-yao-tu-fang-bian-yong-hashmap/</url>
      
        <content type="html"><![CDATA[<p>1、HashMap比起简单的实体类占用空间非常大</p><p>场景：100W行的大数据量查询，使用List<HashMap> 结构导致OOM</p><p>但这种方式只能解决燃眉之急，归根结底还是要看看到底是什么数据一次性占了 1.6 个 G！<br>仔细一看，List 里面装的都是 Map，每个 Map 表示数据库中的一行数据，总共 100 万行 15 列。<br>这，这不对吧，这些数据在数据库、Excel 文件里才不到 100 MB，咋变成 Map 直接膨胀了十几倍？<br>于是，我试着输出了一下 List<Map> 对象的大小，发现 105 行 * 10 列就占用了 155.9 KB！100万行的话真就 1.6 个 G 了！</p><p>那一刻，我突然想起了被八股文支配的恐惧，Java 的 HashMap 占用空间的确是很大的！每个 HashMap 对象包含 12 字节的 Java 对象头、4 个引用字段、3 个 int 型字段、1 个 float 字段，这些加起来是 44 字节。因为 JVM 要求对象内存大小必须是 8 字节的倍数，所以还要再补上 4 个字节，最终一个空的 HashMap 就占用了 48 字节。用它来存数据，可比其他格式的文件要大多了！</p><p>不过吃一堑长一智，下次再遇到类似问题（希望不会有下次），我应该就能很快解决啦。实践 + 翻车，印象真的太深刻了！所以建议大家在背八股文的同时，还是多多写代码做实验哦~</p><p>至于这个问题怎么解决。。那就别用 HashMap 呗！用 List + 下标来表示一行数据应该是可行的。当然，大家有更好的方案欢迎讨论~ </p><blockquote><p>使用 List<List> 代替List<Map></p></blockquote><p>2、视图层使用HashMap当参数接收可读性维护性也不好。方法栈占用空间也特别大。mybatis中请使用resultType、resultMap接收</p><p>3、数据库查询参数也不要用HashMap</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动装箱与拆箱.md</title>
      <link href="/2022/03/20/zi-dong-zhuang-xiang-yu-chai-xiang/"/>
      <url>/2022/03/20/zi-dong-zhuang-xiang-yu-chai-xiang/</url>
      
        <content type="html"><![CDATA[<p>自动装箱与拆箱<br>装箱：将基本类型用它们对应的引用类型包装起来；<br>拆箱：将包装类型转换为基本数据类型；<br>举例：</p><p>Integer i = 10;  //装箱<br>int n = i;   //拆箱<br>上面这两行代码对应的字节码为：</p><pre><code>   L1    LINENUMBER 8 L1    ALOAD 0    BIPUSH 10    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;   L2    LINENUMBER 9 L2    ALOAD 0    ALOAD 0    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;    INVOKEVIRTUAL java/lang/Integer.intValue ()I    PUTFIELD AutoBoxTest.n : I    RETURN</code></pre><p>从字节码中，我们发现装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。</p><p>因此，</p><p>Integer i = 10 等价于 Integer i = Integer.valueOf(10)<br>int n = i 等价于 int n = i.intValue();</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出流使用.md</title>
      <link href="/2022/03/20/shu-ru-shu-chu-liu-shi-yong/"/>
      <url>/2022/03/20/shu-ru-shu-chu-liu-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>使用输出流 FileOutputStream 写入文件</p><pre><code>      File file = new File(System.getProperty(&quot;user.dir&quot;).concat(&quot;/config/organizationId&quot;));        if (!file.exists()) &#123;            FileOutputStream fileOutputStream = null;            try &#123;                fileOutputStream = new FileOutputStream(file);                fileOutputStream.write(&quot;你哈珀&quot;.getBytes(&quot;UTF-8&quot;));            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125; finally &#123;                if (fileOutputStream != null) &#123;                    fileOutputStream.flush();                    fileOutputStream.close();                &#125;            &#125;        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法糖.md</title>
      <link href="/2022/03/20/yu-fa-tang/"/>
      <url>/2022/03/20/yu-fa-tang/</url>
      
        <content type="html"><![CDATA[<p>1、JSONObject 的fluentPut 链式put</p><pre><code>JSONObject res = new JSONObject()            .fluentPut(&quot;mode&quot;, ClusterStateManager.getMode())            .fluentPut(&quot;lastModified&quot;, ClusterStateManager.getLastModified())            .fluentPut(&quot;clientAvailable&quot;, isClusterClientSpiAvailable())            .fluentPut(&quot;serverAvailable&quot;, isClusterServerSpiAvailable());        return CommandResponse.ofSuccess(res.toJSONString());</code></pre><p>2、double brace initialization</p><pre><code>new ArrayList&lt;String&gt;0 &#123;&#123; add("Harry"); add("Tony"); &#125;&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载和重写的区别.md</title>
      <link href="/2022/03/20/chong-zai-he-chong-xie-de-qu-bie/"/>
      <url>/2022/03/20/chong-zai-he-chong-xie-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E9%87%8D%E8%BD%BD"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>下面是《Java 核心技术》对重载这个概念的介绍：</p><p><a href="https://camo.githubusercontent.com/5c7cc5e609bbb1f41c797f3445e380385ee1f67fad13f45190c5a0ecc662f172/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f62672f6465736b746f706a6176612545362541302542382545352542462538332545362538412538302545362539432541462d2545392538372538442545382542442542442e6a7067"><img src="https://upload-images.jianshu.io/upload_images/13965490-0296cdcc261a8cdc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a> </p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><h4 id="重写"><a href="#重写" class="headerlink" title="[]重写"></a>[]重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li> 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li> 如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li> 构造方法无法被重写</li></ol><p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p><p>暖心的 Guide 哥最后再来个图表总结一下！</p><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">发生范围</td><td align="left">同一个类</td><td align="left">子类</td></tr><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可修改</td><td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td align="left">异常</td><td align="left">可修改</td><td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td align="left">访问修饰符</td><td align="left">可修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td align="left">发生阶段</td><td align="left">编译期</td><td align="left">运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892</a> ）：</p><ul><li>  “两同”即方法名相同、形参列表相同；</li><li>  “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>  “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类</strong>型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><pre class="line-numbers language-source-java"><code class="language-source-java">public class Hero &#123;    public String name() &#123;        return "超级英雄";    &#125;&#125;public class SuperMan extends Hero&#123;    @Override    public String name() &#123;        return "超人";    &#125;    public Hero hero() &#123;        return new Hero();    &#125;&#125;public class SuperSuperMan extends SuperMan &#123;    public String name() &#123;        return "超级超级英雄";    &#125;    @Override    public SuperMan hero() &#123;        return new SuperMan();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问题：流一条路走到黑，怎么去拿开始的数据？.md</title>
      <link href="/2022/03/20/wen-ti-liu-yi-tiao-lu-zou-dao-hei-zen-me-qu-na-kai-shi-de-shu-ju/"/>
      <url>/2022/03/20/wen-ti-liu-yi-tiao-lu-zou-dao-hei-zen-me-qu-na-kai-shi-de-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>把下面的代码转成stream形式</p><pre><code>        Set&lt;String&gt; keySet = map.keySet();        for (String s : keySet) &#123;            String[] split1 = s.split(Constant.COLON);            String value = split1[Constant.NUMBER_ONE];            String[] split = value.split(Constant.COMMA);            if (ObjectUtil.contains(split, key)) &#123;                return s;            &#125;</code></pre><p>怎么回过头拿标记的m1？</p><pre><code>    private static String hasKey(Map&lt;String, JgRuleUnsuitableGoods&gt; map, String key) &#123;        //怎么拿m1？        String s1 = map.keySet().stream()                .flatMap(m1 -&gt; Arrays.stream(StringUtils.split(m1, Constant.COLON)))                .flatMap(m2 -&gt; Arrays.stream(StringUtils.split(m2, Constant.COMMA)))                .filter(m3 -&gt; Objects.equals(m3, key)).findFirst().orElse(null);        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象三大特征.md</title>
      <link href="/2022/03/20/mian-xiang-dui-xiang-san-da-te-zheng/"/>
      <url>/2022/03/20/mian-xiang-dui-xiang-san-da-te-zheng/</url>
      
        <content type="html"><![CDATA[<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><pre class="line-numbers language-source-java"><code class="language-source-java">public class Student &#123;    private int id;//id属性私有化    private String name;//name属性私有化    //获取id的方法    public int getId() &#123;        return id;    &#125;    //设置id的方法    public void setId(int id) &#123;        this.id = id;    &#125;    //获取name的方法    public String getName() &#123;        return name;    &#125;    //设置name的方法    public void setName(String name) &#123;        this.name = name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E7%BB%A7%E6%89%BF"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li> 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li> 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li> 子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E5%A4%9A%E6%80%81"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>  对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>  引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>  多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>  如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态方法和实例方法有何不同？.md</title>
      <link href="/2022/03/20/jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong/"/>
      <url>/2022/03/20/jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong/</url>
      
        <content type="html"><![CDATA[<p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码优雅.md</title>
      <link href="/2022/03/20/dai-ma-you-ya/"/>
      <url>/2022/03/20/dai-ma-you-ya/</url>
      
        <content type="html"><![CDATA[<p>###注释篇<br>好的注释一定是宁缺毋滥的</p><p>1、对于注释的要求：<br>第一、能够<code>准确</code>反映设计思想和代码逻辑；<br>第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作; <strong>注释写的意思有歧义、不明确还不如不写！</strong>好的注释一定可以准确的表达代码的含义！</p><p>1、<code>重要</code> 谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。<strong>如果无用，则删除。</strong><br>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，<br>难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。</p><p>2、好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。</p><pre><code>反例：// put elephant into fridge put(elephant, fridge);</code></pre><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释</p><p>3、【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1） 待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没<br>有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。<br>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）<br>在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况</p><p>4、代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑<br>等的修改。说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。</p><p>5、所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p><p>####注释得例子：<br>1、if条件注释写法</p><pre><code>    // IOS审核期间 &amp;&amp; 关键词被屏蔽    if (isIosAuditVersion &amp;&amp; matchForbiddenKeyword) &#123;        return true;    &#125;</code></pre><p>###命名篇<br>1、包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br>正例：应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的<br>框架结构）</p><p>2、常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME<br>反例：MAX_COUNT / EXPIRED_TIME</p><p>3、方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。<br>正例： localValue / getHttpMessage() / inputUserId</p><p>4、类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO /<br>PO / UID 等。<br>正例：ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion<br>反例：forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</p><p>5、所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式更要避免采用。<br>正例：ali / alibaba / taobao / cainiao/ aliyun/ youku / hangzhou 等国际通用的名称，可视同英文。<br>反例：DaZhePromotion [打折] / getPingfenByName() [评分] / String fw[福娃] / int 某变量 = 3</p><p>6、抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾</p><p>7、类型与中括号紧挨相连来表示数组。<br>正例：定义整形数组 int[] arrayDemo。<br>反例：在 main 参数中，使用 String args[]来定义。</p><p>8、POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。<br>说明：在本文 MySQL 规约中的建表约定第一条，表达是与否的变量采用 is_xxx 的命名方式，所以，需要<br>在<resultMap>设置从 is_xxx 到 xxx 的映射关系。<br>反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时<br>候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常</p><p>9、杜绝完全不规范的缩写，避免望文不知义。<br>反例：AbstractClass“缩写”成 AbsClass；condition“缩写”成 condi；Function 缩写”成 Fu，此类随意缩写严重降低了代码的可阅读性。</p><p>10、<code>重要</code> 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。<br>正例：对某个对象引用的 volatile 字段进行原子更新的类名为 AtomicReferenceFieldUpdater。<br>反例：常见的方法内变量为 int a;的定义方式。</p><p>11、在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。<br>正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT<br>反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD</p><p>12、接口类中的方法和属性<strong>不要加任何修饰符号（public 也不要加），保持代码的简洁性</strong>，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，确定<br>与接口方法相关，并且是整个应用的基础常量。<br>正例：接口方法签名 void commit();<br> 接口基础常量 String COMPANY = “alibaba”;<br>反例：接口方法定义 public abstract void f();<br>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。</p><p>13、枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON</p><p>14、各层命名规约：<br>A) Service/DAO 层方法命名规约<br>1） 获取单个对象的方法用 get 做前缀。<br>2） 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。 3） 获取统计值的方法用 count 做前缀。 4） 插入的方法用 save/insert 做前缀。<br>5） 删除的方法用 remove/delete 做前缀。<br>6） 修改的方法用 update 做前缀。</p><p>B) 领域模型命名规约<br>1） 数据对象：xxxDO，xxx 即为数据表名。<br>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>3） 展示对象：xxxVO，xxx 一般为网页名称。<br>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</p><p>###代码写法篇<br>1、 表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</p><pre><code>if (condition) &#123;  ... return obj; &#125;</code></pre><p>// 接着写 else 的业务逻辑代码;<br>说明：如果非使用 if()…else if()…else…方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。<br>正例：超过 3 层的 if-else 的逻辑判断代码可以使用<code>卫语句</code>、策略模式、状态模式等来实现，其中卫语句<br>示例如下：</p><pre><code>public void findBoyfriend (Man man) &#123; if (man.isUgly()) &#123; System.out.println(&quot;本姑娘是外貌协会的资深会员&quot;); return; &#125; if (man.isPoor()) &#123; System.out.println(&quot;贫贱夫妻百事哀&quot;); return; &#125; if (man.isBadTemper()) &#123; System.out.println(&quot;银河有多远，你就给我滚多远&quot;); return; &#125; System.out.println(&quot;可以先交往一段时间看看&quot;);&#125;</code></pre><p>2、除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复<br>杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。<br>说明：很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本<br>非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。<br>正例：</p><pre><code>// 伪代码如下final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);if (existed) &#123; ...&#125;</code></pre><p>反例：</p><pre><code>public final void acquire ( long arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123; selfInterrupt(); &#125;</code></pre><p>3、不要在其它表达式（尤其是条件表达式）中，插入赋值语句。</p><p>说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。<br>反例：</p><pre><code>public Lock getLock(boolean fair) &#123; // 算术表达式中出现赋值操作，容易忽略 count 值已经被改变 threshold = (count = Integer.MAX_VALUE) - 1; // 条件表达式中出现赋值操作，容易误认为是 sync==fair return (sync = fair) ? new FairSync() : new NonfairSync();&#125;</code></pre><p>4、避免采用取反逻辑运算符。<br>说明：取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。<br>正例：使用 if (x &lt; 628) 来表达 x 小于 628。<br>反例：使用 if (!(x &gt;= 628)) 来表达 x 小于 628。</p><p>7、构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p><p>8、<code>重要</code> POJO 类必须写 toString 方法。使用 IDE 中的工具：source&gt; generate toString<br>时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。<br>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p><p>10、变量声明和变量使用不能隔得太远<br>不知道大家有没有“变量焦虑”：当我看到一个变量被声明，却无法在5行以内找到它的使用时，我会感到焦虑。在上面的代码中，plusGrade代表用户等级，用于计算不同等级对应的佣金。但是，变量声明在第14行，使用却在第83行…这会造成至少两个困惑：第14行初见时我不知它将去往何处，第83行再见时我不知它来自何方，两次相见都只能默默流泪。</p><p>变量声明与变量使用隔得太远，是很多程序员的通病。这种不良的编码风格，不仅影响可读性，还可能造成性能浪费。比如：<br>public void method() {<br>    Integer plusGrade = memberProfileManager.getPlusGrade(loginUid);</p><pre><code>// 隔了80行...Long commission = caculateCms(originPrice, plusGrade);</code></pre><p>}<br>如果中间发生了异常，代码没有执行到caculateCms()，那么plusGrade的获取就毫无意义，白白浪费一次网络调用。所以，对于变量声明，不仅要见名知意，还要遵守“使用时再声明”，或者“声明后立即使用”。</p><p>11、像写诗一样换行</p><p>自从新文化运动以后，我们国家开始提倡白话文，为后面的扫盲打下了坚实的基础。现如今，普通人也能自己写诗了，唯一的诀窍就是：换行。<br>宝<br>今天我去输液了<br>输的什么液<br>想你的夜<br>换行的好处在于，通过在合适的地方切断信息流，让读者能快速理清行文逻辑。编写代码也是如此，有时只需简单地换行，就能大大地提高可读性。</p><pre><code>private List&lt;RebateItemDetailInfo.ShopScore&gt; getScoreList(ProductDetail productDetail) &#123;    // 描述    RebateItemDetailInfo.ShopScore descScore = new RebateItemDetailInfo.ShopScore();    descScore.setScore(formatScore(productDetail.getDescScore()));    descScore.setType(ShopScoreTypeEnum.DESC.getType());    // 服务    RebateItemDetailInfo.ShopScore serviceScore = new RebateItemDetailInfo.ShopScore();    serviceScore.setScore(formatScore(productDetail.getServiceScore()));    serviceScore.setType(ShopScoreTypeEnum.SERVICE.getType());    // 物流    RebateItemDetailInfo.ShopScore shipScore = new RebateItemDetailInfo.ShopScore();    shipScore.setScore(formatScore(productDetail.getShipScore()));    shipScore.setType(ShopScoreTypeEnum.SHIP.getType());    return Lists.newArrayList(descScore, serviceScore, shipScore);&#125;</code></pre><p>哦，对了，刚才那个plusGrade的代码，之所以读起来那么痛苦，其中一个原因就是没换行，甚至一点注释都没有…整个方法只有一个信息流，太大块了！如果想要临时去改一些逻辑，不得不从头到尾理解每个细节，有种你明明不想吃屎，却被强行按着头吃了一口屎的感觉，难受至极。</p><p>好的代码，应该可以让阅读它的人立即找到他关心的逻辑，而不是强迫对方去关注无关紧要的细节。</p><p>看到这，扪心自问，你写的代码像诗呢，还是像屎呢…</p><p>13、尽量不要修改公用逻辑。如springboot的入口main方法里面。<br>我加了个缓存和代理注解，其他同时pull下来时运行不了。这对人的印象不好，不成熟的功能不要提交。</p><blockquote><p>使用别的影响较小方案代替吧。以局部修改代替整体修改。</p></blockquote><p>15、filter和forEach是可以拆开的</p><p>拆开前</p><pre><code>        for (Integer key : keySet) &#123;            String value = data.get(key);            if (ToolUtil.isEmpty(value)) &#123;                continue;            &#125;            String fieldName = fieldMap.get(key);            if (ToolUtil.isEmpty(fieldName)) &#123;                continue;            &#125;            //反射调用set            ImportOrderByExcelListener.setObjOnOrder(jgOriginalOrder, fieldName, value);        &#125;</code></pre><p>拆开后</p><pre><code>    //反射调用set        keySet.parallelStream().filter(key -&gt; ToolUtil.isNotEmptyAll(data.get(key), fieldMap.get(key))).forEach(key -&gt;                ImportOrderByExcelListener.setObjOnOrder(jgOriginalOrder, fieldMap.get(key), data.get(key)));</code></pre><p>18、异常处理可以同事catch掉多个异常<br>正例：</p><pre><code>      try &#123;            method.invoke(order, setObj);        &#125; catch (IllegalAccessException  | InvocationTargetException e) &#123;            ImportOrderByExcelListener.log.error(ImportOrderByExcelListener.INVOKE_ERR_MSG, method.getName(), setObj);            return true;        &#125; </code></pre><p>反例：</p><pre><code>  try &#123;            method.invoke(order, setObj);        &#125; catch (IllegalAccessException e) &#123;            ImportOrderByExcelListener.log.error(ImportOrderByExcelListener.INVOKE_ERR_MSG, method.getName(), setObj);            return true;        &#125; catch (InvocationTargetException e) &#123;            ImportOrderByExcelListener.log.error(ImportOrderByExcelListener.INVOKE_ERR_MSG, method.getName(), setObj);            return true;        &#125;</code></pre><p>19、Map的为空赋值操作简化<br>computeIfAbsent</p><pre><code>// java8之前。从map中根据key获取value操作可能会有下面的操作Object key = map.get(&quot;key&quot;);if (key == null) &#123;    key = new Object();    map.put(&quot;key&quot;, key);&#125;</code></pre><pre><code>// java8之后。上面的操作可以简化为一行，若key对应的value为空，会将第二个参数的返回值存入并返回Object key2 = map.computeIfAbsent(&quot;key&quot;, k -&gt; new Object());</code></pre><p>20、前缀后缀和字符串join简化</p><pre><code>    public static void main(String[] args) &#123;        StringJoiner sj = new StringJoiner(&quot;,&quot;,&quot;start_&quot;,&quot;_end&quot;);        sj.add(&quot;1&quot;);        sj.add(&quot;2&quot;);        sj.add(&quot;3&quot;);        sj.add(&quot;4&quot;);        //未add时，设置toString时的内容        //sj.setEmptyValue(&quot;dddddd&quot;);        //start_1,2,3,4_end        System.out.println(sj.toString());        StringJoiner stringJoiner = new StringJoiner(&quot;#&quot;);        stringJoiner.add(&quot;a&quot;);        stringJoiner.add(&quot;b&quot;);        /**         * merge会把第二个stringJoiner去掉前后缀作为一个字符串合并到第一个stringJoiner         */        StringJoiner merge = sj.merge(stringJoiner);        //start_1,2,3,4,a#b_end        System.out.println(merge);    &#125;</code></pre><p>22、用变量接收值时的考虑<br>如果在后边多次使用，就可以用变量接收。只使用一次那么没必要。<br>if 判断条件过长、get值代码过长时例外<br>反例：</p><pre><code>      Map&lt;Integer, String&gt; collect = Arrays.stream(AuditState.values()).collect(Collectors.toMap(s -&gt; s.code, section -&gt; section.desc, (v1, v2) -&gt; v2));        return collect;</code></pre><p>23、使用ifPresent代替get() + isNotNull<br>正例</p><pre><code>zskQuestionsAndAnswersDoMap.get(zskOperationLogDo.getKnowledgeId()).ifPresent(zskQuestionsAndAnswersDo -&gt; &#123;                                //组内最大id                                Long groupMaxId = zskQuestionsAndAnswersDo.getId();                                setImportData(zskOperationLogDo, groupMaxId);                            &#125;);</code></pre><p>反例：</p><pre><code>         zskOperationLogDoList.forEach(zskOperationLogDo -&gt; &#123;                            ZskQuestionsAndAnswersDo zskQuestionsAndAnswersDo = zskQuestionsAndAnswersDoMap.get(zskOperationLogDo.getKnowledgeId()).get();                            if (ToolUtil.isNotEmpty(zskQuestionsAndAnswersDo)) &#123;                                //组内最大id                                Long groupMaxId = zskQuestionsAndAnswersDo.getId();                                setImportData(zskOperationLogDo, groupMaxId);                            &#125;                        &#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序健壮性.md</title>
      <link href="/2022/03/20/cheng-xu-jian-zhuang-xing/"/>
      <url>/2022/03/20/cheng-xu-jian-zhuang-xing/</url>
      
        <content type="html"><![CDATA[<p>###防止NPE</p><p>1、<code>重要</code> 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p><ul><li><p>返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p><blockquote><p>所以，接口的返回值一定使用包装类型！</p></blockquote></li><li><p> 数据库sql查询参数可能为 null。比如in(null) 这是大忌！查询参数中<strong>mybatis_plus</strong> 加前面的布尔值判断非空参数查询 ; 集合就list.stram().fillter(Objects:isNotNull)</p></li><li><p><code>数据库的查询</code>结果可能为 null。</p></li><li><p><code>集合</code>里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p></li><li><p>Map 结构里get元素 可以为null。</p></li><li><p><strong>RPC、HTTP、webservice 调用</strong> <code>远程调用返回对象时</code>，一律要求进行空指针判断，防止 NPE。</p></li><li><p>对于 <code>Session</code> 中获取的数据，建议进行 NPE 检查，避免空指针。</p></li><li><p><code>级联调用</code> obj.getA().getB().getC()；一连串调用，易产生 NPE。<br>正例：使用 JDK8 的 Optional 类来防止 NPE 问题</p></li></ul><p>2、<code>方法的返回值</code>可以为 null，不强制返回空集合，或者空对象等，<strong>必须添加注释充分说明什么情况下会返回 null 值。</strong><br>说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也<br>并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。</p><p>3、<code>三目运算</code>符非常容易出现空指针，表达式1和表达式2都会被执行。类似于<code>非短路的|</code><br> condition? 表达式 1 : 表达式 2 中，注意表达式 1 和 2 在类型对齐时，可能抛出因<code>自动拆箱</code>导致的 NPE 异常。</p><p>说明：以下两种场景会触发类型对齐的拆箱操作：</p><ul><li>表达式 1 或表达式 2 的值只要有一个是原始类型。</li><li>表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。<br>反例：<pre><code>      Integer a = 1;      Integer b = 2;      Integer c = null;      Boolean flag = false;      // a*b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常      Integer result=(flag? a*b : c);</code></pre></li></ul><p>4、当 <code>switch</code> 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null<br>判断。因为switch 指定条件变量为String时会去调用 hahcode()方法</p><blockquote><p>直接报空指针异常 Exception in thread “main” java.lang.NullPointerException</p></blockquote><p>反例：</p><pre><code>    public static void main(String[] args) &#123;        method(null);    &#125;    public static void method(String param) &#123;        switch (param) &#123;            // 肯定不是进入这里            case &quot;sth&quot;:                System.out.println(&quot;it&#39;s sth&quot;);                break;            // 也不是进入这里            case &quot;null&quot;:                System.out.println(&quot;it&#39;s null&quot;);                break;            // 也不是进入这里            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p>正例：</p><pre><code>    public static void main(String[] args) &#123;        method(null);    &#125;    public static void method(String param) &#123;        if(null==param)&#123;            return;        &#125;        switch (param) &#123;            // 肯定不是进入这里            case &quot;sth&quot;:                System.out.println(&quot;it&#39;s sth&quot;);                break;            // 也不是进入这里            case &quot;null&quot;:                System.out.println(&quot;it&#39;s null&quot;);                break;            // 也不是进入这里            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p>5、对象非空和对象的属性非空判断一起做，<code>请使用短路的||</code>。避免发生空指针 ！<br>短路或是一真就真，不会再去判断第二个了。若user 为null，执行第二个条件一定会空指针</p><p>反例：</p><pre><code>      String a = null;        if(null == a|a.length()==0)&#123;            System.out.println(&quot;失败&quot;);        &#125;</code></pre><p>正例：</p><pre><code> String a = null;        if(null == a||a.length()==0)&#123;            System.out.println(&quot;失败&quot;);        &#125;</code></pre><p>6、<code>重要</code> 包装类型使用==、+ - * / 进行比较。拆箱导致空指针； 左右一边的对象为null一边的对象为基本类型。<br>会把null进行隐式拆箱导致空指针</p><p>它的厉害之处在于我们无法直接观察到空指针，因为光从代码层面看确实“很安全”，但问题发生在“拆箱”，中间隔了一个JDK语法糖，被蒙蔽了。当user.getType()发现自己要和左边的int值比较时，需要拆箱为基础类型。<br>问题代码</p><pre><code>if (CommonConstants.USER_TYPE == user.getType()) &#123;    // ...&#125;public class CommonConstants &#123;    // 他用了int，而不是Integer    public static final int USER_TYPE = 1;&#125;</code></pre><p>总之，Integer拆箱底层会调用：intValue()，所以上面的代码编译后近似于：</p><pre><code>if (CommonConstants.USER_TYPE == user.getType().intValue()) &#123;    // ...&#125;if (CommonConstants.USER_TYPE == user.getType().intValue()) &#123;    // ...&#125;</code></pre><blockquote><p>一定要注意。使用 == 进行包装类型之间的判断有两大坏处： 1、数据缓存导致比较结果不正确；2、隐式拆箱导致空指针！<br>请使用 Objects.equals 进行比较;<br>但是Objects.equals也是有坑的！<br><img src="https://upload-images.jianshu.io/upload_images/13965490-655e532281dec040.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><blockquote><p>原理：一个int和一个Integer比较，要么int装箱为Integer，要么Integer拆箱为int，总之要在“同一个水平线”。Objects.equals()选择不改变Integer，而是把int装箱为Integer。int作为基础类型是没有null的，也就不会发生NPE。也就是说，Objects.equals()的思想是：用安全的装箱替代不稳定的拆箱。<br>一定记得加L </p></blockquote><pre><code> if (Objects.equals(1L, groupListSize)) &#123;</code></pre><p>7、StringBuilder<br>构造器是空不安全的<br>java.lang.StringBuilder</p><pre><code>    public StringBuilder(String str) &#123;        super(str.length() + 16);        append(str);    &#125;</code></pre><p>请尽量使用append代替构造器：</p><p>new StringBuilder().append(province).append(city).append(area).toString())</p><p>8、List里面的元素可能是空，在逐一操作时请使用.filter(Objects::nonNull)，这样写更直观</p><pre><code>        List&lt;JqReturnExchange&gt; records = page.getRecords();        records.parallelStream().filter(Objects::nonNull).forEach(returnExchange -&gt; &#123;            Integer auditStateInt = Optional.of(returnExchange)                    .map(JqReturnExchange::getAuditState)                    .map(AuditState::getCode).orElse(AuditState.TO_BE_APPROVED.getCode());            returnExchange.setAuditStateInt(auditStateInt);        &#125;);</code></pre><p>8、分组的判定字段不能为null。<br>反例：<br> saveZskAccessoriesListDoList.stream().collect(Collectors.groupingBy(ZskAccessoriesListDo::getSpu));<br>正例：<br>.stream().filter(m-&gt;ToolUtil.isNotEmpty(m.getSpu())).collect(Collectors.groupingBy(ZskAccessoriesListDo::getSpu));</p><p>9、比较器中容易空指针<br>空安全的比较器</p><p>userList.sort(Comparator.comparing(User::getId).thenComparing(User::getAge));<br>实际上这个代码有空值安全问题，里面的age字段为null时会报错，如何解决呢？</p><p>方法是使用nullsLast或者nullsFirst</p><p>就像下面这样</p><p>new TreeSet&lt; (Comparator.comparing(ZskAccessoriesListDtoError::getRowNum,Comparator.nullsLast(Integer::compareTo)));</p><p>实际上有更简单的写法</p><p> new TreeSet&lt;&gt;(Comparator.comparing(ZskAccessoriesListDtoError::getRowNum,Comparator.nullsLast(Comparator.naturalOrder())));</p><p>nullsLast、reverseOrder<br>sorted(Comparator.comparing(Rule::getVal,Comparator.nullsLast(Comparator.reverseOrder())))</p><p>10、正则表达式匹配容易空指针<br>getPattern().matcher（参数为空报空指针）</p><pre><code>    //遍历，全都不包含才返回false || 包含之外的就返回false    @Override    public boolean isValid(String value, ConstraintValidatorContext context) &#123;        if (ToolUtil.isEmpty(value)) &#123;            return true;        &#125;        HashSet&lt;Boolean&gt; booleans = new HashSet&lt;&gt;(2);        StringBuilder stringBuilder = new StringBuilder();        for (ContainCharEnum containCharEnum : values) &#123;            booleans.add(containCharEnum.getPattern().matcher(value).find());            stringBuilder.append(containCharEnum);        &#125;</code></pre><p>###浮点计算</p><p>1、<code>重要</code> 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals来判断。<br>说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。<br>反例：</p><pre><code>        float a = 1.0F - 0.9F;        float b = 0.9F - 0.8F;        if (a == b) &#123;            // 预期进入此代码块，执行其它业务逻辑            // 但事实上 a==b 的结果为 false            System.out.println(1);        &#125;        Float x = Float.valueOf(a);        Float y = Float.valueOf(b);        if (x.equals(y)) &#123;            // 预期进入此代码块，执行其它业务逻辑            // 但事实上 equals 的结果为 false            System.out.println(2);        &#125;</code></pre><p>正例：<br>(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</p><pre><code>float a = 1.0F - 0.9F;float b = 0.9F - 0.8F;float diff = 1e-6F;if (Math.abs(a - b) &lt; diff) &#123; System.out.println(&quot;true&quot;);&#125;</code></pre><p>(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。</p><pre><code>        BigDecimal a = new BigDecimal(&quot;1.0&quot;);        BigDecimal b = new BigDecimal(&quot;0.9&quot;);        BigDecimal c = new BigDecimal(&quot;0.8&quot;);        BigDecimal x = a.subtract(b);        BigDecimal y = b.subtract(c);        if (x.compareTo(y) == 0) &#123;            System.out.println(&quot;true&quot;);        &#125;</code></pre><blockquote><p>如上所示 BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。<br>说明：equals()方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareTo()则会忽略精度</p></blockquote><p>2、禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。<br>说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。<br>如：BigDecimal g = new BigDecimal(0.1F); 实际的存储值为：0.10000000149<br>正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了</p><pre><code>Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。 BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;); BigDecimal recommend2 = BigDecimal.valueOf(0.1);</code></pre><blockquote><p>请使用字符串来构造BigDecimal</p></blockquote><p>###异常处理篇</p><p>1、 <strong>运行时异常不应该被捕获</strong> ,  Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。<br>说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不<br>通过 catch NumberFormatException 来实现。<br>正例：if (obj != null) {…}<br>反例：try { obj.method(); } catch (NullPointerException e) {…}</p><p>2、<code>重要</code> 异常捕获后不要用来做流程控制，条件控制。<br>说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多</p><blockquote><p>不要为了图方便直接使用异常控制程序流程！我亲身经历过因为大量异常抛出捕获打印堆栈信息导致 CPU飙高。这种业务流程方面完全可以不使用异常。</p></blockquote><p>3、<code>重要</code> catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。<br>说明：对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，<br>这是一种不负责任的表现。<br>正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p><blockquote><p>不要图方便直接对一大段代码进行全局的try catch，然后统一使用Exception父类接收异常对象。</p></blockquote><p>4、<code>重要</code> 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请<br>将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的<br>内容</p><p>5、事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。<code>或者抛出到上层，这样也能回滚。但是最好手动回滚</code></p><p>6、finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。<br>说明：如果 JDK7 及以上，可以使用 try-with-resources 方式</p><p>7、<code>重要</code>不要在 finally 块中使用 return。<br>说明：try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存<br>在 return 语句，则在此直接返回，无情丢弃掉 try 块中的返回点。</p><p>反例：</p><pre><code>private int x = 0;public int checkReturn() &#123; try &#123; // x 等于 1，此处不返回 return ++x; &#125; finally &#123; // 返回的结果是 2 return ++x; &#125; &#125;</code></pre><p>8、捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br>说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p><p>9、<code>重要</code> 在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable<br>类来进行拦截。<br>说明：通过反射机制来调用方法，如果找不到方法，抛出 NoSuchMethodException。什么情况会抛出<br>NoSuchMethodError 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，<br>或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代<br>码编译期是正确的，但在代码运行期时，会抛出 NoSuchMethodError</p><blockquote><p>Throwable 是Error和Exption的父类</p></blockquote><p>反例：</p><pre><code>    public static void main(String[] args) &#123;        try &#123;            throw new Error();        &#125;catch (Exception e)&#123;            System.out.println(e);        &#125;        System.out.println(&quot;不会执行&quot;);    &#125;</code></pre><p>正例：</p><pre><code>        try &#123;            throw new Error();        &#125;catch (Throwable e)&#123;            System.out.println(e);        &#125;        System.out.println(&quot;会被执行&quot;);</code></pre><p>10、catch异常打印异常请使用log.err打印，而不是使用e.printStackTrace(); e.printStackTrace() ，会输出大量堆栈信息，性能非常差。如果频繁调用势必导致cpu飙高。</p><p>正例</p><pre><code> catch (IOException e) &#123;            log.error(e.toString(),e);            log.info(&quot;okHttp.post请求出错了-------------------&gt;&quot;+ url);        &#125;</code></pre><p>反例</p><pre><code>catch (IOException e) &#123;            e.printStackTrace();        &#125;</code></pre><p>###其它</p><p>1、list、set转 array<br>使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。<br>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现<br>ClassCastException 错误。<br>正例：</p><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(2);list.add(&quot;guan&quot;);list.add(&quot;bao&quot;);String[] array = list.toArray(new String[0]);</code></pre><p> 说明：使用 toArray 带参方法，数组空间大小的 length： </p><ul><li> <strong>等于 0，动态创建与 size 相同的数组，性能最好。</strong></li><li>大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。</li><li>等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。</li><li>大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患</li></ul><p>2、集合类边遍历边删除一定要使用Iterator迭代器，直接使用for循环会报错</p><pre><code>   Iterator&lt;Entry&lt;String, Cache&gt;&gt; it = cacheMap.entrySet().iterator();        while (it.hasNext()) &#123;            Entry&lt;String, Cache&gt; next = it.next();            GuavaCache value = (GuavaCache)  next.getValue();            if (value.isEmpty(next.getKey())) &#123;                it.remove();            &#125;        &#125;</code></pre><p>3、使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</p><p>4、Integer、Long等 类型请使用eques来比较相等<br>因为-128 ~ 127走缓存，这个范围之外的如128就是new实例了，这时候使用==会返回false</p><p>7、Bean copy属性性能比较<br>属性copy时各方式的使用场景：</p><ul><li>对性能要求较高的时候，推荐采用手工方法调用</li><li>一般场景推荐使用net.sf.cglib.beans.BeanCopier#copy</li><li>如果考虑到引入新jar包的风险时，推荐使用org.springframework.beans.BeanUtils.copyProperties</li><li>不可以使用apache家的性能非常差</li></ul><p>8、比较两个对象使用equals注意要重写 hashcode、和equals方法；<br>另外若一个对象要做Map的key，也需要重写hashcode、和equals方法。否则不唯一</p><p>9、equals使用的时候一定左边写常量。避免空指针<br>Object code = (Object)”0”;<br>code.equals(0) 返回false<br>code.equals(“0”) 返回true</p><p>为了使语意明确和避免控制针， 判断请改为这样：<br>“0”.equals(code)</p><blockquote><p>推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b)</p></blockquote><p>10、list转map时。使用的toMap 请使用 3个参数的，带 BinaryOperator<U> mergeFunction的。这个方法会在key冲突时提供解决办法，而不是直接报错</p><pre><code>    public static &lt;T, K, U&gt;    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,                                    Function&lt;? super T, ? extends U&gt; valueMapper,                                    BinaryOperator&lt;U&gt; mergeFunction) &#123;        return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new);    &#125;</code></pre><p>反例</p><blockquote><p>报错 Exception in thread “main” java.lang.IllegalStateException: Duplicate key 12.1</p></blockquote><pre><code>  String[] departments = new String[]&#123;&quot;iERP&quot;, &quot;iERP&quot;, &quot;EIBU&quot;&#125;;        Map&lt;Integer, String&gt; map = Arrays.stream(departments)                .collect(Collectors.toMap(String::hashCode, str -&gt; str));</code></pre><p>正例：(v1, v2) -&gt; v2) 表示，如果发生冲突，则以V2 （后加入的）为准</p><pre><code>   String[] departments = new String[]&#123;&quot;iERP&quot;, &quot;iERP&quot;, &quot;EIBU&quot;&#125;;        Map&lt;Integer, String&gt; map = Arrays.stream(departments)                .collect(Collectors.toMap(String::hashCode, str -&gt; str,(v1, v2) -&gt; v2));</code></pre><p>11、<code>重要</code> 关于基本数据类型与包装数据类型的使用标准如下：</p><ul><li>所有的 POJO 类属性必须使用包装数据类型。</li><li>RPC 方法的返回值和参数必须使用包装数据类型。</li><li>所有的局部变量使用基本数据类型。<br>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或<br>者入库检查，都由使用者来保证。</li></ul><p>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：某业务的交易报表上显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调<br>用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线-。所以包装数据类型<br>的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p><p>12、<code>重要</code> 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。<br>反例：POJO 类的 createTime 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间</p><p>13、序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果<br>完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。<br>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p><p>14、禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法。<br>说明：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到的。</p><p>15、使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容<br>的检查，否则会有抛 IndexOutOfBoundsException 的风险。<br>说明：</p><pre><code>String str = &quot;a,b,c,,&quot;;String[] ary = str.split(&quot;,&quot;);// 预期大于 3，结果是 3System.out.println(ary.length);</code></pre><p>16、<code>重要</code> 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。<br>说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append<br>操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。<br>反例：</p><pre><code>String str = &quot;start&quot;;for (int i = 0; i &lt; 100; i++) &#123; str = str + &quot;hello&quot;; &#125;</code></pre><p>17、final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：<br>1） 不允许被继承的类，如：String 类。<br>2） 不允许修改引用的域对象，如：POJO 类的域变量。<br>3） 不允许被覆写的方法，如：POJO 类的 setter 方法。<br>4） 不允许运行过程中重新赋值的局部变量。<br>5） 避免上下文重复使用一个变量，使用 final 关键字可以强制重新定义一个变量，方便更好地进行重构。</p><p>18、慎用 Object 的 clone 方法来拷贝对象。<br>说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝，需覆写 clone 方法实现域对象的深度遍历式拷贝。</p><p>19、类成员与方法访问控制从严：</p><ul><li><p> 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 2） 工具类不允许有 public 或 default 构造方法。</p></li><li><p>类非 static 成员变量并且与子类共享，必须是 protected。 </p></li><li><p>类非 static 成员变量并且仅在本类使用，必须是 private。</p></li><li><p> 类 static 成员变量如果仅在本类使用，必须是 private。</p></li><li><p> 若是 static 成员变量，考虑是否为 final。</p></li><li><p>类成员方法只供类内部调用，必须是 private。</p></li><li><p>类成员方法只对继承类公开，那么限制为 protected。</p></li></ul><p>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果<br>是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不<br>得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你<br>会担心的</p><p>20、关于 hashCode 和 equals 的处理，遵循如下规则：<br>1） 只要覆写 equals，就必须覆写 hashCode。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写<br>这两种方法。<br>3） 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。<br>说明：String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。</p><p>21、<code>重要</code> 判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。<br>说明：在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。<br>正例：</p><pre><code>Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);if(map.isEmpty()) &#123; System.out.println(&quot;no element in this map.&quot;);&#125;</code></pre><p>22、<code>重要</code> 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。<br>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的<br>value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用<br>Map.forEach 方法。<br>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对<br>象；entrySet()返回的是 K-V 值组合集合</p><p>23、<code>重要</code> 集合初始化时，指定集合初始值大小。<br>说明：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默<br>认值（16）即可。<br>正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认<br>为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。<br>反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，<br>resize()方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序<br>性能。</p><p>24、<code>去重</code> 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的<br>contains()进行遍历去重或者判断包含操作。</p><p>25、<code>重要</code> 在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么<br>注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default<br>语句并且放在最后，即使它什么代码也没有。</p><blockquote><p>说明：注意 break 是退出 switch 语句块，而 return 是退出方法体。</p></blockquote><p>for循环和switch 嵌套使用：</p><ul><li><p>break不跳出循环</p></li><li><p>continue 跳过本次循环<br>如何直接提前结束循环？<br>1、使用return<br>2、使用 continue goto</p><pre><code>  public static void main(String[] args) &#123;      for (int i = 0; i &lt; 3; i++) &#123;          switch (i)&#123;              case 1:                  break;              default:                  continue;          &#125;          // break不跳出循环          // continue 跳过本次循环          System.out.println(&quot;a&quot;);                &#125;  &#125;</code></pre></li></ul><p>26、<code>重要</code> List.remove 在数据不存在时会报数组越界。java8有List.removeIf可以代替之<br>正例</p><pre><code>   final ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(2);        list.add(3);        list.removeIf(e-&gt;Objects.equals(e,4));</code></pre><p>set</p><pre><code>sSet.removeIf(s -&gt; Objects.equals(s,String.valueOf(OrderErrMsgEnum.COMMODITY_REFERENCE.getState())));</code></pre><p>反例，报错：Exception in thread “main” java.lang.IndexOutOfBoundsException: Index: 4, Size: 3</p><pre><code>     final ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(2);        list.add(3);        list.remove(4);</code></pre><p>27、Map的一个方法computeIfPresent 可以快速完成对value的修改。不用再遍历然后if了</p><pre><code>        // 创建一个 HashMap        HashMap&lt;String, Integer&gt; prices = new HashMap&lt;&gt;();        // 往HashMap中添加映射关系        prices.put(&quot;Shoes&quot;, 200);        prices.put(&quot;Bag&quot;, 300);        prices.put(&quot;Pant&quot;, 150);        System.out.println(&quot;HashMap: &quot; + prices);        // 重新计算鞋加上10%的增值税后的价值        int shoesPrice = prices.computeIfPresent(&quot;Shoes&quot;, (key, value) -&gt; value + value * 10/100);        System.out.println(&quot;Price of Shoes after VAT: &quot; + shoesPrice);        // 输出更新后的HashMap        System.out.println(&quot;Updated HashMap: &quot; + prices);</code></pre><p>28、截取指定字符的之前的前缀。indexOf会返回-1.这个时候需要做判断。否则substring传入-1报错:<br>正例</p><pre><code>           final int index = platformOrderNo.indexOf(&quot;-&quot;);                if(!Objects.equals(-1,index))&#123;                    platformOrderNo = platformOrderNo.substring(0, index);                &#125;</code></pre><p>java.lang.StringIndexOutOfBoundsException: String index out of range: -1<br>###边界值缺失判断</p><p>但产品语言与程序语言并不完全等同，直接翻译有时会引发意想不到的BUG。</p><p>假设现在有一个需求：<br>● 下单24小时以后，为用户发放奖励</p><p>一般来说，我们可以采用定时任务完成这个需求，具体做法是：<br>● 用户下单后，在order_task表插入一条记录（为了方便记忆，type和status都用字符串代替）：</p><p>● 定时任务扫描需要发放下单奖励的任务、为用户发放奖励、更新任务状态：</p><pre><code># 伪代码 86400=24*60*60SELECT * FROM order_task WHERE order_type=&#39;complete_order_prize&#39; and task_status=&#39;wait&#39; and gmt_create &lt; now-86400;</code></pre><p>注意时间条件，由于产品需求是下单24小时后才发放奖励，所以要满足条件：</p><pre><code>gmt_create &lt; now-86400。</code></pre><p>解决方法是，查询奖励任务时，加一个边界判断：下单24小时后，<strong>且最近3个月内的订单</strong>。</p><p>个人建议<br>● 注意边界判断，不要做产品语言的翻译机，要从开发的角度考虑设计是否合理<br>● 养成打日志的习惯有利于问题排查</p><blockquote><p>这个案例中出错的原因就是只是查询超过24小时没处理的信息，然而现在存在积压的非常久的信息，没有被处理。数量非常之大。所以查询的数量就非常多了。因此需要加一个 <strong>且最近3个月内的订单</strong> 条件。</p></blockquote><p>###subList的代替方案<br> ArrayList的subList方法，返回的是原集合的一个子集合（视图），修改任意一个集合的元素的值，都会彼此影响；原集合结构性修改（删除或添加元素）时，会报ConcurrentModificationException异常；结构性修改子集合时，会影响原集合，所以使用时要注意，避免程序错误或者异常。</p><ul><li><p>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异 常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。<br>说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视<br>图，对于 SubList 的所有操作最终会反映到原列表上。</p></li><li><p>在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p></li><li><p>对于一个不确定长度的原List，如果你想做以下截取操作：list.subList(0, 5)或者list.subList(2, 5)，当原List长度不满足List.size()&gt;=5时，会抛异常。为了避免误操作，你必须先判断size：</p><pre><code>if(list != null &amp;&amp; list.size() &gt;= 5) &#123;  return list.subList(2, 5);&#125;if(list != null &amp;&amp; list.size() &gt;= 5) &#123;  return list.subList(2, 5);&#125;</code></pre></li></ul><p>既然subList那么多问题， 我们可以使用java8提供的新方法来代替subList：</p><blockquote><p>stream的skip和limit返回的list是一个新的对象。对他操作并不会影响原来的</p></blockquote><pre><code>        List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);        List&lt;String&gt; limit3 = list.stream().limit(3).collect(Collectors.toList());        // 超出实际长度也不会报错        List&lt;String&gt; limit5 = list.stream().limit(5).collect(Collectors.toList());        List&lt;String&gt; range3_4 = list.stream().skip(2).limit(2).collect(Collectors.toList());        // 超出实际长度也不会报错        List&lt;String&gt; range3_5 = list.stream().skip(2).limit(3).collect(Collectors.toList());        //[a, b, c] [a, b, c, d] [c, d] [c, d]        System.out.println(limit3 + &quot; &quot; + limit5 + &quot; &quot; + range3_4 + &quot; &quot; + range3_5);</code></pre><p>对比下</p><ul><li>subList a表示开始索引，b表示结束索引</li><li>stream的skip 表示开始索引，b表示长度<pre><code>      List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);      List&lt;String&gt; range3_4 = list.stream().skip(2).limit(2).collect(Collectors.toList());      //[c, d]      System.out.println(range3_4);      //[c, d]      System.out.println(list.subList(2,4));</code></pre></li><li>所以，a和skip 都为0时，两个方法结果是一样的</li></ul><pre><code> List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);        final List&lt;String&gt; addList1 = list.stream().skip(0).limit(3).collect(Collectors.toList());        System.out.println(addList1);        final List&lt;String&gt; addList2 = list.subList(0, 3);        System.out.println(addList2);</code></pre><p>###List的交差并操作<br>两个list直接进行集合操作，可能大部分人就是想到使用嵌套的for循环来做。这样的代码极不优雅，而且容易出错。</p><p>方法1：<br>当然，List本身提供了诸如addAll()、retainAll()、removeAll()等操作，可以很方便的实现并集、交集、差集。所以，上面的去重取并集可以这样：</p><p>方法2：<code>重要</code> 使用stream的 filter</p><pre><code>        // 前台List        List&lt;Item&gt; aList = Lists.newArrayList(                new Item(1, &quot;甲&quot;),                new Item(2, &quot;乙&quot;),                new Item(3, &quot;丙&quot;)        );        // 后台List        List&lt;Item&gt; bList = Lists.newArrayList(                new Item(3, &quot;丙&quot;),                new Item(99, &quot;对照数据&quot;)        );        /**         * 两个list去重后取并集         */        // 对aList进行筛选（bList中不存在的item）        Map&lt;Integer, Item&gt; bItemMap = bList.stream().collect(Collectors.toMap(Item::getId, v -&gt; v, (v1, v2) -&gt; v1));        List&lt;Item&gt; filteredAList = aList.stream()                .filter(aItem -&gt; !bItemMap.containsKey(aItem.getId()))                .collect(Collectors.toList());        // 组合去重后的两个List，后台List置顶        bList.addAll(filteredAList);        System.out.println(JSON.toJSONString(bList));</code></pre><p>###try-catch 使用注意<br>finally里面请不要写业务逻辑、不要写return，只做资源关闭。或者只写独立的业务。否则容易出现意想不到的问题！</p><p>###集合之间无缝切换实现时注意<br>HashMap 用ConcurrentHashMap替换时需要注意 put进去key和value为null时会报空指针</p><p>###接收mq消息，接收接口调用消息<br>新添加type时一定要注意兼容老接口请求，老接口可能就是一个json字符串，里面不包含type。<br>否则解析失败，各种打印异常堆栈信息。导致服务宕机！<br>这个坑我掉入过几次了，之前在丰速时就是这样。这次在讯销也有类似问题。</p><p>修改接口时只考虑实现功能，没有考虑兼容性了！</p><h3 id="Objects-equals坑"><a href="#Objects-equals坑" class="headerlink" title="Objects.equals坑"></a>Objects.equals坑</h3><pre><code>       //fasle        System.out.println(Objects.equals(1,new Long(1)));//true        System.out.println(Objects.equals(1,new Integer(1)));</code></pre><p>基本类型和包装类型比较比较还是得要用 == ，或者Objects.equals只能用在int和Integer直接比较，long和long之间比较！</p><p>这种代码就是有问题,注意数据类型1L和1不同</p><p>###StringUtils.split的坑<br>请使用apache的而不是spring的</p><pre><code>      String[] split1 = org.apache.commons.lang.StringUtils.split(&quot;aaaa,bbbb,cccc&quot;, Constant.COMMA);        System.out.println(split1.length);        System.out.println(Arrays.asList(split1));        String[] split2 = org.springframework.util.StringUtils.split(&quot;aaaa,bbbb,cccc&quot;, Constant.COMMA);        System.out.println(split2.length);        System.out.println(Arrays.asList(split2));</code></pre><p>###<code>重要</code>字符串转数值很容易出现格式化错误，因此我们需要提前判断<br> NumberUtil.isInteger(designFormulas) ? Integer.valueOf(designFormulas) : Constant.NUMBER_ZERO;<br>这个问题还可以延伸到json的解析，如果有个不规范的字符串调用了JSON.parse那么也会有转换失败的运行时异常抛出。这个时候如果上层没有try-catch那么将会导致相关业务异常。而且要尽力减少异常的影响面积，比如一个云打印的功能，其中一个图片展示出现了json解析异常。那么仅仅是这个图片显示不出来而不是整个云打印功能都瘫痪！</p><p>###接口<br>公开接口需要进行入参保护，尤其是批量操作的接口。<br>反例：某业务系统，提供一个用户批量查询的接口，API 文档上有说最多查多少个，但接口实现上没做任何<br>保护，导致调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。</p><p>###查询<br>1、关于配置表或者其它业务表的查询<br>应该要尽量添加where条件。如 is_delete、客户编号、平台编号等。<br>这些条件非常容易忘记添加。这也会导致业务出错。而且查询的结果也会非常大</p><p>2、sql注入预防<br>项目里搜索CONCAT(‘%’,’$ 查看使用$的地方。改之</p><pre><code>LIKE CONCAT(&#39;%&#39;,&#39;#&#123;zskKnowledgeVo.keyword&#125;&#39;,&#39;%&#39; )</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
