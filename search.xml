<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1-4-Collection-子接口之-Queue.md</title>
      <link href="/2022/03/20/1-4-collection-zi-jie-kou-zhi-queue/"/>
      <url>/2022/03/20/1-4-collection-zi-jie-kou-zhi-queue/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>1.4 Collection 子接口之 Queue</p><h3 id="1-4-1-Queue-与-Deque-的区别"><a href="#1-4-1-Queue-与-Deque-的区别" class="headerlink" title="1.4.1 Queue 与 Deque 的区别"></a>1.4.1 Queue 与 Deque 的区别</h3><p>Queue是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p>Queue扩展了 Collection的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值（布尔值或object） 。</p><table><thead><tr><th>Queue接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>boolean offer(E e)  失败返回false</td></tr><tr><td>删除队首</td><td>remove()</td><td>Object poll() 失败返回null</td></tr><tr><td>查询队首元素</td><td>element()</td><td>Object peek() 失败返回null</td></tr></tbody></table><blockquote><p>记忆方法：<br>低级词汇：add、remove、element 会引发异常；<br>高级词汇：offer（插入）、poll（都有o）、peek（都有e） ；会返回特殊值（布尔值或object） </p></blockquote><p>Deque是双端队列，在队列的两端均可以插入或删除元素。</p><p>Deque扩展了 Queue的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th>Deque接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><blockquote><p>事实上，Deque还提供有 push()和 pop()等其他方法，可用于模拟栈。</p></blockquote><h3 id="1-4-2-ArrayDeque-与-LinkedList-的区别"><a href="#1-4-2-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="1.4.2 ArrayDeque 与 LinkedList 的区别"></a>1.4.2 ArrayDeque 与 LinkedList 的区别</h3><p>ArrayDeque和 LinkedList都实现了 Deque接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><p>  ArrayDeque是基于可变长的数组和双指针来实现，而 LinkedList则通过链表来实现。</p></li><li><p>  ArrayDeque不支持存储 NULL数据，但 LinkedList支持。</p><blockquote><p>Qeque、Deque 都不允许存入null。否则报空指针</p></blockquote></li><li><p>  ArrayDeque是在 JDK1.6 才被引入的，而LinkedList早在 JDK1.2 时就已经存在。</p></li><li><p>  ArrayDeque插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p></li></ul><blockquote><p>从性能的角度上，选用 ArrayDeque来实现队列要比 LinkedList更好。此外，ArrayDeque也可以用于实现栈。</p></blockquote><p>###1.4.3 说一说 PriorityQueue</p><p>PriorityQueue是在 JDK1.5 中被引入的, 其与 Queue的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li>  PriorityQueue利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>  PriorityQueue通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>  PriorityQueue是非线程安全的，且不支持存储 NULL和 non-comparable的对象。</li><li>  PriorityQueue默认是小顶堆，但可以接收一个 Comparator作为构造参数，从而来自定义元素优先级的先后。<blockquote><p>其实就是按优先级自定义排序</p></blockquote></li></ul><p>PriorityQueue在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p><pre><code>  PriorityQueue&lt;Integer&gt; objects = new PriorityQueue&lt;&gt;(5,new Comparator&lt;Integer&gt;() &#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                return o1-o2;            &#125;        &#125;);        objects.offer(200);        objects.offer(1);        objects.offer(33);        objects.offer(888);        objects.offer(666);        boolean offer = objects.offer(999);        System.out.println(offer);        while (!objects.isEmpty())&#123;            System.out.println(objects.poll());        &#125;</code></pre><p>###LinkedBlockingDeque<br>LinkedBlockingDeque是BlockingDeque接口唯一的实现类</p><p>使用它来模拟栈</p><pre><code>        LinkedBlockingDeque&lt;Object&gt; objects = new LinkedBlockingDeque&lt;&gt;(3);        objects.push(1);        objects.push(2);        objects.push(3);        Object pop = objects.pop();        //3        System.out.println(pop);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7种遍历hashMap的方式那种最好？.md</title>
      <link href="/2022/03/20/7-chong-bian-li-hashmap-de-fang-shi-na-chong-zui-hao/"/>
      <url>/2022/03/20/7-chong-bian-li-hashmap-de-fang-shi-na-chong-zui-hao/</url>
      
        <content type="html"><![CDATA[<p>HashMap 遍历从大的方向来说，可分为以下 4 类：</p><p>迭代器（Iterator）方式遍历；<br>For Each 方式遍历；<br>Lambda 表达式遍历（JDK 1.8+）;<br>Streams API 遍历（JDK 1.8+）。<br>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；<br>使用迭代器（Iterator）KeySet 的方式进行遍历；<br>使用 For Each EntrySet 的方式进行遍历；<br>使用 For Each KeySet 的方式进行遍历；<br>使用 Lambda 表达式的方式进行遍历；<br>使用 Streams API 单线程的方式进行遍历；<br>使用 Streams API 多线程的方式进行遍历。</p><p>本文我们讲了 HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，我们应该尽量使用迭代器（Iterator）来遍历 EntrySet 的遍历方式来操作 Map 集合，这样就会既安全又高效了。</p><pre><code>        // 创建并赋值 HashMap        Map&lt;Integer, String&gt; map = new HashMap();        map.put(1, &quot;Java&quot;);        map.put(2, &quot;JDK&quot;);        map.put(3, &quot;Spring Framework&quot;);        map.put(4, &quot;MyBatis framework&quot;);        map.put(5, &quot;Java中文社群&quot;);        // 遍历        Iterator&lt;Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();        while (iterator.hasNext()) &#123;            Map.Entry&lt;Integer, String&gt; entry = iterator.next();            System.out.println(entry.getKey());            System.out.println(entry.getValue());        &#125;</code></pre><p>###3.Lambda 方式</p><p>小结<br>我们不能在遍历中使用集合 map.remove() 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 iterator.remove() 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 removeIf 来提前删除数据，或者是使用 Stream 中的 filter 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 for 循环前删除数据在遍历也是线程安全的。</p><p>总结<br>本文我们讲了 HashMap 4 大类(迭代器、for、lambda、stream)遍历方式，以及具体的 7 种遍历方法，<strong>除了 Stream 的并行循环</strong>，其他几种遍历方法的性能差别不大，但从简洁性和优雅性上来看，Lambda 和 Stream 无疑是最适合的遍历方式。除此之外我们还从「安全性」方面测试了 4 大类遍历结果，从安全性来讲，我们应该使用迭代器提供的 iterator.remove() 方法来进行删除，这种方式是安全的在遍历中删除集合的方式，或者使用 Stream 中的 filter 过滤掉要删除的数据再进行循环，也是安全的操作方式。</p><p>总体来说，本文提供了 7 种方式肯定也不是最全的，我是想给读者在使用 HashMap 时多一种选择，然而选择那一种形式的写法，要综合：性能、安全性、使用环境的 JDK 版本以及优雅性和可读性等方面来综合考虑。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-种基本类型的包装类和常量池.md</title>
      <link href="/2022/03/20/8-chong-ji-ben-lei-xing-de-bao-zhuang-lei-he-chang-liang-chi/"/>
      <url>/2022/03/20/8-chong-ji-ben-lei-xing-de-bao-zhuang-lei-he-chang-liang-chi/</url>
      
        <content type="html"><![CDATA[<p>Java 基本类型的包装类的大部分都实现了常量池技术。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p><p><strong>Integer 缓存源码：</strong></p><pre><code>/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/public static Integer valueOf(int i) &#123;    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)      return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);&#125;private static class IntegerCache &#123;    static final int low = -128;    static final int high;    static final Integer cache[];&#125;</code></pre><p><strong><code>Character</code> 缓存源码:</strong></p><pre><code>public static Character valueOf(char c) &#123;    if (c &lt;= 127) &#123; // must cache      return CharacterCache.cache[(int)c];    &#125;    return new Character(c);&#125;private static class CharacterCache &#123;    private CharacterCache()&#123;&#125;    static final Character cache[] = new Character[127 + 1];    static &#123;        for (int i = 0; i &lt; cache.length; i++)            cache[i] = new Character((char)i);    &#125;&#125;</code></pre><p><strong><code>Boolean</code> 缓存源码：</strong></p><pre><code>public static Boolean valueOf(boolean b) &#123;    return (b ? TRUE : FALSE);&#125;</code></pre><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p><pre><code>Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueFloat i11 = 333f;Float i22 = 333f;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false</code></pre><p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>flase</code> 呢？</p><pre><code>Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2);</code></pre><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。你答对了吗？</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。<br><a href="https://camo.githubusercontent.com/1787ac3ea56e56450b185b8e6dccb0bfd4ce60cafe05ffdecf31f3e64c833724/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303432323136343534343834362e706e67"><img src="https://upload-images.jianshu.io/upload_images/13965490-462db0b814071f82?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array、Set、List互相转.md</title>
      <link href="/2022/03/20/array-set-list-hu-xiang-zhuan/"/>
      <url>/2022/03/20/array-set-list-hu-xiang-zhuan/</url>
      
        <content type="html"><![CDATA[<ol><li>数组转化为List：<pre><code>String[] strArray= new String[]&#123;&quot;Tom&quot;, &quot;Bob&quot;, &quot;Jane&quot;&#125;;List strList= Arrays.asList(strArray);</code></pre>List转数组<pre><code>toArray()</code></pre></li></ol><ol start="2"><li>数组转Set<br>~~~<br>String[] strArray= new String[]{“Tom”, “Bob”, “Jane”};<br>Set<String> staffsSet = new HashSet&lt;&gt;(Arrays.asList(staffs));</li></ol><p>staffsSet.add(“Mary”); // ok<br>staffsSet.remove(“Tom”); // ok</p><pre><code>3. List转Set</code></pre><p>String[] staffs = new String[]{“Tom”, “Bob”, “Jane”};<br>List staffsList = Arrays.asList(staffs);<br>Set result = new HashSet(staffsList);</p><pre><code>4. set转List</code></pre><p>String[] staffs = new String[]{“Tom”, “Bob”, “Jane”};<br>Set<String> staffsSet = new HashSet&lt;&gt;(Arrays.asList(staffs));<br>List<String> result = new ArrayList&lt;&gt;(staffsSet);</p><pre><code> </code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigDecimal.md</title>
      <link href="/2022/03/20/bigdecimal/"/>
      <url>/2022/03/20/bigdecimal/</url>
      
        <content type="html"><![CDATA[<p>###compareTo比较<br>compareTo也说得很详细，数值相同但是精度不同的两个数（例如2.0和2.00）被认为是相等的两个数，返回0。另外对于a.compareTo(b)方法</p><p>a&lt;b, 返回-1</p><p>a=b，返回0</p><p>a&gt;b, 返回1</p><p>###divide</p><p>除法</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-hashCode和equals方法与对象比较和去重(一).md</title>
      <link href="/2022/03/20/java-hashcode-he-equals-fang-fa-yu-dui-xiang-bi-jiao-he-qu-chong-yi/"/>
      <url>/2022/03/20/java-hashcode-he-equals-fang-fa-yu-dui-xiang-bi-jiao-he-qu-chong-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>事实胜于雄辩</p></blockquote><p>###什么时候需要重写hashCode 和 equals 方法呢？</p><blockquote><p>如果想使用equals比较对象，那么请将equals方法和hashCode方法重写</p></blockquote><p>######情景模式一<br><code>在使用Set进行集合元素去重的时候，请将hashCode 和 equals 方法重写。</code></p><p>如下代码，不重写hashCode 和 equals 。看看使用set是否能去重成功</p><pre><code>package io.renren;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.Set;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,                new Test(1,&quot;yinkai&quot;,23),                new Test(1,&quot;yinkai&quot;,23),                new Test(2,&quot;yinkai&quot;,25)        );        Set&lt;Test&gt; set = new HashSet&lt;&gt;(list);        System.out.println(set);    &#125;&#125;</code></pre><p>可以看到list里有两个new Test(1,”yinkai”,23)，那么使用set去重应该能够干掉一个。运行程序，打印如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-df829b4d0196706e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>还是存在两个相同的对象<br>那么，我们再使用idea生成下两个方法，代码如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-ee1f131d899a096f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>之后的代码如下</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Test test = (Test) o;        return Objects.equals(id, test.id) &amp;&amp;                Objects.equals(name, test.name) &amp;&amp;                Objects.equals(age, test.age);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(id, name, age);    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,                new Test(1,&quot;yinkai&quot;,23),                new Test(1,&quot;yinkai&quot;,23),                new Test(2,&quot;yinkai&quot;,25)        );        Set&lt;Test&gt; set = new HashSet&lt;&gt;(list);        System.out.println(set);    &#125;&#125;</code></pre><p>再次运行程序如下：<br><img src="https://upload-images.jianshu.io/upload_images/13965490-e0d8bf0f1db2f6f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>问题完美解决 ~</p><p>######情景模式二<br><code>使用自定义对象作为作为 Map 的键，请将 hashCode 和 equals方法重写。</code></p><p>如下代码，若不重写 hashCode 和 equals方法看看会发生什么情况~</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    public static void main(String[] args) &#123;        HashMap&lt;Test,Object&gt; hashMap = new HashMap&lt;Test,Object&gt;() &#123;&#123;           put(new Test(1,"yinkai",23),1);           put(new Test(1,"yinkai",23),1);           put(new Test(3,"yinkai",25),1);        &#125;&#125;;        System.out.println(hashMap);    &#125;&#125;</code></pre><p>上面的代码两次将new Test(1,”yinkai”,23)作为HashMap的key，而我们知道HashMap的key是不会重复的。但是运行下程序：<br><img src="https://upload-images.jianshu.io/upload_images/13965490-b7f669b62f24658f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可见这个HashMap的key在这种情况是重复的，其实此时HashMap它自己认为二者key是不相同的，因为HashMap内部判断key是否重复的算法仅仅使用的是对象的引用。而我们程序员希望它根据字段来判断是否重复。</p><p>那么，我们使用idea生成一下Test类的hashCode 和 equals 方法，代码如下：</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Test test = (Test) o;        return Objects.equals(id, test.id) &amp;&amp;                Objects.equals(name, test.name) &amp;&amp;                Objects.equals(age, test.age);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(id, name, age);    &#125;    public static void main(String[] args) &#123;        HashMap&lt;Test,Object&gt; hashMap = new HashMap&lt;Test,Object&gt;() &#123;&#123;           put(new Test(1,"yinkai",23),1);           put(new Test(1,"yinkai",23),1);           put(new Test(3,"yinkai",25),1);        &#125;&#125;;        System.out.println(hashMap);    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-ccc8bcc0e5592ec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>ok，现在key总算是不重复了</p><p>###为什么使用equals比较对象就要将 hashCode 和 equals 方法一起重写？</p><p>我们可以看看Object类的源码。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-b641867bd0543563.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面例子中的两个new Test(1,”yinkai”,23) 对象的引用的确是不同的，但是引用的比较对我们来说根本没有意义，我们需要使用Test中的id,name,age字段一起进行比较！</p><blockquote><p>Object基类的equals方法的确只是比较对象的引用，但是我们程序员希望根据业务字段来进行比较。</p></blockquote><p>那么可能有人就会问了，既然需要比较业务字段，那重写equals 就行了呀，为什么还要重写hashCode呢？<br>是的，如果单单只是使用equals来判断俩对象是否相等，我们可以不去重写hashCode，看代码：</p><pre><code>package io.renren;import java.util.*;/** * @author: yinkai * @create: 2020-03-20 10:53 */class Test &#123;    private Integer id;    private String name;    private Integer age;    public Test()&#123;&#125;    public Test(Integer id, String name, Integer age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Test&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Test test = (Test) o;        return Objects.equals(id, test.id) &amp;&amp;                Objects.equals(name, test.name) &amp;&amp;                Objects.equals(age, test.age);    &#125;    public static void main(String[] args) &#123;        System.out.println(new Test(1,&quot;yinkai&quot;,23) .equals(new Test(1,&quot;yinkai&quot;,23)) );    &#125;&#125;</code></pre><p>程序打印 true ，若按字段比较两个对象是相等的</p><p> <code>但是，我们要在 HashMap、HashTable 的 key 和 HashSet 这种容器中使用时就必须重写hashCode方法了！</code></p><p>在上面程序中添加一行代码，打印下两个字段相同对象的hashCode数值是否相同</p><pre><code>System.out.println(new Test(1,&quot;yinkai&quot;,23).hashCode() == new Test(1,&quot;yinkai&quot;,23).hashCode());</code></pre><p>打印了false，可见如果不重写hashCode。那么两个new Test(1,”yinkai”,23)对象的hashCode()方法返回值是不同的。</p><p>很巧的是，HashMap和HashTable都是使用对象的hashCode()方法和equals 方法一起来进行key键对象重复判断的。我们可以看看HashMap put方法的源码：</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-694aa59faf431f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这里调用了hash()方法，进去看看这个<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c3ec4ad01745c382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>不出所料，的确是使用了hashCode。在跟进去putval看看<br><img src="https://upload-images.jianshu.io/upload_images/13965490-2fd176e88eab27c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>已经很清晰了，hashCode和equals 一起用在了HashMap的key键的重复判断中。</p><p>由此可见在 HashMap、HashTable 的 key 和 HashSet中必须将hashCode和equals 一起重写。如果违背这个原则，那么后果就是HashMap、HashTable 的key重复，HashSet无法完成去重任务。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongAdder与AtomicLong有什么区别？.md</title>
      <link href="/2022/03/20/longadder-yu-atomiclong-you-shi-me-qu-bie/"/>
      <url>/2022/03/20/longadder-yu-atomiclong-you-shi-me-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>LongAdder与AtomicLong有什么区别？<br>参考答案</p><ul><li>AtomicLong 是基于 CAS 方式自旋更新的；</li></ul><p>LongAdder 是把 value 分成若干cell，并发量低的时候，直接 CAS 更新值，成功即结束。并发量高的情况，CAS更新某个cell值和需要时对cell数据扩容，成功结束；更新失败自旋 CAS 更新 cell值。取值的时候，调用 sum() 方法进行每个cell累加。</p><ul><li>AtomicLong 包含有原子性的读、写结合的api；LongAdder 没有原子性的读、写结合的api，能保证结果最终一致性。</li><li>低并发场景AtomicLong 和 LongAdder 性能相似，高并发场景 LongAdder 性能优于 AtomicLong。</li></ul><p>###LongAdder求和<br>LongAdder的思想其实和之前的 数据库表实现计数器是一样的！<br>多个卡槽，随机update。最后sum求和+ </p><pre><code>    /**     * Returns the current sum.  The returned value is &lt;em&gt;NOT&lt;/em&gt; an     * atomic snapshot; invocation in the absence of concurrent     * updates returns an accurate result, but concurrent updates that     * occur while the sum is being calculated might not be     * incorporated.     *     * @return the sum     */    public long sum() &#123;        Cell[] as = cells; Cell a;        long sum = base;        if (as != null) &#123;            for (int i = 0; i &lt; as.length; ++i) &#123;                if ((a = as[i]) != null)                    sum += a.value;            &#125;        &#125;        return sum;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？.md</title>
      <link href="/2022/03/20/java-fan-xing-liao-jie-me-shi-me-shi-lei-xing-ca-chu-jie-shao-yi-xia-chang-yong-de-tong-pei-fu/"/>
      <url>/2022/03/20/java-fan-xing-liao-jie-me-shi-me-shi-lei-xing-ca-chu-jie-shao-yi-xia-chang-yong-de-tong-pei-fu/</url>
      
        <content type="html"><![CDATA[<p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><pre><code>    public static void main(String[] args)        throws  NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(12);        //这里直接添加会报错        //list.add(&quot;a&quot;);        Class&lt;? extends List&gt; clazz = list.getClass();        Method add = clazz.getDeclaredMethod(&quot;add&quot;, Object.class);        //但是通过反射添加，是可以的        add.invoke(list, &quot;kl&quot;);        System.out.println(list);    &#125;</code></pre><p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p><p>1.泛型类：</p><pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt; &#123;    private T key;    public Generic(T key) &#123;        this.key = key;    &#125;    public T getKey() &#123;        return key;    &#125;    public static void main(String[] args) &#123;        Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);        //自动获取Integer的eky        Integer key1 = genericInteger.getKey();        Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;HELLO&quot;);        //自动获取Integer的eky        String key2 = genericString.getKey();    &#125;&#125;</code></pre><p>2.泛型接口 ：</p><pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public interface Generator&lt;T&gt; &#123;    public T method();&#125;/** * 实现泛型接口，不指定类型 */class GeneratorImplA&lt;T&gt; implements Generator&lt;T&gt;&#123;    @Override    public T method() &#123;        return null;    &#125;&#125;/** * 实现泛型接口，指定类型 */class GeneratorImplB&lt;T&gt; implements Generator&lt;String&gt;&#123;    @Override    public String method() &#123;        return &quot;hello&quot;;    &#125;&#125;class Main&#123;    public static void main(String[] args) &#123;        GeneratorImplA&lt;Integer&gt;  generatorImplA = new GeneratorImplA&lt;&gt;();        //传入Integer泛型，获取了Integer类型值        Integer method = generatorImplA.method();        //实现类本身是指定了String的泛型，返回就是String        Generator&lt;String&gt; stringGenerator = new GeneratorImplB&lt;&gt;();        String method2 = stringGenerator.method();    &#125;&#125;</code></pre><p>3、泛型方法</p><pre><code>class Main &#123;    public static &lt;E&gt; void printArray(E[] inputArray) &#123;        for (E element : inputArray) &#123;            System.out.printf(&quot;%s &quot;, element);        &#125;        System.out.println();    &#125;    public static void main(String[] args) &#123;        // 创建不同类型数组： Integer, Double 和 Character        Integer[] intArray = &#123; 1, 2, 3 &#125;;        String[] stringArray = &#123; &quot;Hello&quot;, &quot;World&quot; &#125;;        printArray( intArray  );        printArray( stringArray  );    &#125;&#125;</code></pre><p>**常用的通配符为： T，E，K，V，？</p><p>？ 表示不确定的 java 类型<br>T (type) 表示具体的一个 java 类型<br>K V (key value) 分别代表 java 键值中的 Key Value<br>E (element) 代表 Element</p><p><strong>? T 区别：</strong><br>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map-批量remove.md</title>
      <link href="/2022/03/20/map-pi-liang-remove/"/>
      <url>/2022/03/20/map-pi-liang-remove/</url>
      
        <content type="html"><![CDATA[<p>saveMap.keySet().removeAll(errMap.keySet());</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objects-equals-比较Long和Integer-一定记得加L.md</title>
      <link href="/2022/03/20/objects-equals-bi-jiao-long-he-integer-yi-ding-ji-de-jia-l/"/>
      <url>/2022/03/20/objects-equals-bi-jiao-long-he-integer-yi-ding-ji-de-jia-l/</url>
      
        <content type="html"><![CDATA[<p> if (Objects.equals(1L, groupListSize)) {<br><img src="https://upload-images.jianshu.io/upload_images/13965490-85d8db3ce824e1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>article-title.md</title>
      <link href="/2022/03/20/article-title/"/>
      <url>/2022/03/20/article-title/</url>
      
        <content type="html"><![CDATA[<hr><p>title: article title<br>top: false<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2022-03-20 18:54:13<br>password:<br>summary:<br>tags:<br>categories:</p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eques.md</title>
      <link href="/2022/03/20/eques/"/>
      <url>/2022/03/20/eques/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>assertTrue、assertEquals.md</title>
      <link href="/2022/03/20/asserttrue-assertequals/"/>
      <url>/2022/03/20/asserttrue-assertequals/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>forEachRemaining继续输出其余的元素.md</title>
      <link href="/2022/03/20/foreachremaining-ji-xu-shu-chu-qi-yu-de-yuan-su/"/>
      <url>/2022/03/20/foreachremaining-ji-xu-shu-chu-qi-yu-de-yuan-su/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first.md</title>
      <link href="/2022/03/20/first/"/>
      <url>/2022/03/20/first/</url>
      
        <content type="html"><![CDATA[<hr><p>title: first<br>top: false<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2021-05-02 18:45:23<br>password:<br>summary:<br>tags:<br>categories:</p><hr><p>###first</p><p><img src="./kw.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java--jar-运行，带引号解决参数中包含等号的问题.md</title>
      <link href="/2022/03/20/java-jar-yun-xing-dai-yin-hao-jie-jue-can-shu-zhong-bao-han-deng-hao-de-wen-ti/"/>
      <url>/2022/03/20/java-jar-yun-xing-dai-yin-hao-jie-jue-can-shu-zhong-bao-han-deng-hao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>java -jar identityauthsrv-1.0.5-base-linux-release.jar –spring.datasource.url=”jdbc:mysql://localhost:3306/iam?characterEncoding=utf8&amp;useSSL=false” –server.port=8077 </p><pre><code>java -jar ruoyi-admin.jar --server.port=8081 --business.apk.apkPath=&quot;file:/home/ca/iam-vue/apk&quot; --business.pdf.basePath=&quot;/home/ca/pdfstone&quot; </code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-8中使用Optional-避免空指针.md</title>
      <link href="/2022/03/20/java-8-zhong-shi-yong-optional-bi-mian-kong-zhi-zhen/"/>
      <url>/2022/03/20/java-8-zhong-shi-yong-optional-bi-mian-kong-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Optional 类的引入要求程序员强制处理和避免空指针。Optional 需要使用在可能为null的变量上。很多时候，程序员都是不判空的，这些BUG就像定时炸弹一样，使用Optional 类等于强迫程序员做好判空处理，减少可能的损失。</p></blockquote><p>Optional 类的设计是十分必要的，提前处理可能发生的错误，而不是等到逻辑处理完了再报告错误。<br>如果返回的null不会终止代码逻辑的运行，比如Java的Map的get方法传了错误类型的key返回null，那么开发者可能会花大量的时间去定位错误的原因，尤其是对于那些庞大的系统来说，无疑是大海捞针。<br>Scala、lisp、hashshell、erlang等函数式编程语言无一例外地，都对NullPointerException进行了处理，都有Optional的概念，Java8是借鉴了他们。 </p><p>###阿里手册中也提到我们需要使用 Optional 类<br>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<br>1）  返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。<br> 反例：<br>public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。<br>2） 数据库的查询结果可能为 null。<br>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。<br>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。<br>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。<br>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。<br>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p><p>###Optional 使用思路<br>解决办法就是3个步骤：<br>• 包装value：of(x)传入的对象不能为null，而ofNullable(x)是支持传入null的对象，一般用使用<code>Optional.ofNullable()</code>。<br>• 逐层安全地拆解value：map()。<br>• 最终返回：orElse()/orElseGet()/orElseThrow()。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-d4b848d63b4ec476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###使用示例<br>Person 类</p><pre><code>public class Person &#123;    private String name;    private Integer age;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +            &quot;, age=&quot; + age +            &#39;&#125;&#39;;    &#125;&#125;</code></pre><p><strong>用法1、使用内部的ofNullable去掉if的写法，将返回值set到其它对象</strong><br>我比喜欢用这个方法，毕竟不要写if xx!=null 。可以直接在ifPresent() 小括号里写各种逻辑。</p><pre><code>    public static void main(String[] args) &#123;        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, &quot;kawai&quot;);        objectObjectHashMap.put(&quot;age&quot;, 18);        Person a = new Person();        //TODO 使用内部的ifPresent避免了空指针异常        Optional.ofNullable(objectObjectHashMap.get(&quot;name1&quot;))            .ifPresent(name -&gt; a.setName(name.toString().toUpperCase()));        Optional.ofNullable(objectObjectHashMap.get(&quot;age1&quot;))            .ifPresent(age -&gt; a.setAge(Integer.valueOf(age.toString()) + 18));        System.out.println(a);    &#125;</code></pre><p><strong>用法2、链式调用map()方法。消除多重if xxx!=null; 嵌套</strong><br>想要实现a、b、c三个变量的加法乘法的组合运算。但是三个变量都有可能为null。所以需要加三层if判断：</p><pre><code>Integer a = getA(); if (a != null) &#123;  Integer b = getB();  if ( b != null) &#123;    Integer c = getC();    if ( c != null) &#123;      return (a + b) * c;    &#125; else return null;  &#125; else return null;&#125; else return null;</code></pre><p>改写成这样，是不是简洁很多了？</p><pre><code>Optional&lt;Integer&gt; result = Optional.ofNullable(getA())                             .flatMap(a   -&gt; Optional.ofNullable(getB()).map( b -&gt; a + b ))                             .flatMap(sum -&gt; Optional.ofNullable(getC()).map( c -&gt; sum * c ))</code></pre><p><strong>用法3、使用orElse，为null则返回默认值</strong> </p><pre><code>    static class UserMapper &#123;        public static BizUser selectBizUserByEmployeeNum(String employeeNum) &#123;            return null;        &#125;    &#125;    public static Integer run() &#123;        BizUser user = UserMapper.selectBizUserByEmployeeNum(&quot;3306&quot;);        return Optional.ofNullable(user).map(BizUser::getDeptId)            .filter(deptId -&gt; deptId.intValue() != 0).orElse(1122);    &#125;    public static void main(String[] args) &#123;        Integer run = run();        System.out.println(run);    &#125;</code></pre><p><strong>用法4、使用orElseThrow，为null则抛出异常到上层中断执行</strong></p><pre><code>    static class UserMapper&#123;        public static BizUser selectBizUserByEmployeeNum(String employeeNum) &#123;            return null;        &#125;    &#125;    public static void main(String[] args) &#123;        BizUser user = UserMapper.selectBizUserByEmployeeNum(&quot;3306&quot;);        Optional.ofNullable(user).map(BizUser::getDeptId).filter(deptId -&gt; deptId.intValue() != 0)            .orElseThrow(() -&gt; new CustomException(&quot;查询到的user为空！&quot;));    &#125;</code></pre><p><strong>用法5、使用filter完成除非空判断以外的其它判断</strong><br>另外，如果你需要对返回值进行判断，比如结果是否大于某个值等，可以使用Optional的filter方法。</p><pre><code>        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, &quot;kawai&quot;);        objectObjectHashMap.put(&quot;age&quot;, 19);        //TODO 使用内部的ifPresent避免了空指针异常        Object a = Optional.ofNullable(objectObjectHashMap.get(&quot;age&quot;))            .filter(age -&gt; Integer.parseInt(age.toString()) &gt;= 18).orElse(18);        System.out.println(a);</code></pre><p>###来看看错误用法（滥用Optional）</p><p><strong>错误用法1、把if xx！=null 换成了 name1.isPresent()</strong><br>这种方法和if xx！=null 差不多，还有if条件。不好用！把isPresent()当做判断空指针的方法，又回归以前的if嵌套，毫无意义 。 个人觉得isPresent()不应该暴露出来，放在Optional内部使用更好。</p><pre><code>public static void main(String[] args) &#123;        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, &quot;小明&quot;);        objectObjectHashMap.put(&quot;age&quot;, 18);        Person a = new Person();        Optional&lt;Object&gt; name1 = Optional.ofNullable(objectObjectHashMap.get(&quot;name1&quot;));        if (name1.isPresent()) &#123;            a.setName(name1.get().toString().toUpperCase());        &#125;        Optional&lt;Object&gt; age = Optional.ofNullable(objectObjectHashMap.get(&quot;age1&quot;));        if (age.isPresent()) &#123;            a.setAge(Integer.valueOf(age.get().toString()) + 18);        &#125;        System.out.println(a);    &#125;&#125;</code></pre><p><strong>错误用法2、这样还是会出现空指针，因为get()后返回的就是裸露的值</strong></p><pre><code>    public static void main(String[] args) &#123;        HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();        objectObjectHashMap.put(&quot;name&quot;, null);        objectObjectHashMap.put(&quot;age&quot;, 18);        Person a = new Person();        //TODO 下面的语句还是会报空指针NoSuchElementException，get()方法返回的是裸露的值。        String name = Optional.ofNullable(objectObjectHashMap.get(&quot;name&quot;)).get().toString()            .toUpperCase();        a.setName(name);        Optional.ofNullable(objectObjectHashMap.get(&quot;age&quot;))            .ifPresent(age -&gt; a.setAge(Integer.valueOf(age.toString()) + 18));        System.out.println(a);    &#125;</code></pre><blockquote><p>注意：请不要直接使用get()方法获得值，因为它还是会造成空指针。</p></blockquote><p><strong>错误用法3、被Optional.ofNullable()包装的表达式这样写照样出现空指针</strong></p><pre><code>Optional.ofNullable(((Integer) null).toString()).orElse(&quot;123&quot;);</code></pre><p>请使用map()函数把toString()方法单独提出来。</p><pre><code>Optional.ofNullable(((Integer) null)).map(m-&gt;m.toString()).orElse(&quot;123&quot;);</code></pre><p>###orElse和orElseGet有什么区别？</p><p>对比下面代码的执行结果：<br>eg1</p><pre><code>    private static Integer query()&#123;        System.out.println(&quot;查询值&quot;);        return 1122;    &#125;    public static void main(String[] args) &#123;        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(1);        map.put(&quot;age1&quot;,1);        System.out.println(Optional.ofNullable(map.get(&quot;age1&quot;)).orElse(query())) ;    &#125;</code></pre><blockquote><p>查询值<br>1122</p></blockquote><p>eg2</p><pre><code>    private static Integer query()&#123;        System.out.println(&quot;查询值&quot;);        return 1122;    &#125;    public static void main(String[] args) &#123;        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(1);        map.put(&quot;age1&quot;,1);        System.out.println(Optional.ofNullable(map.get(&quot;age1&quot;)).orElseGet(()-&gt;query())) ;    &#125;</code></pre><blockquote><p>1</p></blockquote><p>显然，当ofNullable内部参数非空时，不会去调用默认值里的方法去获取默认值。这也算是一个优化。若query()方法实现是一个网络请求或者数据库操作这样的耗时操作。那么这里请使用orElseGet而不是orElse！<br>当然若默认值只是一个常量，那么使用orElse语法更简洁。</p><p>###使用注意<br><strong>不能使用Optional到java bean的属性中</strong><br>由于Optional并没有实现Serializable接口，所以不推荐直接作为pojo字段使用。</p><p><strong>不推荐将方法返回值设置为Optional</strong><br>虽然Optional能够防止空指针，有些类里的方法强制把返回值都定为Optional类型。<br>1、比如java8的stream流api<br>java.util.stream.Stream</p><pre><code>    Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</code></pre><p>2、JPA返回值就是Optional。</p><p>3、但是我们平时工作还是不用使用他为返回值比较好。作为内部方法的返回值，免去调用时手动包装，但这意味着强制调用者使用Optional，但不是所有人都会用这个东西。</p><p>应该把Optional当做一个简单的工具类，是一个纯主观意愿的。想用就用吧，咱也不强制别人用。</p><p>###其它三个类OptionalDouble、OptionalInt、OptionalLong<br>自己用的比较少。<br>它们的of方法形参是基本类型的，也就是说传null会报空指针：</p><pre><code>    /**     * Return an &#123;@code OptionalInt&#125; with the specified value present.     *     * @param value the value to be present     * @return an &#123;@code OptionalInt&#125; with the value present     */    public static OptionalInt of(int value) &#123;        return new OptionalInt(value);    &#125;</code></pre><p>主要了解它们的getAsInt()、getAsDouble()、getAsLong() 方法。</p><pre><code>    public static void main(String[] args) &#123;        OptionalInt op = OptionalInt.of(0);        if (op.isPresent())&#123;            //获得OptionalInt对象里面的值，输出1            System.out.println(op.getAsInt());        &#125;        op.ifPresent((value) -&gt; System.out.println(&quot;value：&quot; + value));        //创建一个空值对象        OptionalInt opint = OptionalInt.empty();        if (opint.isPresent()) &#123;            //和Optional一样，输出No value present            System.out.println(opint.getAsInt());        &#125; else &#123;            //如果没有值，赋初始值            System.out.println(opint.orElse(222));            //如果没有值，赋初始函数            System.out.println(opint.orElseGet(() -&gt; 333));        &#125;        //如果没有值则抛出异常        opint.orElseThrow(NullPointerException::new);    &#125;</code></pre><p>###实践</p><p>1、解析json</p><pre><code>    public static void main(String[] args) &#123;        String json = &quot;&#123;\n&quot;            + &quot;    \&quot;responseResult\&quot;: &#123;\n&quot;            + &quot;        \&quot;status\&quot;: 0,\n&quot;            + &quot;        \&quot;msg\&quot;: \&quot;成功\&quot;\n&quot;            + &quot;    &#125;,\n&quot;            + &quot;    \&quot;contents\&quot;: &#123;\n&quot;            + &quot;        \&quot;total\&quot;: 1,\n&quot;            + &quot;        \&quot;currentRowsSize\&quot;: 1,\n&quot;            + &quot;        \&quot;rows\&quot;: [\n&quot;            + &quot;            &#123;\n&quot;            + &quot;                \&quot;id\&quot;: 551,\n&quot;            + &quot;                \&quot;name\&quot;: \&quot;学生二\&quot;,\n&quot;            + &quot;                \&quot;phone\&quot;: \&quot;15099955982\&quot;\n&quot;            + &quot;            &#125;\n&quot;            + &quot;        ]\n&quot;            + &quot;    &#125;\n&quot;            + &quot;&#125;&quot;;        final String[] msg = &#123;&quot;&quot;&#125;;        JSONObject jsonObject = JSONObject.parseObject(json);        Optional.ofNullable(jsonObject)            .map(m1 -&gt; m1.getJSONObject(&quot;responseResult&quot;))            .filter(m2 -&gt; &#123;                msg[0] = m2.getString(&quot;msg&quot;);                return m2.getInteger(&quot;status&quot;) == 0;            &#125;)            .orElseThrow(() -&gt; new RuntimeException(String.format(&quot;netca 获取授权list失败，%s&quot;, msg[0])));        JSONArray objects = Optional.ofNullable(jsonObject).map(m -&gt; m.getJSONObject(&quot;contents&quot;))            .map(m -&gt; m.getJSONArray(&quot;rows&quot;))            .orElseThrow(() -&gt; new RuntimeException(&quot;netca 获取授权list失败，miss contents.rows&quot;));        System.out.println(objects);    &#125;</code></pre><p>2、下面demo展示如何在流获取时兼顾多个字段。这里有：m.getString(“msg”)和 m.getInteger(“status”)<br>在map内部得到json返回值的msg字段，并见它赋值给 msg[0]。随后在Throw Exception中用到。</p><blockquote><p>还有可以注意的是判断json返回状态码的写法</p></blockquote><pre><code>        jsonObject = Optional.ofNullable(JSON.parseObject(respResult))            .map(m -&gt; m.getJSONObject(&quot;responseResult&quot;)).map(m -&gt; &#123;                msg[0] = m.getString(&quot;msg&quot;);                return m;            &#125;)            .filter(m -&gt; m.getInteger(&quot;status&quot;) == 0)            .orElseThrow(                () -&gt; new CloudsignException(-15,                    String.format(&quot;netca授权签名获得授权人userToken失败,%s&quot;, msg[0])));</code></pre><p>3、Optional.map()，只能一条路走到黑，顶多使用 m-&gt;{return m } 获取同级别的节点。但是绝对不能回头。如果想走两条路，那么请用两个 Optional.ofNullable。暂时我也没找到更好的办法。<br>下面有两条路。一条路拿responseResult.status/responseResult.msg；一条路拿contents.signCert；<br>所以用了两次 <code>Optional.ofNullable</code></p><pre><code>        JSONObject jsonObject = JSONObject.parseObject(respResult);        Optional.ofNullable(jsonObject)            .map(m -&gt; m.getJSONObject(&quot;responseResult&quot;)).map(m -&gt; &#123;                msg[0] = m.getString(&quot;msg&quot;);                return m;            &#125;)            .filter(m -&gt; m.getInteger(&quot;status&quot;) == 0).orElseThrow(                () -&gt; new CloudsignException(-12,                    String.format(&quot;netca 获取base64cert失败,%s&quot;, msg[0])));        String signCert = Optional            .ofNullable(jsonObject)            .map(m -&gt; m.getJSONArray(&quot;contents&quot;)).map(m -&gt; m.getJSONObject(0))            .map(m -&gt; m.getString(&quot;signCert&quot;))            .orElseThrow(                () -&gt; new CloudsignException(-13, &quot;netca 获取base64cert失败，miss contents.signCert&quot;));</code></pre><p>4、</p><pre><code>    public static String getDescByCode(Integer code, UserEnum userEnum) &#123;        final Map&lt;Integer, SignedReturnOption&gt; all = getAll();        if (all.keySet().contains(code)) &#123;            final SignedReturnOption signedReturnOption = all.get(code);            return Optional.ofNullable(signedReturnOption).map(m -&gt; m.userEnum.equals(userEnum) ? signedReturnOption.desc : Constant.NOT_ME).orElse(null);        &#125;        return null;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-9、11、17.md</title>
      <link href="/2022/03/20/java-9-11-17/"/>
      <url>/2022/03/20/java-9-11-17/</url>
      
        <content type="html"><![CDATA[<p>1、9的dropWhile方法与filter的区别</p><pre><code>        System.out.println(&quot;dropWhile方法&quot;);        //abcde        Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,            &quot;d&quot;, &quot;e&quot;).dropWhile(name -&gt; (name.charAt(0) != &#39;a&#39;)).forEach(System.out::print);        System.out.println();        System.out.println(&quot;filter方法&quot;);        //a        Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,            &quot;d&quot;, &quot;e&quot;).filter(name -&gt; (name.charAt(0) == &#39;a&#39;)).forEach(System.out::print);</code></pre><p>dropWhile丢弃条件所在集合开头的所有项目true。一旦第一项失败，它就会停止丢弃。<br>filter丢弃整个集合中条件不正确的所有项目。它直到收集结束才停止。</p><p>2、9的takeWhile</p><p>Stream中依次获取满足条件的元素，直到不满足条件为止结束获取<br>举例：Stream中的元素 12, 4, 3, 6, 8, 9<br>条件是 x -&gt; x % 2 == 0 ，即判断是否为偶数，即当遇到元素不为偶数时终止获取<br>那么得到的结果输出就是，12, 4 因为下一个元素为3不为偶数，即结束获取，丢弃后面的其他元素</p><pre><code>IntStream.of(12, 4, 3, 6, 8, 9).takeWhile(x -&gt; x % 2 == 0).forEach(System.out::print);</code></pre><p>3、JDK12提供的新聚合方法<br>//流分别经过downstream1、downstream2聚合处理，再合并两聚合结果<br>public static &lt;T, R1, R2, R&gt; Collector&lt;T, ?, R&gt; teeing(<br>        Collector&lt;? super T, ?, R1&gt; downstream1,<br>        Collector&lt;? super T, ?, R2&gt; downstream2,<br>        BiFunction&lt;? super R1, ? super R2, R&gt; merger)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-DTO-DO-VO.md</title>
      <link href="/2022/03/20/java-dto-do-vo/"/>
      <url>/2022/03/20/java-dto-do-vo/</url>
      
        <content type="html"><![CDATA[<p>《阿里巴巴开发手册》以及网上各种博客或多或少都有提到诸如DTO、DO、BO、PO、VO等等，也提倡对实体类进行分层。至于为什么要分层，它们的理由是“避免暴露内部设计细节，只展示必要的字段”，但我个人最大的感受其实是“解耦”。我曾遇到一件无奈的事，接口已经开发完毕，前后端也联合好了，结果产品临时要大改，Service层的逻辑基本要推倒重来，连查的表都不一样了。好在得益于DTO和VO的隔离，并没有影响到其它层，前端甚至完全不知道后端全部重写了，Swagger文档也和原来一模一样…</p><p>不过个人觉得没必要去扣这些概念，比如BO、PO是啥我也记不清。一般来说，POJO分为三类即可：</p><ul><li> 客户端/前端传入的DTO</li><li>与数据库字段映射的DO</li><li>返回给客户端/前端的VO</li></ul><p>DO和VO一般没太多争议，至于DTO，有些公司又会细分各种O，至于有没有必要，则是仁者见仁智者见智了。</p><p>使用DTO DO VO的话，自然就避免不了<code>对象的深拷贝</code>了。</p><p>数据从DTO-&gt;DO 持久化到数据库中。<br>DO-&gt;VO 数据从库中出来放到视图模型VO中返回给前端。</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-3b6ccdf84cd15863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-error捕获.md</title>
      <link href="/2022/03/20/java-error-bu-huo/"/>
      <url>/2022/03/20/java-error-bu-huo/</url>
      
        <content type="html"><![CDATA[<pre><code>package org.szwj.ca.identityauthsrv;import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import javax.imageio.ImageIO;import javax.imageio.stream.ImageOutputStream;import org.apache.commons.io.FileUtils;import org.szwj.ca.identityauthsrv.util.common.ImageUtils;public class DrawDemo &#123;    public static void main(String[] args) throws FileNotFoundException, IOException &#123;        /**         * 直接捕获error         */        try &#123;            byte[] bytes = new byte[1024 * 1024 * 10*10];        &#125;catch (Error error)&#123;            System.out.println(error.getMessage());        &#125;        /**         * 捕获error和exption的分类Throwable         */        try &#123;            byte[] bytes = new byte[1024 * 1024 * 10*10];        &#125;catch (Throwable throwable)&#123;            System.out.println(throwable.getMessage());        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-Map接口和抽象类分析总结.md</title>
      <link href="/2022/03/20/java-map-jie-kou-he-chou-xiang-lei-fen-xi-zong-jie/"/>
      <url>/2022/03/20/java-map-jie-kou-he-chou-xiang-lei-fen-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>java.util.SortedMap</p><p>java.util.NavigableMap</p><p>抽象类<br>  java.util.AbstractMap</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-jdk1-8新特性之Stream流.md</title>
      <link href="/2022/03/20/java-jdk1-8-xin-te-xing-zhi-stream-liu/"/>
      <url>/2022/03/20/java-jdk1-8-xin-te-xing-zhi-stream-liu/</url>
      
        <content type="html"><![CDATA[<p>jdk8提供的Stream流能够方便操作集合、数组<br>java.util.stream包即是Stream流式计算的核心</p><p>###Stream流的特点</p><ul><li>Stream自己不会存储元素</li><li>Stream <code>不会改变源对象</code>，相反，他们会返回一个持有结果的新Stream </li><li>Stream 操作总是延迟执行的。这意味着他们会等到需要结果的时候才执行</li></ul><p>###基础用法<br>①、从数据源中获得流 ==&gt; 一个数据源(数组、List)</p><pre><code>arrayList.stream()</code></pre><p>②、中间操作==&gt;处理数据源数据</p><pre><code> .map(e -&gt; e.get(&quot;a&quot;))</code></pre><p>③、终止操作==&gt;执行中间操作链，产生结果</p><pre><code> .collect(Collectors.toList());</code></pre><p>###获得流<br>######普通流stream()</p><pre><code>import java.util.Arrays;import java.util.List;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);        // 获取空字符串的数量        int count = (int) strings.stream().filter(string -&gt; string.isEmpty()).count();        System.out.println(count);    &#125;&#125;</code></pre><p>######并行流 parallelStream()<br>parallelStream 是流并行处理程序的代替方法。以下实例我们使用parallelStream 来输出空字符串的数量：</p><pre><code>import java.util.Arrays;import java.util.List;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);        // 获取空字符串的数量        int count = (int) strings.parallelStream().filter(string -&gt; string.isEmpty()).count();        System.out.println(count);    &#125;&#125;</code></pre><p>###中间操作<br><img src="https://upload-images.jianshu.io/upload_images/13965490-6d3cbd62a24e4d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/13965490-af3b89b1daaf040a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/13965490-757a575b70c295aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h6><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数：</p><pre><code>import java.util.Random;public class Test &#123;    public static void main(String[] args) &#123;        Random random = new Random();        random.ints().limit(10).forEach(System.out::println);    &#125;&#125;</code></pre><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><pre><code>import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);        // 获取对应的平方数        List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i * i).collect(Collectors.toList());        squaresList.forEach(System.out::println);    &#125;&#125;</code></pre><p>######filter<br>filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串，然后统计数量：</p><pre><code>import org.apache.commons.lang3.StringUtils;import java.util.Arrays;import java.util.List;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot; &quot;, null,&quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot; &quot;, &quot;jkl&quot;);        // 获取空字符串的数量        int count = (int) strings.stream().filter(string -&gt; StringUtils.isBlank(string)).count();        System.out.println(count);    &#125;&#125;</code></pre><p>######Limit</p><p>limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据：</p><pre><code>import java.util.Random;public class Test &#123;    public static void main(String[] args) &#123;        Random random = new Random();        random.ints().limit(10).forEach(System.out::println);    &#125;&#125;</code></pre><p>######sorted</p><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><pre><code>import java.util.Random;public class Test &#123;    public static void main(String[] args) &#123;        Random random = new Random();        random.ints().limit(10).sorted().forEach(System.out::println);    &#125;&#125;</code></pre><p>###终止操作<br>######Collectors 转化为集合、聚合元素、字符串</p><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</p><pre><code>import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);        List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());        System.out.println(&quot;筛选列表: &quot; + filtered);        String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));        System.out.println(&quot;合并字符串: &quot; + mergedString);    &#125;&#125;</code></pre><p>######summaryStatistics 统计<br>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><pre><code>import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);        IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();        System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());        System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());        System.out.println(&quot;所有数之和 : &quot; + stats.getSum());        System.out.println(&quot;平均数 : &quot; + stats.getAverage());    &#125;&#125;</code></pre><p>###Stream流使用实战<br>1、从List<Map>中抽离出map中特定key对应的value所组成的List</p><pre><code>import java.util.*;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Map&lt;String, String&gt;&gt; arrayList = new ArrayList();        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","hhhhhhhhh");            put("b","kkkkkkkkk");        &#125;&#125;);        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","fffffffff");            put("b","gggggggggg");        &#125;&#125;);        List&lt;String&gt; list = arrayList.stream()                .map(e -&gt; e.get(&quot;a&quot;))                .collect(Collectors.toList());        list.forEach(System.out::println);    &#125;&#125;</code></pre><p>2、List<Map> 根据key查找</p><pre><code>import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.stream.Collectors;public class Test &#123;    public static void main(String[] args) &#123;        List&lt;Map&lt;String, String&gt;&gt; arrayList = new ArrayList();        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","hhhhhhhhh");            put("b","kkkkkkkkk");        &#125;&#125;);        arrayList.add(new HashMap&lt;String,String&gt;()&#123;&#123;            put("a","fffffffff");            put("b","gggggggggg");        &#125;&#125;);        List&lt;Map&lt;String, String&gt;&gt; list = arrayList.stream().filter(e -&gt; e.keySet().contains(&quot;a&quot;)).collect(Collectors.toList());        System.out.println(list);    &#125;&#125;</code></pre><p>3、过滤掉List<Java Bean>中符合过滤条件的Java Bean</p><pre><code>import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;@Data@AllArgsConstructor@NoArgsConstructorpublic class Test &#123;    private String name;    private Integer age;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,new Test(&quot;yink&quot;,24),new Test(&quot;yinx&quot;,12), new Test(&quot;hh&quot;,13));        List&lt;Test&gt; testList = list.stream().filter(test -&gt; !test.getName().equals(&quot;hh&quot;)&amp;&amp;test.getAge()!=13).collect(Collectors.toList());        System.out.println(testList);    &#125;&#125;</code></pre><pre><code>import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.Arrays;import java.util.List;import java.util.UUID;import java.util.function.*;@Data@NoArgsConstructor@AllArgsConstructorclass User &#123;    private Integer id;    private String userName;    private int age;&#125;/** * @create 2019-02-26 22:24 * &lt;p&gt; * 题目：请按照给出数据，找出同时满足 * 偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序 * 最后只输出一个用户名字 */public class StreamDemo &#123;    public static void main(String[] args) &#123;        User u1 = new User(11, &quot;a&quot;, 23);        User u2 = new User(12, &quot;b&quot;, 24);        User u3 = new User(13, &quot;c&quot;, 22);        User u4 = new User(14, &quot;d&quot;, 28);        User u5 = new User(16, &quot;e&quot;, 26);        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);        list.stream().filter(p -&gt; &#123;            return p.getId() % 2 == 0;        &#125;).filter(p -&gt; &#123;            return p.getAge() &gt; 24;        &#125;).map(f -&gt; &#123;            return f.getUserName().toUpperCase();        &#125;).sorted((o1, o2) -&gt; &#123;            return o2.compareTo(o1);        &#125;).limit(1).forEach(System.out::println);    &#125;&#125;</code></pre><p>4、List<Java Bean>根据Java Bean的一个属性去重</p><pre><code>import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.*;import java.util.stream.Collectors;@Data@AllArgsConstructor@NoArgsConstructorpublic class Test &#123;    private String name;    private Integer age;    public static void main(String[] args) &#123;        ArrayList&lt;Test&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,new Test(&quot;yink&quot;,24),new Test(&quot;yink&quot;,12), new Test(&quot;hh&quot;,13));        ArrayList&lt;Test&gt; collect = list.stream().collect(                Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Test::getName))), ArrayList::new)        );        System.out.println(collect);    &#125;&#125;</code></pre><pre><code>       /**         * 按platformOrderNo去重excel集合         */        dataList = dataList.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(()                -&gt; new TreeSet&lt;&gt;(Comparator.comparing(JgOriginalOrder::getPlatformOrderNo))), ArrayList::new));</code></pre><p>5、根据具体属性查找list中的对象</p><pre><code> TbBox tbBox = boxs.stream().filter(u -&gt; u.getSbNumber().equals(&quot;123456&quot;)).findAny().get();</code></pre><p>6、List按字段分组</p><pre><code>  Map&lt;String, List&lt;CertInfoPO&gt;&gt; collect = certSet.stream()                    .collect(Collectors.groupingBy(CertInfoPO::getIdentityNumber));</code></pre><p>7、List<Bean>转 key-vue 形式的Map<code>列转行</code></p><pre><code>       List&lt;SysDictData&gt; face = sysDictDataService.selectDictDataByType(&quot;face&quot;);        Map&lt;String, String&gt; collect = face.stream()            .collect(Collectors.toMap(SysDictData::getDictLabel, SysDictData::getDictValue));</code></pre><p><strong>收集对象实体本身</strong><br>在开发过程中我们也需要有时候对自己的list中的实体按照其中的一个字段进行分组（比如 id -&gt;List），这时候要设置map的value值是实体本身。</p><pre><code>public Map&lt;Long, Account&gt; getIdAccountMap(List&lt;Account&gt; accounts) &#123;    return accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account));&#125;</code></pre><p>account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法 Function.identity()，这个方法返回自身对象，更加简洁</p><p><strong>重复key的情况。</strong><br>在list转为map时，作为key的值有可能重复，这时候流的处理会抛出个异常：Java.lang.IllegalStateException:Duplicate key。这时候就要在toMap方法中指定当key冲突时key的选择。(这里是选择第二个key覆盖第一个key)</p><pre><code>public Map&lt;String, Account&gt; getNameAccountMap(List&lt;Account&gt; accounts) &#123;    return accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2));&#125;</code></pre><p><strong>用groupingBy 或者 partitioningBy进行分组</strong><br>根据一个字段或者属性分组也可以直接用groupingBy方法，很方便。</p><pre><code>Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());&#125;</code></pre><p>8、count 统计</p><pre><code>                List&lt;Map&gt; reList = ((StockProductDetailRepository) stockProductDetailService.getBaseMapper()).getSupplierNoByk3Code(k3Code);                final long count = reList.stream()                        .map(m -&gt; m.get(&quot;firstTag&quot;))                        .filter(e -&gt; Objects.equals(e, 0))                        .count();</code></pre><p>9、Map 过滤方法流</p><pre><code>        /**         * 得到自定义字段         */        //jg_order_field_relationship 里的相关模板的数据除开这个枚举的之外就是自定义字段了        Map&lt;Integer, String&gt; myDefinitionMap = fieldMap.entrySet().stream()                .filter((e) -&gt; !definitionMap.keySet().contains(e.getValue()))                .collect(Collectors.toMap(                        (e) -&gt; e.getKey(),                        (e) -&gt; e.getValue()                ));</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-Optional#ifPresent.md</title>
      <link href="/2022/03/20/java-util-optional-ifpresent/"/>
      <url>/2022/03/20/java-util-optional-ifpresent/</url>
      
        <content type="html"><![CDATA[<p>ifPresent 用于对过滤出的数据如果存在。如果经过过滤条件后，有数据的话就可以进行修改。</p><pre><code> Optional&lt;A&gt; firstA= AList.stream()                           .filter(a -&gt; &quot;小明&quot;.equals(a.getUserName()))                           .findFirst()                          .ifPresent(a -&gt; &#123;                              a.setUserName(&quot;明明&quot;);                          &#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-jdk1-8新特性之四种函数式接口.md</title>
      <link href="/2022/03/20/java-jdk1-8-xin-te-xing-zhi-si-chong-han-shu-shi-jie-kou/"/>
      <url>/2022/03/20/java-jdk1-8-xin-te-xing-zhi-si-chong-han-shu-shi-jie-kou/</url>
      
        <content type="html"><![CDATA[<p>java.util.function 包即是函数式编程的核心</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-d6eb0ce38b58c5ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-Optional-缺陷.md</title>
      <link href="/2022/03/20/java-util-optional-que-xian/"/>
      <url>/2022/03/20/java-util-optional-que-xian/</url>
      
        <content type="html"><![CDATA[<p>在这种时候使用新写法就有些鸡肋了。不要为了使用而使用。反而原来的写法可读性更好</p><pre><code>        Set&lt;String&gt; keySet = map.keySet();        for (String s : keySet) &#123;            String[] split1 = s.split(Constant.COLON);            String value = split1[Constant.NUMBER_ONE];            String[] split = value.split(Constant.COMMA);            if (ArrayUtils.contains(split, key)) &#123;                return s;            &#125;        &#125;</code></pre><p>改写</p><pre><code>        String[] re = new String[1];        boolean b = map.keySet().stream().map(s -&gt; &#123;                    re[0] = s;                    return s.split(Constant.COLON);                &#125;).flatMap(Arrays::stream).skip(1).limit(1).map(s -&gt; s.split(Constant.COMMA))                .anyMatch(split -&gt; ObjectUtil.contains(split, key));        if (b) &#123;            return re[0];        &#125;</code></pre><p>在执行 s.split(Constant.COMMA)时我想拿到前面执行后的数据只能使用 re[0]来记录</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-stream-Collectors#minBy-返回的Optional本身可能会空指针.md</title>
      <link href="/2022/03/20/java-util-stream-collectors-minby-fan-hui-de-optional-ben-shen-ke-neng-hui-kong-zhi-zhen/"/>
      <url>/2022/03/20/java-util-stream-collectors-minby-fan-hui-de-optional-ben-shen-ke-neng-hui-kong-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p>所以拿出这个 Optional对象也记得要判空！</p><p>   public static <T> Collector&lt;T, ?, Optional<T>&gt;<br>    minBy(Comparator&lt;? super T&gt; comparator) {<br>        return reducing(BinaryOperator.minBy(comparator));<br>    }</p><pre><code> //分组计算最小id                    Map&lt;Long, Optional&lt;ZskAccessoriesListDo&gt;&gt; zskQuestionsAndAnswersDoMap = saveZskAccessoriesListDoList.stream()                            .filter(m -&gt; ToolUtil.isNotEmpty(m.getId())).collect(Collectors.groupingBy(ZskAccessoriesListDo::getKnowledgeId,                                    Collectors.minBy(Comparator.comparingInt(o -&gt; ObjectUtil.defaultIfNull(o.getId(), 0).intValue()))));</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-util-stream-Stream#reduce.md</title>
      <link href="/2022/03/20/java-util-stream-stream-reduce/"/>
      <url>/2022/03/20/java-util-stream-stream-reduce/</url>
      
        <content type="html"><![CDATA[<p>实现用一个12345的list生成一个以”element-“ 为开头元素的List</p><pre><code>    public static void main(String[] args) &#123;        List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5, 6);        ArrayList&lt;String&gt; result = numList.stream().reduce(new ArrayList&lt;String&gt;(), (a, b) -&gt; &#123;            a.add(&quot;element-&quot; + Integer.toString(b));            return a;        &#125;, (a, b) -&gt; null);        System.out.println(result);    &#125;</code></pre><p>[element-1, element-2, element-3, element-4, element-5, element-6]</p><p>a 代表生成的list，b代表原始list的元素</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-中的位运算-位运算符(&amp;，--，^).md</title>
      <link href="/2022/03/20/java-zhong-de-wei-yun-suan-wei-yun-suan-fu/"/>
      <url>/2022/03/20/java-zhong-de-wei-yun-suan-wei-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<p>关于位运算符无非也就 与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;)</p><p>位运算其实就是二进制的运算，加减乘除适用于十进制，而位运算就是二进制的运算,但是由于我们的运算都是基于十进制来说的，所以会有点绕，略微有点难懂，接下来言归正传</p><h2 id="3-与运算符-amp"><a href="#3-与运算符-amp" class="headerlink" title="3) 与运算符(&amp;)"></a>3) 与运算符(&amp;)</h2><p>   如果  4&amp;7   那么这个应该怎么运算呢？</p><p>     首先我们需要把两个十进制的数转换成二进制 </p><p>     4 ： 0000 0100</p><p>     7 ： 0000 0111</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204022745-1107563193.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-2e94d35658d580b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>在这里要提到一点，1表示true，0表示false</p><p>而与运算的时候相同位之间其实就是两个Boolean的运算</p><p>全true(1),即为true(1)</p><p>全false(0),即为false(0)</p><p>一false(0)一true(1),还是false(0)</p><h2 id="4-或运算符"><a href="#4-或运算符" class="headerlink" title="4)或运算符(|)"></a>4)或运算符(|)</h2><p>   以   5|9   为例</p><p>   5 ： 0000 0101 </p><p>   9 ： 0000 1001</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204023575-1172288145.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-35d76a0c19b6bfb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>在做与运算的时候</p><p>**                 遇true(1)就是true(1),**</p><p>**                 无true(1)就是false(0)**</p><h2 id="5-异或运算符"><a href="#5-异或运算符" class="headerlink" title="5) 异或运算符(^)"></a>5) 异或运算符(^)</h2><p>**           以 7^15 为例**</p><p>**           7：   0000 0111**</p><p>**           15： 0000 1111**</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204024149-967390106.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-f6c3b39087393bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>在异或的时候</p><p>               只要相同都是false(0)</p><p>               只有不同才是true(1)</p><h2 id="6-取反运算符"><a href="#6-取反运算符" class="headerlink" title="6) 取反运算符(~)"></a>6) 取反运算符(~)</h2><p>        例：   ~15</p><p>        同样的先变成二进制：15：0000 1111</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204024870-227422826.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-710777dfabde3ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>      这个其实挺简单的，就是把1变0，0变1</p><p>注意：二进制中，最高位是符号位   1表示负数，0表示正数</p><h2 id="7-左移运算-lt-lt"><a href="#7-左移运算-lt-lt" class="headerlink" title="7) 左移运算(&lt;&lt;)"></a>7) 左移运算(&lt;&lt;)</h2><p>左移就是把所有位向左移动几位</p><p>如：   12 &lt;&lt; 2    意思就是12向左移动两位</p><p>12的二进制是： 0000 1100</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025326-1518482974.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-38f503a210b7f5e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p>通过这个图我们可以看出来，所有的位全都向左移动两位，然后把右边空的两个位用0补上，最左边多出的两个位去掉，最后得到的结果就是00110000  结果就是48</p><p><strong>我们用同样的办法算 12&lt;&lt;3  结果是 96</strong></p><p>**                            8&lt;&lt;4  结果是  128**</p><p>**  由此我们得出一个快速的算法    M &lt;&lt; n   其实可以这么算   M &lt;&lt; n  = M * 2<sup>n</sup>**</p><h2 id="8-右移运算符-gt-gt"><a href="#8-右移运算符-gt-gt" class="headerlink" title="8) 右移运算符(&gt;&gt;)"></a><strong>8) 右移运算符(&gt;&gt;)</strong></h2><p><strong>这个跟左移运算大体是一样的</strong></p><p>**     例： 12 &gt;&gt; 2**</p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025862-1215072643.png"><img src="https://upload-images.jianshu.io/upload_images/13965490-6c06712655c236cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></a> </p><p><strong>我们可以看出来右移和左移其实是一样的，但是还是有点不同的，不同点在于对于正数和负数补位的时候补的不一样，负数补1，正数补0</strong></p><p><strong>如我们再做一个 –8 的    -8&gt;&gt;2</strong></p><p><a href="https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204026563-746326181.png"><strong><img src="https://upload-images.jianshu.io/upload_images/13965490-86488c1d8f0aedac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="image"></strong></a> </p><p><strong>这里总结一下，关于负数或者正数来说，移位的时候是一样的，但是在补位的时候，如果最高位是0就补0，如果最高位是1就补1</strong></p><p><strong>由此我们得出一个快速的算法    M &gt;&gt; n   其实可以这么算   M &gt;&gt; n  = M / 2^****n</strong></p><h2 id="9）无符号右移-gt-gt-gt"><a href="#9）无符号右移-gt-gt-gt" class="headerlink" title="9）无符号右移(&gt;&gt;&gt;)"></a>9）无符号右移(&gt;&gt;&gt;)</h2><p>无符号右移(&gt;&gt;&gt;)只对32位和64位有意义<br>在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0</p><p>  这个就不画图了</p><p>###补充<br>使用位运算来判断两个数符号是否相同</p><pre><code>       int a =1;        int b = 10000000;        boolean b1 = ((a &gt;&gt; 31) ^ (b &gt;&gt; 31)) == 0;        System.out.println(b1);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-代码积累.md</title>
      <link href="/2022/03/20/java-dai-ma-ji-lei/"/>
      <url>/2022/03/20/java-dai-ma-ji-lei/</url>
      
        <content type="html"><![CDATA[<p>1、集合逗号拼接<br>String join = org.apache.commons.lang3.StringUtils.StringUtils.join(doctorEmployeeNum,”,”);</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-内存中join-算法.md</title>
      <link href="/2022/03/20/java-nei-cun-zhong-join-suan-fa/"/>
      <url>/2022/03/20/java-nei-cun-zhong-join-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>这个有点像mysql join 算法</p><p>###double netsted for</p><pre><code>import java.util.ArrayList;import java.util.List;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;public class Join &#123;    @Data    @AllArgsConstructor    @NoArgsConstructor    static    class Couple &#123;        private Integer familyId;        private String userName;    &#125;    public static void main(String[] args) &#123;        // 用于计算循环次数        int count = 0;        // 老公组        List&lt;Couple&gt; husbands = new ArrayList&lt;&gt;();        husbands.add(new Couple(1, &quot;梁山伯&quot;));        husbands.add(new Couple(2, &quot;牛郎&quot;));        husbands.add(new Couple(3, &quot;干将&quot;));        husbands.add(new Couple(4, &quot;工藤新一&quot;));        husbands.add(new Couple(5, &quot;罗密欧&quot;));        // 老婆组        List&lt;Couple&gt; wives = new ArrayList&lt;&gt;();        wives.add(new Couple(1, &quot;祝英台&quot;));        wives.add(new Couple(2, &quot;织女&quot;));        wives.add(new Couple(3, &quot;莫邪&quot;));        wives.add(new Couple(4, &quot;毛利兰&quot;));        wives.add(new Couple(5, &quot;朱丽叶&quot;));        for (Couple husband : husbands) &#123;            for (Couple wife : wives) &#123;                // 记录循环的次数                count++;                if (husband.getFamilyId().equals(wife.getFamilyId())) &#123;                    System.out.println(husband.getUserName() + &quot;爱&quot; + wife.getUserName());                    // 把已经匹配的remove                    wives.remove(wife);                    //本次已经找到，再循环下去没有意义                    break;                &#125;            &#125;        &#125;        System.out.println(&quot;----------------------&quot;);        System.out.println(&quot;循环了：&quot; + count + &quot;次&quot;);    &#125;&#125;</code></pre><p>在本案例中，第三版算法在男嘉宾顺序时可以得到最好的结果（5次），如果倒序则得到最差的结果（15次）。</p><p>第二种算法，使用hash</p><h3 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h3><pre><code>    public static void main(String[] args) &#123;        // 用于计算循环次数        int count = 0;        // 老公组        List&lt;Couple&gt; husbands = new ArrayList&lt;&gt;();        husbands.add(new Couple(1, &quot;梁山伯&quot;));        husbands.add(new Couple(2, &quot;牛郎&quot;));        husbands.add(new Couple(3, &quot;干将&quot;));        husbands.add(new Couple(4, &quot;工藤新一&quot;));        husbands.add(new Couple(5, &quot;罗密欧&quot;));        // 老婆组        List&lt;Couple&gt; wives = new ArrayList&lt;&gt;();        wives.add(new Couple(1, &quot;祝英台&quot;));        wives.add(new Couple(2, &quot;织女&quot;));        wives.add(new Couple(3, &quot;莫邪&quot;));        wives.add(new Couple(4, &quot;毛利兰&quot;));        wives.add(new Couple(5, &quot;朱丽叶&quot;));        // 给女嘉宾发牌子        Map&lt;Integer, Couple&gt; wivesMap = new HashMap&lt;&gt;();        for (Couple wife : wives) &#123;            // 女嘉宾现在不在List里了，而是去了wivesMap中，前面放了一块牌子：男嘉宾的号码            wivesMap.put(wife.getFamilyId(), wife);            count++;        &#125;        // 男嘉宾上场        for (Couple husband : husbands) &#123;            // 找到举着自己号码牌的女嘉宾            Couple wife = wivesMap.get(husband.getFamilyId());            System.out.println(husband.getUserName() + &quot;爱&quot; + wife.getUserName());            count++;        &#125;        System.out.println(&quot;----------------------&quot;);        System.out.println(&quot;循环了：&quot; + count + &quot;次&quot;);    &#125;</code></pre><p>此时无论你如何调换男嘉宾出场顺序，都只会循环10次。</p><p>###小结</p><p>它的精髓就是利用HashMap给其中一列数据加了“索引”，每个数据的“索引”（Map的key）是不同的，让数据差异化。<br>了解原理后，如何掌握这简单有效的小算法呢？<br>记住两步：<br>• 先把其中一列数据由线性结构的List转为Hash散列的Map，为数据创建“索引”<br>• 遍历另一列数据，依据索引从Map中匹配数据<br>相比第三版在原有的两个List基础上操作数据，第四版需要额外引入一个Map，内存开销稍微多了一点点。算法中，有一句特别经典的话：空间换时间。第四版勉强算吧。但要清楚，实际上Couple对象并没有增多，Map只是持有原有的Couple对象的引用而已。新增的内存开销主要是Map的索引（Key）。<br>请大家务必掌握这个小算法，后面很多地方会用到它。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-使用ScheduledExecutorService来代替Timer.md</title>
      <link href="/2022/03/20/java-shi-yong-scheduledexecutorservice-lai-dai-ti-timer/"/>
      <url>/2022/03/20/java-shi-yong-scheduledexecutorservice-lai-dai-ti-timer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>志存高远</p></blockquote><p>《阿里巴巴Java开发手册》中有关于Timer和ScheduledExecutorService的用法说明如下</p><blockquote><p>【强制】 多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用ScheduledExecutorService 则没有这个问题。</p></blockquote><p>它要求使用ScheduledExecutorService来代替Timer</p><p>###先来看Timer</p><p>我们来看下列程序</p><pre><code>package io.renren;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123;    public static void main(String[] args) &#123;        Timer timer = new Timer();        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);            &#125;        &#125;,0,3*1000);        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;***&quot;+Thread.currentThread().getName()+&quot;***&quot;);            &#125;        &#125;,0,3*1000);    &#125;&#125;</code></pre><p>一个Timer运行了2个TimerTask，TimerTask的run方法每3秒执行一次。打印了执行run方法的线程名；可以看到它们是使用同一个<code>Timer-0</code>线程来执行任务的<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c90e4d9d5906bbbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>######Timer的任务出现异常可能导致其他任务不被执行<br>因为Timer总是使用单个线程来执行多个TimerTask的，这样一个TimerTask抛出异常会影响到其它TimerTask的执行 ~<br>如下给 其中一个抛出一个运行时异常看看会怎么样呢？</p><pre><code>package io.renren;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123;    public static void main(String[] args) &#123;        Timer timer = new Timer();        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);            &#125;        &#125;,0,3*1000);        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                int i = 1/0;                System.out.println(&quot;***&quot;+Thread.currentThread().getName()+&quot;***&quot;);            &#125;        &#125;,0,3*1000);    &#125;&#125;</code></pre><p>运行上面程序古，可以看到线程直接退出了<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c2546a27aa86b6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>TimerTask抛出的未检查的异常会终止timer线程，此后已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了</p></blockquote><p>######执行耗时的TimerTask会影响其它TimerTask的执行<br>我们再来看如下例子</p><pre><code>package io.renren;import java.sql.Time;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) &#123;        Timer timer = new Timer();        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;            System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);                try &#123;                    TimeUnit.SECONDS.sleep(10);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,0,3*1000);        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;                System.out.println(&quot;***&quot;+Thread.currentThread().getName()+&quot;***&quot;);            &#125;        &#125;,0,3*1000);    &#125;&#125;</code></pre><p>执行程序就会发现第二个TimerTask迟迟得不到执行。这也是Timer的单线程执行导致的缺点</p><blockquote><p>创建Timer的时候会创建TimerThread做为执行线程，所以一个Timer对应一个线程，如果一个TimerTask执行的时间过长，其他的TimerTask只能等待。</p></blockquote><p>######Timer的执行时基于系统的绝对时间的<br>如果系统的绝对时间被改变，那么Timer的执行将被影响！</p><p>如下程序，设定等到2020-03-18 10:04:00 时就会触发调用TimerTask。如果我在之前将系统的时间修改，那么改程序就无法得到准确的执行了。</p><p>我将时间修改为 2020-03-17 日。今天其实是18日。执行下列程序。就发现TimerTask迟迟得不到执行</p><pre><code>package io.renren;import java.sql.Time;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) throws ParseException &#123;        Timer timer = new Timer();        SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);        Date parse = ft.parse(&quot;2020-03-18 10:04:00&quot;);        /**         * 3秒打印一次线程名         */        timer.schedule(new TimerTask() &#123;            @Override            public void run() &#123;               System.out.println(&quot;===&quot;+Thread.currentThread().getName()+&quot;===&quot;);                try &#123;                    TimeUnit.SECONDS.sleep(10);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, parse);    &#125;&#125;</code></pre><blockquote><p>Timer对调度的支持是基于绝对时间的，对系统时钟的改变是敏感的</p></blockquote><p>###我们再来看ScheduledExecutorService<br>ScheduledExecutorService没有timer的上面说名的三个缺陷。<br>它是多线程执行任务的，可以指定初始化线程数（因为它本身是使用线程池ThreadPoolExecutor实现的）</p><p>我们来看下面代码，即使在第二次提交Runnable时出现了除0异常，也不会影响到第一次提交的Runnable执行</p><pre><code>package io.renren;import java.text.ParseException;import java.util.concurrent.*;public class ScheduledExecutorServiceTest &#123;    public static void main(String[] args) &#123;        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        System.out.println(&quot;===&quot; + Thread.currentThread().getName() + &quot;===&quot;);                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        int i = 1/0;                        System.out.println(&quot;***&quot; + Thread.currentThread().getName() + &quot;***&quot;);                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);    &#125;&#125;</code></pre><p>再来看是否因为某个Runnable执行时长过长导致其他Runnable延迟执行</p><pre><code>package io.renren;import java.text.ParseException;import java.util.concurrent.*;public class ScheduledExecutorServiceTest &#123;    public static void main(String[] args) &#123;        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        System.out.println(&quot;===&quot; + Thread.currentThread().getName() + &quot;===&quot;);                        try &#123;                            TimeUnit.SECONDS.sleep(10);                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);        scheduledExecutorService.scheduleAtFixedRate(                new Runnable() &#123;                    @Override                    public void run() &#123;                        System.out.println(&quot;***&quot; + Thread.currentThread().getName() + &quot;***&quot;);                    &#125;                &#125;                , 0, 3, TimeUnit.SECONDS);    &#125;&#125;</code></pre><p>执行上面程序，可以看到打印了多次 pool-1-thread-2。说明这个问题在ScheduledExecutorService 中不会出现<br><img src="https://upload-images.jianshu.io/upload_images/13965490-3d00cc5267c8fe58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>ScheduledExecutorService 是基于<code>相对时间</code>的，这点也不同于Timer。因此不会出现修改系统时间，指定运行的任务也跟着影响的尴尬局面了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-内部类应用之剥离配置到静态内部类让配置信息初始化不依赖于类的本身初始化.md</title>
      <link href="/2022/03/20/java-nei-bu-lei-ying-yong-zhi-bo-chi-pei-zhi-dao-jing-tai-nei-bu-lei-rang-pei-zhi-xin-xi-chu-shi-hua-bu-yi-lai-yu-lei-de-ben-shen-chu-shi-hua/"/>
      <url>/2022/03/20/java-nei-bu-lei-ying-yong-zhi-bo-chi-pei-zhi-dao-jing-tai-nei-bu-lei-rang-pei-zhi-xin-xi-chu-shi-hua-bu-yi-lai-yu-lei-de-ben-shen-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<p>现在有这么一种情况</p><p>A 类和B类都实现了接口C，接口C中有两个方法，方法1和方法2。A类实现了方法1和方法2，而B类只实现了方法1，B类的方法2没有实现，只能去调用A类的方法2，但是这样调用会报空指针，因为A类使用了@ConditionalOnExpression注解且配置文件中声明使用的实现是B类，故初始化类A所需必要配置信息没办法得到有效的初始化。</p><p>那么我们可以这样处理：</p><p>1、将方法2声明为static方法并从接口C中移除；<br>2、将初始化A类的配置信息放到A类的静态内部类当中,然后加上@Component注解将此类纳入到spring容器的管理，这样A类初始化所需的配置就可以得到初始化了！</p><p>1、接口C</p><pre><code>public interface AiService &#123;    //人脸    void facePost(String image, String name, String idNo);&#125;</code></pre><p>2、A类</p><pre><code>@Service(&quot;BaiduUtilsServiceImpl&quot;)@ConditionalOnExpression(&quot;&#39;$&#123;business.idCartOcr.choice&#125;&#39;.equalsIgnoreCase(&#39;BAIDU&#39;)&quot;)public class BaiduUtilsServiceImpl implements AiService &#123;  void facePost(String image, String name, String idNo)&#123;       //实现接口1      //访问内部类Conifg中的属性    &#125;   //接口2 实现 改为静态；    public static IdCart ocrPost(String photoFront, String photoBack) &#123;    //访问内部类Conifg中的属性    &#125;    /**     * 内部类     */    @Component    public static class Config &#123;        private static String accessToken;        private static String thirdEndpoint;        private static String thirdClientId;        private static String thirdClientSecret;        //接口URL        private static String thirdEndpointIdCart;        private static String thirdEndpointFace;        @NacosValue(value = &quot;$&#123;business.idCartOcr.baidu.thirdClientId&#125;&quot;, autoRefreshed = true)        public void setThirdClientId(String thirdClientId) &#123;            Config.thirdClientId = thirdClientId;        &#125;        @NacosValue(value = &quot;$&#123;business.idCartOcr.baidu.thirdClientSecret&#125;&quot;, autoRefreshed = true)        public void setThirdClientSecret(String thirdClientSecret) &#123;            Config.thirdClientSecret = thirdClientSecret;        &#125;        @NacosValue(value = &quot;$&#123;business.idCartOcr.baidu.thirdEndpoint&#125;&quot;, autoRefreshed = true)        public void setThirdEndpoint(String thirdEndpoint) &#123;            Config.thirdEndpoint = thirdEndpoint;            Config.thirdEndpointIdCart = String                .format(&quot;%s/rest/2.0/ocr/v1/idcard&quot;, thirdEndpoint);            Config.thirdEndpointFace = String                .format(&quot;%s/rest/2.0/face/v3/person/verify&quot;, thirdEndpoint);        &#125;    &#125;&#125;</code></pre><p>3、B类</p><pre><code>@Service(&quot;GdcaUtilsServiceImpl&quot;)@ConditionalOnExpression(&quot;&#39;$&#123;business.idCartOcr.choice&#125;&#39;.equalsIgnoreCase(&#39;GDCA&#39;)&quot;)public class GdcaUtilsServiceImpl implements AiService &#123;    @Override    public void facePost(String image, String name, String idNo) &#123;    //实现  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-刷题.md</title>
      <link href="/2022/03/20/java-shua-ti/"/>
      <url>/2022/03/20/java-shua-ti/</url>
      
        <content type="html"><![CDATA[<p>1、byte b = (byte)129;<br>  -127</p><p>其实可以把每个数据类型范围画成一个圈，byte是从-128-127，可以这样想，从-128开始，向上加就是一步一步画圈，知道加到127，这个圆圈刚好补满了，所以127再加一就又到了-128，再加一就是129，也就是-127</p><p>2、java中的泛型相关结论<br>1、虚拟机中没有泛型，只有普通类和普通方法<br>2、所有泛型类的类型参数在编译时都会被擦除<br>3、创建泛型对象时请指明类型，让编译器尽早的做参数检查</p><p>3、获得参数的方法区分：如何获取ServletContext设置的参数值？<br>getInitParameter();</p><p>getParameter()是获取POST/GET传递的参数值；<br>getInitParameter获取Tomcat的server.xml中设置Context的初始化参数<br>getAttribute()是获取对象容器中的数据值；<br>getRequestDispatcher是请求转发。</p><p>4、java8中，忽略内部接口的情况，不能用来修饰interface里的方法的有（ ）<br>正确答案: A C<br>A private<br>B public<br>C protected<br>D static</p><p>Java8的接口方法可以有如下定义<br>only public, abstract, default, static and strictfp are permitted<br>`java <code>1.8</code>开始支持接口中定义静态方法</p><p>5、如果一个list初始化为{5，3，1}，执行以下代码后，其结果为（B）？<br>nums.add(6);<br>nums.add(0,4);<br>nums.remove(1);</p><p> A[5, 3, 1, 6]<br>B [4, 3, 1, 6]<br> C[4, 3, 6]<br> D[5, 3, 6]</p><p>1、add(int)和两个重载<br>add(int) 是往后面加一位元素；<br>add(int a,int b) 将b插入到指定索引a处，原来a处的元素和后面的元素向后移动一位。注意不是单纯的替换<br>2、remove(int index) 和 remove(Object a) 两种重载<br>即可移除指定位置，又可按元素内容移除。移除后，后面元素往都要往前补一位</p><p>将题目修改下nums.remove((Object)1); 最终输出就是[4, 5, 3, 6]了，因为这次调用的是remove(Object a)重载乃，直接移除指定元素。</p><p>6、表达式(short)10/10.2*2运算后结果是什么类型？</p><p>double。java中默认的浮点就是double。除不断的除法运算计算结果也是double。除的断的结果是int。</p><pre><code>double v = 10 / 2.1;int i = 10 / 2;</code></pre><p>10、关于protected 修饰的成员变量，以下说法正确的是<br>可以被该类自身、与它在同一个包中的其它类、在其它包中的该类的子类所访问</p><p>11、抽象类可以被抽象类继承</p><p>12、javac 命令参数</p><p>-d destination 目的地<br>-s source 起源地<br>javac -d 指定放置生成的类文件的位置<br>javac -s 指定放置生成的源文件的位置</p><p>13、构造函数不能被继承，构造方法只能被显式或隐式的调用。</p><p>14、</p><pre><code>class Animal&#123;    public void move()&#123;        System.out.println(&quot;动物可以移动&quot;);    &#125;&#125;class Dog extends Animal&#123;    public void move()&#123;        System.out.println(&quot;狗可以跑和走&quot;);    &#125;    public void bark()&#123;        System.out.println(&quot;狗可以吠叫&quot;);    &#125;&#125;public class TestDog&#123;    public static void main(String args[])&#123;        Animal a = new Animal();        Animal b = new Dog();         a.move();        b.move();        b.bark();    &#125;&#125;</code></pre><p>编译错误！</p><blockquote><p>编译看左边，运行看右边。 父类型引用指向子类型对象，无法调用只在子类型里定义的方法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-匿名内部类相关概念.md</title>
      <link href="/2022/03/20/java-ni-ming-nei-bu-lei-xiang-guan-gai-nian/"/>
      <url>/2022/03/20/java-ni-ming-nei-bu-lei-xiang-guan-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>###匿名内部类</p><pre><code>public class MyThread &#123;    private MyRunnable target;    public MyThread(MyRunnable target) &#123;        this.target = target;    &#125;    public void run() &#123;        System.out.println(&quot;去12306买了一张票&quot;);        System.out.println(&quot;坐火车...&quot;);    &#125;    public void start() &#123;        if (target != null) &#123;            target.run();        &#125; else &#123;             this.run();        &#125;    &#125;&#125;</code></pre><pre><code>@FunctionalInterfacepublic interface MyRunnable &#123;    void run();&#125;</code></pre><pre><code>    public static void main(String[] args) &#123;        Integer i =1;        new MyThread(new MyRunnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;不用买票&quot;);                System.out.println(&quot;骑电瓶车...&quot;);                System.out.println(i);            &#125;        &#125;).start();    &#125;</code></pre><p>####匿名内部类访问外部方法中定义的变量<br>jdk1.8后匿名部内部类访问外面方法中定义胡变量不需要加final了。记住，在1.7时还需加final否则编译不通过！<br>查看反编译代码，可见编译后的代码自动了帮我们加了final。</p><pre><code>public class t1 &#123;    public t1() &#123;    &#125;    public static void main(String[] args) &#123;        final Integer i = 1;        (new MyThread(new MyRunnable() &#123;            public void run() &#123;                System.out.println(&quot;不用买票&quot;);                System.out.println(&quot;骑电瓶车...&quot;);                System.out.println(i);            &#125;        &#125;)).start();    &#125;&#125;</code></pre><p><strong>为什么传递给匿名内部类的参数必须声明为final？</strong><br>局部变量在方法中，方法调用完毕即弹栈，会从内存消失。而匿名内部类的实例是在堆中，在未来某个时刻被垃圾回收。生命周期不同步会导致：一个实例持有一个已经不存在的变量引用…<br>由于对象的生命周期无法改变，所以只能是局部变量做出让步：加final变为常量，常驻内存。这样，变量的生命周期反而可能比实例更长久。</p><p><em>我这个里还有个疑问：</em><br>但是，这种情况。for循环中的循环计数器i如果要使用到匿名内部类里面去。编译会报错：<br>需要用int finalI = i; 接收下。</p><pre><code>    public static void main(String[] args) &#123;        for (int i = 0; i &lt;10 ; i++) &#123;            int finalI = i;            new MyThread(new MyRunnable() &#123;                @Override                public void run() &#123;                    System.out.println(&quot;不用买票&quot;);                    System.out.println(&quot;骑电瓶车...&quot;);                    System.out.println(finalI);                &#125;            &#125;).start();        &#125;    &#125;</code></pre><p>why？<br>因为不能把final声明在i上，i毕竟还要自增。故只能再用一个final 变量接收i的值。而jdk1.8中final会自动加上，所以就是 int finalI = i; </p><p>###Lambda<br><strong>只有一个抽象方法的匿名内部类(函数式接口)可以写作lambada</strong><br>上面的可以简写为如下：</p><pre><code>    public static void main(String[] args) &#123;        for (int i = 0; i &lt;10 ; i++) &#123;            final String finalI = String.valueOf(i);            new MyThread(() -&gt; &#123;                System.out.println(&quot;不用买票&quot;);                System.out.println(&quot;骑电瓶车...&quot;);                System.out.println(finalI);            &#125;).start();        &#125;    &#125;</code></pre><p>1、说明Lambda表达式在身份上与匿名类对象等价。<br>2、说明Lambda表达式在作用上与方法等价。</p><blockquote><p>Lambda表达式，其实是一段可传递的代码。Lambda本质是以类的身份，干方法的活。</p></blockquote><p>###函数式接口<br>介绍完Lambda表达式，最后提一下函数式接口。大家肯定会有疑问：难道所有接口都可以接收Lambda表达式吗？显然不是的，接口要想接收Lambda表达式，必须是一个函数式接口。所谓函数式接口，最核心的特征是：</p><blockquote><p>有且只有一个抽象方法。</p></blockquote><p>这句话有两个重点：抽象方法、唯一。你可能觉得：啥玩意，Java的接口不就抽象方法吗？难道还有别的方法？是的，Java8的接口可以添加静态方法和默认方法，越来越像一个类。关于Java8为什么需要静态方法和默认方法，后面介绍Stream流操作时我们再来介绍。</p><p>也就是说，如果你希望一个接口能接收Lambda表达式充当匿名类对象，那么接口必须仅有一个抽象方法，这是函数式接口的定义。通常我们可以在接口上加一个@FunctionalInterface检测，作用于@Override一样。但函数式接口和@FunctionalInterface注解没有必然联系。</p><p>若接口包含多个抽象方法，则不是一个<code>函数式接口</code>，不能改写为<code>Lambda</code>。<br>下面的代码不会被idea置灰提示可以改写为Lambda。</p><pre><code>public interface MyRunnable &#123;    void run();    void rr();&#125;</code></pre><pre><code>    public static void main(String[] args) &#123;        for (int i = 0; i &lt;10 ; i++) &#123;            final String finalI = String.valueOf(i);            new MyThread(new MyRunnable() &#123;                @Override                public void run() &#123;                    System.out.println(&quot;不用买票&quot;);                    System.out.println(&quot;骑电瓶车...&quot;);                    System.out.println(finalI);                &#125;                @Override                public void rr() &#123;                &#125;            &#125;).start();        &#125;    &#125;</code></pre><p>###Lambda与匿名内部类的区别</p><blockquote><p>很多人可能在心里已经自动把Lambda等同于匿名内部类，认为Lambda是匿名内部类的语法糖。然而并不是。</p></blockquote><p>1、只有仅仅包含一个抽象方法实现的匿名内部类才可以改写为Lambda。<br>2、使用匿名内部类编译后产生两个class<code>（t1.class、t1$1.class）</code>；Lambda编译产生一个<code>class(t1.class)</code>。<br>3、在抽象方法体打印this二者不同；匿名内部类的this指向匿名内部类对象<code>(t1$1@16f6e28)</code>；Lambda方法体this指向调用者<code>(t1@14c265e)</code>。</p><h3 id="this与闭包"><a href="#this与闭包" class="headerlink" title="this与闭包"></a>this与闭包</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-反射.md</title>
      <link href="/2022/03/20/java-fan-she/"/>
      <url>/2022/03/20/java-fan-she/</url>
      
        <content type="html"><![CDATA[<p>1、调用所有包含get的方法名，参数数目为0的</p><pre><code>      Class&lt;?&gt; herosClass = Certificate.class;        Method[] methods = herosClass.getMethods();        for (Method method : methods) &#123;            if(method.getName().contains(&quot;get&quot;) &amp;&amp;   method.getParameterCount()  == 0)&#123;                System.out.println(method.getName());                Object invoke = method.invoke(x509Certificate);                System.out.println(invoke);            &#125;        &#125;</code></pre><p>2、使用字符串方法名调用方法</p><pre><code>@Test    public void test7() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException&#123;        Class&lt;?&gt; Person = Class.forName(&quot;com.Person&quot;);        Object newInstance = Person.newInstance();        for (int i = 1; i &lt; 4; i++) &#123;            Method method = Person.getMethod(&quot;getPerson&quot;+i, String.class);            String str2= (String) method.invoke(newInstance, new Object[]&#123;i+&quot;&quot;&#125;);            System.out.println(str2);        &#125;    &#125;</code></pre><p>3、调用set</p><pre><code>    /***     * 初始化时加载所有set方法     */    static &#123;        Class cs = null;        try &#123;            cs = Class.forName(JgOriginalOrder.class.getName());        &#125; catch (ClassNotFoundException e) &#123;            log.error(&quot;初始化JgOriginalOrder set 失败&quot;,e);        &#125;        Field[] fileds = cs.getDeclaredFields();        try &#123;            for (Field field : fileds) &#123;                PropertyDescriptor pd = new PropertyDescriptor(field.getName(), cs);                //获取所有set方法                Method method = pd.getWriteMethod();                methodMap.put(field.getName(),method);            &#125;        &#125; catch (Exception e) &#123;            log.error(&quot;初始化JgOriginalOrder set 失败&quot;,e);        &#125;    &#125;    private static void setObjOnOrder(JgOriginalOrder order, String fieldName ,Object setObj) &#123;        final Method method = methodMap.get(fieldName);        try &#123;            method.invoke(order,setObj);        &#125; catch (IllegalAccessException e) &#123;           log.error(&quot;set 方法调用失败&quot;,e);        &#125; catch (InvocationTargetException e) &#123;            log.error(&quot;set 方法调用失败&quot;,e);        &#125;    &#125;</code></pre><p>4、pojo 各种属性都为null判断</p><pre><code>    private static Method[] methods = MgbsupplierBatchDto.class.getMethods();    private static boolean isAllNull(MgbsupplierBatchDto t) &#123;        for (Method method : methods) &#123;            if (method.getName().contains(&quot;get&quot;) &amp;&amp; method.getParameterCount() == 0) &#123;                if(!StringUtils.contains(method.getName(),&quot;getCellStyleMap&quot;)&amp;&amp;!StringUtils.contains(method.getName(),&quot;getClass&quot;) )&#123;                    Object invoke = null;                    try &#123;                        invoke = method.invoke(t);                    &#125; catch (IllegalAccessException e) &#123;                        log.error(e.toString(),e);                    &#125; catch (InvocationTargetException e) &#123;                        log.error(e.toString(),e);                    &#125;                    if (ToolUtil.isNotEmpty(invoke)) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-发起post请求,自定义header和body.md</title>
      <link href="/2022/03/20/java-fa-qi-post-qing-qiu-zi-ding-yi-header-he-body/"/>
      <url>/2022/03/20/java-fa-qi-post-qing-qiu-zi-ding-yi-header-he-body/</url>
      
        <content type="html"><![CDATA[<pre><code>package io.renren.modules.websocket.test;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.*;/** * @date 2019/10/1017:12 */public class HttpUtils &#123;    //post请求    /**     * @param url     * @param headerMap  header 参数     * @param contentMap body 参数     * @return     */    public static String postMap(String url, Map&lt;String, String&gt; headerMap, Map&lt;String, String&gt; contentMap) &#123;        String result = null;        CloseableHttpClient httpClient = HttpClients.createDefault();        HttpPost post = new HttpPost(url);        List&lt;NameValuePair&gt; content = new ArrayList&lt;NameValuePair&gt;();        Iterator iterator = contentMap.entrySet().iterator();           //将content生成entity        while (iterator.hasNext()) &#123;            Map.Entry&lt;String, String&gt; elem = (Map.Entry&lt;String, String&gt;) iterator.next();            content.add(new BasicNameValuePair(elem.getKey(), elem.getValue()));        &#125;        CloseableHttpResponse response = null;        try &#123;            Iterator headerIterator = headerMap.entrySet().iterator();          //循环增加header            while (headerIterator.hasNext()) &#123;                Map.Entry&lt;String, String&gt; elem = (Map.Entry&lt;String, String&gt;) headerIterator.next();                post.addHeader(elem.getKey(), elem.getValue());            &#125;            if (content.size() &gt; 0) &#123;                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(content, &quot;UTF-8&quot;);                post.setEntity(entity);            &#125;            response = httpClient.execute(post);            //发送请求并接收返回数据            if (response != null &amp;&amp; response.getStatusLine().getStatusCode() == 200) &#123;                HttpEntity entity = response.getEntity();       //获取response的body部分                result = EntityUtils.toString(entity);          //读取reponse的body部分并转化成字符串            &#125;            return result;        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125; catch (ClientProtocolException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                httpClient.close();                if (response != null) &#123;                    response.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;    // url格式转map    public static Map&lt;String, String&gt; paramToMap(String paramStr) &#123;        String[] params = paramStr.split(&quot;&amp;&quot;);        Map&lt;String, String&gt; resMap = new HashMap&lt;String, String&gt;();        for (int i = 0; i &lt; params.length; i++) &#123;            String[] param = params[i].split(&quot;=&quot;);            if (param.length &gt;= 2) &#123;                String key = param[0];                String value = param[1];                for (int j = 2; j &lt; param.length; j++) &#123;                    value += &quot;=&quot; + param[j];                &#125;                resMap.put(key, value);            &#125;        &#125;        return resMap;    &#125;    //Header字符串转map    public static Map&lt;String, String&gt; splid(String zz) &#123;        String[] stepOne = zz.split(&quot;\n&quot;);        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        for (int i = 0; i &lt; stepOne.length; i++) &#123;            String[] stepTwo = stepOne[i].split(&quot;: &quot;);            if (map.get(stepTwo[0]) == null)                map.put(stepTwo[0], stepTwo[1]);            else                map.put(stepTwo[0], stepTwo[1] + &quot;,&quot; + map.get(stepTwo[0]));        &#125;        return map;    &#125;    public static void main(String[] args) &#123;        String header =                &quot;Host: r.cnews.qq.com\n&quot; +                        &quot;Accept-Encoding: gzip,deflate\n&quot; +                        &quot;Referer: http://cnews.qq.com/cnews/android/\n&quot; +                        &quot;User-Agent: %E5%A4%A9%E5%A4%A9%E5%BF%AB%E6%8A%A56080(android)\n&quot; +                        &quot;Cookie: lskey=; luin=; skey=; uin=; logintype=0;\n&quot; +                        &quot;snqn: isrlo83QeV0HUKSXBDEC2KU0i6dA6NJ+cJ6DfolV5BUaHTHKTIU0WQXRMHW9bo+0oWH2Uep5SZ6wOU2ufjuBOl9TYQKJaDModIprMcdjEIFHr32o8/mB9Da/apEitNzMj/o+zfCmWj7zQZTmMNvZaQ==\n&quot; +                        &quot;svqn: 1_4\n&quot; +                        &quot;qn-sig: 8da32c703ef980b76fc3343118e1a9f8\n&quot; +                        &quot;qn-rid: 16e0d706-a1e4-465b-9a39-ce0caea0e03f\n&quot; +                        &quot;Content-Type: application/x-www-form-urlencoded\n&quot; +                        &quot;Connection: Keep-Alive&quot;;        //&quot;Content-Length: 2267\n&quot;;        Map splid = splid(header);        System.out.println(splid);        Map&lt;String, String&gt; bodyMap = paramToMap(&quot;adcode=440111&amp;last_id=20191008A046A900&amp;lon=113.268162&amp;cityList=%E5%B9%BF%E5%B7%9E&amp;loc_streetNo=&amp;forward=1&amp;refreshType=normal&amp;provinceId=19&amp;last_time=1570521327&amp;userCity=%E5%B9%BF%E5%B7%9E&amp;bottom_id=20191007A0DZI400&amp;loc_name=%E7%99%BD%E4%BA%91%E7%BB%BF%E5%9C%B0%E4%B8%AD%E5%BF%83&amp;top_time=1570495721&amp;manualRefresh=1&amp;top_id=20191008A046A900&amp;loc_addr=%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%B9%BF%E5%B7%9E%E5%B8%82%E7%99%BD%E4%BA%91%E5%8C%BA%E4%BA%91%E5%9F%8E%E8%A5%BF%E8%B7%AF%E4%B8%8E%E9%BD%90%E5%BF%83%E8%B7%AF%E4%BA%A4%E5%8F%89%E5%8F%A3%E5%8D%97150%E7%B1%B3&amp;page=8&amp;cityId=198&amp;lastRefreshTime=1570521327&amp;loc_street=%E4%BA%91%E5%9F%8E%E8%A5%BF%E8%B7%AF&amp;preload=1&amp;loc_catalog=%E6%88%BF%E4%BA%A7%E5%B0%8F%E5%8C%BA%3A%E5%95%86%E5%8A%A1%E6%A5%BC%E5%AE%87&amp;refresh_from=refresh_footer&amp;direction=1&amp;sessionid=undefined&amp;chlid=kb_news_hotnews&amp;bottom_time=1570435632&amp;is_viola=1&amp;loc_accuracy=40.0&amp;lat=23.180721&amp;REQBuildTime=1570521551393&amp;adcode=440111&amp;lon=113.268162&amp;ssid=YR-TECH&amp;omgid=f4287f3ea730a249015bd9d06a73f6dc23c00010212406&amp;REQExecTime=1570521551412&amp;qqnetwork=wifi&amp;commonsid=7b7615ee4c8e412b9ba95ca7ebbca7eb&amp;kingCardType=0&amp;picSizeMode=0&amp;adCookie=&amp;commonGray=1_3%7C2_1%7C12_0%7C49_1%7C14_1%7C17_1%7C30_1%7C99_1&amp;currentTab=kuaibao&amp;proxy_addr=192.168.1.99%3A8888&amp;is_wap=0&amp;lastCheckCardType=0&amp;omgbizid=a323e236f72cee4c10e96ec642cb73943d3a0080214908&amp;imsi=460005292210411&amp;commonIsFirstLaunch=0&amp;bssid=22%3Abc%3A5a%3A74%3Aa0%3A88&amp;taid=0101869FFED6E4A84F898262CADBA96EC2521FB86438AEE01A238B538F2A8F90BA0F96B93C4F0770FD1F0AED&amp;activefrom=icon&amp;unixtimesign=1570521551414&amp;qimei=92a420ebc78a0356&amp;Cookie=%26lskey%3D%26luin%3D%26skey%3D%26uin%3D%26logintype%3D0&amp;qaid=0171E6660E55174412AC482013E10C8E&amp;imsi_history=460005292210411&amp;qn-sig=8da32c703ef980b76fc3343118e1a9f8&amp;qn-rid=16e0d706-a1e4-465b-9a39-ce0caea0e03f&amp;lat=23.180721&amp;hw_fp=Coolpad%2FCool1_CN%2Fcool_c1%3A6.0.1%2FZAXCNFN5902606201S%2F0001820%3Auser%2Frelease-keys&amp;gpu=Qualcomm%20Adreno%20%28TM%29%20510&amp;mid=ca57d1f0e21794164956b43da41d7fea68de70fa&amp;devid=861795038752864&amp;mac=54%3ADC%3A1D%3A2A%3A0A%3A2A&amp;store=9002096&amp;screen_height=1920&amp;apptype=android&amp;origin_imei=861795038752864&amp;codeclevel=5.1&amp;rover=1&amp;hw=Coolpad_C106&amp;appversion=6.0.80&amp;appver=23_areading_6.0.80&amp;uid=92a420ebc78a0356&amp;screen_width=1080&amp;sceneid=&amp;android_id=92a420ebc78a0356&quot;);        String s = postMap(&quot;https://r.cnews.qq.com/getVerticalChannel?devid=861795038752864&quot;, splid, bodyMap);        System.out.println(s);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之Random-随机数.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-random-sui-ji-shu/"/>
      <url>/2022/03/20/java-ji-chu-zhi-random-sui-ji-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>吾生也有涯，而知也无涯</p></blockquote><p>######使用Random 生成指定大小范围内的随机数</p><blockquote><p>公式:  random.nextInt(n -m + 1) +m;</p></blockquote><p>如下生成[22,433]范围内的随机数，注意两边都是闭区间。22和443都会取得到</p><pre><code>package io.renren;import java.util.Random;public class RandomTest &#123;    public static void main(String[] args) &#123;        Random random = new Random(1);        // [22,433]        for (int i = 0; i &lt;1000 ; i++) &#123;            System.out.println(random.nextInt(433-22+1) + 22);        &#125;    &#125;&#125;</code></pre><p>######Random 是线程安全的么？可以被线程共享一个实例么？<br>在工程中不同地方生成随机数总是new了很多个Random 实例，想着这个Random 能不能复用。于是打开jdk文档看看，里面有提到</p><blockquote><p>java.util.Random的是线程安全的。 但是，跨线程的同时使用java.util.Random实例可能会遇到争用，从而导致性能下降。 在多线程设计中考虑使用<a href="../../java/util/concurrent/ThreadLocalRandom.html" title="java.util.concurrent中的类"><code>ThreadLocalRandom</code></a> 。</p></blockquote><p>文档中说明了Random是线程安全的，但是不建议多线程访问同一个实例。因为会带来效率问题。我们来看看Random的源码探究下</p><p>nextInt方法里调用了next方法<br><img src="https://upload-images.jianshu.io/upload_images/13965490-d2b9900682d44567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>那么再看看next方法，可以看到next方法里为了保证seed对象是最新的就调用了compareAndSet方法</p><p><img src="https://upload-images.jianshu.io/upload_images/13965490-661203cd1e2d7be2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们知道compareAndSet是著名的<code>CAS</code> 乐观锁算法，而这种算法在激烈的并发修改下会导致自旋次数过多。从而长时间占用cpu执行时间片。</p><p>那么这种建议背后的原理就一目了然了。而且在《阿里巴巴Java开发手册》中也有提到：</p><blockquote><p>【推荐】 避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。<br>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。<br>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例</p></blockquote><p>JDK7之前可以使用ThreadLocal为每一个线程绑定一个Random 实例。JDK7之后就有一个现成的ThreadLocalRandom类可以使用了</p><p>######ThreadLocalRandom 多线程共享随机数生成<br>关于ThreadLocalRandom 可以看看这篇文章<br><a href="https://www.jianshu.com/p/bf276d506668">https://www.jianshu.com/p/bf276d506668</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之finally是否一定会执行-.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-finally-shi-fou-yi-ding-hui-zhi-xing/"/>
      <url>/2022/03/20/java-ji-chu-zhi-finally-shi-fou-yi-ding-hui-zhi-xing/</url>
      
        <content type="html"><![CDATA[<p>事实上finally区域代码在很多情况下都不会执行<br>######没有进入try区域<br> <br>1、程序在进入try区域之前抛出异常，那么整个try-catch -finally都不会执行</p><pre><code>class TestThreadLocal &#123;    public static Integer test() &#123;        int a = 1 / 0;        try &#123;            int b = 1 / 0;// 不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);// 不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);// 不会执行            return 1;// 不会执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p>2、程序在进入try区域之前return，那么整个try-catch -finally都不会执行</p><pre><code>class TestThreadLocal &#123;    public static Integer test() &#123;        if (true) &#123;            return 0;        &#125;        try &#123;            int b = 1 / 0;// 不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);// 不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);// 不会执行            return 1;// 不会执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p>######进入了try区域<br> 如果当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。</p><p>1、守护线程随着用户线程退出而退出，finally 不会执行</p><pre><code>class DaemonDemo &#123;    public static void main(String[] args) &#123;        Thread daemonThread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (true) &#123;                    try &#123;                        System.out.println(&quot;i am alive&quot;);                        Thread.sleep(500);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125; finally &#123;                        System.out.println(&quot;finally block&quot;);                    &#125;                &#125;            &#125;        &#125;);        daemonThread.setDaemon(true);        daemonThread.start();        try &#123;            //确保main线程结束前能给daemonThread能够分到时间片            Thread.sleep(800);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-2ac9520341c45633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第二次没有执行finally</p><p>######退出程序<br>1、执行了System.exit(0); 退出java虚拟机</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        System.exit(0);        try &#123;            int b = 1 / 0;// 不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);// 不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);// 不会执行            return 1;// 不会执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之switch语句细节.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-switch-yu-ju-xi-jie/"/>
      <url>/2022/03/20/java-ji-chu-zhi-switch-yu-ju-xi-jie/</url>
      
        <content type="html"><![CDATA[<p>###switch所允许的数据类型<br><img src="https://upload-images.jianshu.io/upload_images/13965490-73a8c2501dba91d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>基本数据类型：byte, short, char, int<br>包装数据类型：Byte, Short, Character, Integer<br>枚举类型：Enum<br>字符串类型：String（jdk 7 开始支持）</p><p>不支持boolean和double、float类型<br>###switch语句的执行特征<br>1、switch 分支是由上到下执行的<br>2、程序会继续执行下一条 case 语句，直到出现 break 语句，当遇到 break 语句时，switch 语句终止<br>3、switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分 支（可以在任何位置，但一般在最后一个）。<br>4、default 在没有 case 语句的值和变量值相等的时候执行。<br>5、default放到最后的话就不需要 break 语句，如果放到前面情况就不同了。</p><p>######实例<br>1、没有break 语句，程序将由上至下执行 case。直到遇到break </p><pre><code>    public static void main(String[] args) &#123;        switch (0) &#123;            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-7ba0d9ac4735e357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>2、再来看有break会怎么样</p><pre><code>public static void main(String[] args) &#123;        switch (0) &#123;            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);                break;            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-cba3e313503979b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>3、default在没有匹配时执行</p><pre><code>    public static void main(String[] args) &#123;        switch (8) &#123;            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);            default:                System.out.println(&quot;default&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-554953b5d84faa0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>4、如果default语句块写在上面，因为没有遇到break，全都执行一遍~</p><pre><code>  public static void main(String[] args) &#123;        switch (8) &#123;            default:                System.out.println(&quot;default&quot;);            case 0:                System.out.println(&quot;zero&quot;);            case 1:                System.out.println(&quot;one&quot;);            case 2:                System.out.println(&quot;two&quot;);        &#125;    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-884fb296a3207e4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之java异常体系.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-java-yi-chang-ti-xi/"/>
      <url>/2022/03/20/java-ji-chu-zhi-java-yi-chang-ti-xi/</url>
      
        <content type="html"><![CDATA[<p>#Java异常类的架构<br><img src="https://upload-images.jianshu.io/upload_images/13965490-d66aae69de2722b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="RuntimeException-UnCheckException"><a href="#RuntimeException-UnCheckException" class="headerlink" title="RuntimeException/UnCheckException"></a>RuntimeException/UnCheckException</h3><p>定义: RuntimeException及其子类都被称为运行时异常。<br>特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。<br>spring框架的@Transactional事务注解默认回滚RuntimeException。</p><p>例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常、常见的空指针异常NullPointerException等，都属于运行时异常。</p><p>虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。</p><blockquote><p>如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p></blockquote><h3 id="CheckException"><a href="#CheckException" class="headerlink" title="CheckException"></a>CheckException</h3><p>定义: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。<br>特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如进行文件操作时遇到的IOException、线程sleep方法/obj的wait方法抛出的InterruptedException等都属于CheckException。</p><p>@Transactional事务注解默认不会回滚checkException，需要指定Exception父类，用法如下：<br>@Transactional(rollbackFor = Exception.class); 而且捕获后需要抛出给上层调用者，这样事务才会正常回滚。</p><blockquote><p>被检查异常通常都是可以恢复的。</p></blockquote><h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><p>定义: Error类及其子类。<br>特点: 和运行时异常一样，编译器也不会对错误进行检查。<br>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。</p><p>@Transactional事务注解默认回滚ERROR</p><p>例如我们常见的虚拟机内存栈溢出错误StackOverflowError。</p><blockquote><p>熟悉java异常机制对我们使用spring声明式事务有很大帮助！这篇文章探讨了异常和spring事务的关系 <a href="https://www.jianshu.com/p/702ac5630b99">https://www.jianshu.com/p/702ac5630b99</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之合理使用if-else.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-he-li-shi-yong-if-else/"/>
      <url>/2022/03/20/java-ji-chu-zhi-he-li-shi-yong-if-else/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e5fa79de51d45271849e7bd">https://juejin.im/post/5e5fa79de51d45271849e7bd</a></p><pre><code>@Around(&quot;dataSourcePointCut()&quot;)    public Object around(ProceedingJoinPoint point) throws Throwable &#123;        //事实上默认数据源是 MASTER        //得到类上的注解        DataSource dataSourceClass = point.getTarget().getClass().getAnnotation(DataSource.class);        //如果类上的注解的参数是SLAVE        if(dataSourceClass != null &amp;&amp; DataSourceNames.SLAVE.getName().equals(dataSourceClass.name()))&#123;            //设置当前线程数据源为SLAVE            DynamicDataSource.setDataSource(DataSourceNames.SLAVE.getName());            logger.info(&quot;设置数据源为&quot; + DataSourceNames.SLAVE);        &#125;        //得到方法上的注解,方法上的注解优先级大于类上的        MethodSignature signature = (MethodSignature) point.getSignature();        Method method = signature.getMethod();        DataSource dataSourceMethod = method.getAnnotation(DataSource.class);        //如果类上的注解的参数是SLAVE        if(dataSourceMethod != null &amp;&amp; DataSourceNames.SLAVE.getName().equals(dataSourceMethod.name()))&#123;            //设置当前线程数据源为SLAVE            DynamicDataSource.setDataSource(DataSourceNames.SLAVE.getName());            logger.info(&quot;设置数据源为&quot; + DataSourceNames.SLAVE);        &#125;else&#123;            //让方法上的注解优先级大于类上的，所以需要写一个else            //设置当前线程数据源为MASTER            DynamicDataSource.setDataSource(DataSourceNames.MASTER.getName());            logger.info(&quot;设置数据源为&quot; + DataSourceNames.MASTER);        &#125;        try &#123;            return point.proceed();        &#125; finally &#123;            DynamicDataSource.clearDataSource();            logger.info(&quot;调用目标方法后，将数据源还原为默认&quot;);        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之try-catch-finally.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-try-catch-finally/"/>
      <url>/2022/03/20/java-ji-chu-zhi-try-catch-finally/</url>
      
        <content type="html"><![CDATA[<p>####关于try-catch -finally异常处理语句块最基本的知识</p><p>1、catch 里的代码只有在try里抛出未处理异常时才会执行</p><pre><code>class TestFinally&#123;    public static void test() &#123;        try &#123;            System.out.println(&quot;会执行吗？&quot;);//执行        &#125; catch (Exception e) &#123;            System.out.println(e);//不会执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行        &#125;    &#125;    public static void main(String[] args) &#123;        test();    &#125;&#125;</code></pre><p>2、try里抛出异常代码行下面的代码不会被执行</p><pre><code>class TestFinally&#123;    public static void test() &#123;        try &#123;            int a = 1 / 0;//抛出异常的代码            System.out.println(&quot;会执行吗？&quot;);//不会执行        &#125; catch (Exception e) &#123;            System.out.println(e);        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行        &#125;    &#125;    public static void main(String[] args) &#123;        test();    &#125;&#125;</code></pre><p>3、try中抛出异常，catch成功捕获执行后。在try-catch-finally后的代码也会得到执行</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int i = 1 / 0;        &#125; catch (Exception e) &#123;            System.out.println(e);//执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行        &#125;        System.out.println(&quot;我会执行吗?&quot;);//执行        return 2;//执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//2    &#125;&#125;</code></pre><p>4、catch 中使用throw 向调用者抛出异常，则在try-catch-finally后的代码不会执行</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int i = 1 / 0;        &#125; catch (Exception e) &#123;            throw e;//方法跳出        &#125;        System.out.println(&quot;我会执行吗?&quot;);//不会执行        return 2;//不会执行    &#125;    public static void main(String[] args) &#123;        try &#123;            System.out.println(test());        &#125;catch (Exception e)&#123;            System.out.println(e);//执行        &#125;    &#125;&#125;</code></pre><p>###try-catch-finally 和return语句不得不说的关系</p><p>######1、finally中有return语句<br><code>finally中的return语句优先级是最高的！函数最终的返回值以finally中的return语句为准</code><br>①、来看try和finally中return语句的优先级</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        try &#123;            return 0;//不执行        &#125; catch (Exception e) &#123;            System.out.println(e);            return 2;//因为没有抛出异常，不执行        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);            return 1;//执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-79aae1697576444e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>②、再来看catch和finally中的return语句优先级</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        try &#123;            int a = 1/0;        &#125; catch (Exception e) &#123;            System.out.println(e);            return 2;// 被finally中的return覆盖！        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);            return 1;//执行        &#125;    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-ac50efd72841e6fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>③、在finally里的return导致finally中后面的语句不被执行</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int a = 1/0;        &#125; catch (Exception e) &#123;            System.out.println(e);//执行        &#125; finally &#123;            if (true) &#123;                return 1;            &#125;            System.out.println(&quot;我会执行吗！&quot;); //不会执行        &#125;        return 0;//不会执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//1    &#125;&#125;</code></pre><p>######2、try/catch 中有return语句，finally块中没有return语句</p><p>①、<code>这里情况很特殊</code>程序执行的顺序被打乱了。代码运行到 return 1;会将return 的结果暂时保留，并没有立刻返回。先去执行finally 区域中的代码，然后返回return 1;</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int a = 1 / 0;        &#125; catch (Exception e) &#123;            System.out.println(e);            return 1;//执行了        &#125; finally &#123;            System.out.println(&quot;执行finally！&quot;);//执行了        &#125;        System.out.println(&quot;会执行吗?&quot;);//没有执行        return 0;//没有执行    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);//输出1    &#125;&#125;</code></pre><p>执行结果<br><img src="https://upload-images.jianshu.io/upload_images/13965490-f75f91cc278ed363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>②、所谓的<code>返回值暂时保留</code>可以再看一个例子：</p><pre><code>class TestFinally&#123;    public static Integer test() &#123;        int i = 0;        try &#123;            int a = 1 / 0;        &#125; catch (Exception e) &#123;            System.out.println(e);            return i;// 保留返回值为 0        &#125; finally &#123;            i++;            System.out.println(&quot;执行finally！&quot;);//执行了        &#125;        System.out.println(&quot;会执行吗?&quot;);//没有执行        return -1;//没有执行    &#125;    public static void main(String[] args) &#123;        Integer test = test();        System.out.println(test);//输出0    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-cadbfdc7705e2587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>最终的返回值是 0 。而不是1，有人肯定会说明明执行了i++，之后才返回为什么？ 因为在finally 执行之前的return语句的返回值会被<code>返回值暂时保留</code></p><p>③、catch 中的return 优先级大于try-catch-finally后面的</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            int a = 1/0;            if (true) &#123;                return 1;//不会执行            &#125;        &#125; catch (Exception e) &#123;            System.out.println(e);//执行            return 2;//执行        &#125; finally &#123;            System.out.println(&quot;finally执行&quot;); //执行        &#125;        System.out.println(&quot;我会执行吗?&quot;);//不会执行        return 3;//不会执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//2    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-9dee15767f4c8bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>④、try中的return 优先级高于try-catch-finally后面的</p><pre><code>class TestFinally &#123;    public static Integer test() &#123;        try &#123;            if (true) &#123;                return 1;//执行            &#125;        &#125; finally &#123;            System.out.println(&quot;finally执行&quot;);//执行        &#125;        return  3;//不会执行    &#125;    public static void main(String[] args) &#123;        System.out.println(test());//1    &#125;&#125;</code></pre><p>######try/catch/finally和return 关系总结</p><ul><li>finally中的return 优先级最高。如果finally中有return 1，那么方法的返回值就是1了</li><li>try和catch中return 的优先级无法比较</li><li>try中的return 优先级高于try-catch-finally后面的</li><li>catch 中的return 优先级大于try-catch-finally后面的</li><li>注意<code>返回值保留</code>问题</li></ul><h6 id="try-catch-finally和-throw抛出异常的关系"><a href="#try-catch-finally和-throw抛出异常的关系" class="headerlink" title="try/catch/finally和 throw抛出异常的关系"></a>try/catch/finally和 throw抛出异常的关系</h6><pre><code>class TestFinally &#123;    public static void test() &#123;       try &#123;           int i = 1 / 0; //执行       &#125;catch (Exception e)&#123;           System.out.println(e);//执行           throw e;//执行       &#125;finally &#123;           System.out.println(&quot;finally被执行&quot;); //执行       &#125;        System.out.println(&quot;我会执行吗？&quot;);//不执行    &#125;    public static void main(String[] args) &#123;        test();    &#125;&#125;</code></pre><p>###大总结<br>1、finally 不受 try、catch、throw 、return的影响，一定会执行<br>2、finally前有return，会先执行return语句，并将结果保存下来，再执行finally块，最后return<br>3、finally前有return，finally中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的return结果，并返回</p><p>###使用try/catch/finally/throw 处理对线程执行流程的影响<br>1、如果某<code>运行时异常</code>没有被捕获，那么直接中断线程执行</p><pre><code>   public static void main(String[] args) &#123;        String str = (String) new Object();        System.out.println(&quot;不会被执行&quot;);    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-e131bec77d0bad69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>2、某异常被try-catch-finally捕获，线程会继续执行finally之后的代码</p><pre><code>    public static void main(String[] args) &#123;        try &#123;            String str = (String) new Object();        &#125;catch ( Exception e )&#123;          e.printStackTrace();        &#125;finally &#123;        &#125;        System.out.println(&quot;继续执行！&quot;);    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-0ef546950bea3028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>3、如果使用throw抛出异常，则finally之后的代码不会执行</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之接口.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-jie-kou/"/>
      <url>/2022/03/20/java-ji-chu-zhi-jie-kou/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础之错误和异常.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-cuo-wu-he-yi-chang/"/>
      <url>/2022/03/20/java-ji-chu-zhi-cuo-wu-he-yi-chang/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13965490-768cbbd2ccc997ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><code>异常和错误有一个共同的基类java.lang.Throwable</code></p><p>###错误<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。<br>比如 栈内存溢出错误(java.lang.StackOverflowError)</p><p>###异常<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。<br>异常(java.lang.Exception)可以分为<br>######非受检异常<br>也叫<code>运行时异常</code> ，它继承了java.lang.RuntimeException类;虽然不是一定要使用try-catch捕获，但是也可以使用之捕获</p><blockquote><p>常见的受检异常有 空指针异常（java.lang.NullPointerException）、除0异常（java.lang.ArithmeticException）、数组越界异常（java.lang.ArrayIndexOutOfBoundsException）、类型强转异常（java.lang.ClassCastException）</p></blockquote><p>######常见运行时异常测试<br>java.lang.NullPointerException</p><pre><code>Object a = null;a.equals(&quot;1&quot;);</code></pre><p> java.lang.ArithmeticException: / by zero</p><pre><code>int i = 1/0;</code></pre><p>java.lang.ArrayIndexOutOfBoundsException</p><pre><code>int[] arr = new int[1];arr[2] = 1;</code></pre><p>java.lang.ClassCastException</p><pre><code> String str = (String) new Object();</code></pre><h6 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h6><p>受检异常必须被try-catch捕获或throws抛出处理，否则idea将报错</p><blockquote><p>常见的受检异常有 反射异常（java.lang.ReflectiveOperationException）、类文件未找到异常（java.lang.ClassNotFoundException）、数据库sql异常（java.sql.SQLException）、文件IO异常（java.io.IOException）</p></blockquote><h6 id="受检异常测试"><a href="#受检异常测试" class="headerlink" title="受检异常测试"></a>受检异常测试</h6><p>我们在写jdbc代码时会遇到这种情况，idea提示异常，需要显式的对异常进行try/catch或者在方法的尾巴上  throws SQLException<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c8bcbd1e3e1af11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>使用try/catch<br><img src="https://upload-images.jianshu.io/upload_images/13965490-be05fdef79dcf70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在方法尾巴上抛出<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c0522d7bcf4f78f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识1-传值和传引用.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-1-chuan-zhi-he-chuan-yin-yong/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-1-chuan-zhi-he-chuan-yin-yong/</url>
      
        <content type="html"><![CDATA[<p>######1、基本类型传复印件</p><pre><code>public static void cr(int a)&#123;    a++;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//2&#125;public static void main(String[] args) &#123;    int a = 1;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//1&#125;</code></pre><p>######2、基本类型的包装类型也传的是复印件</p><pre><code>public static void cr(Integer a)&#123;    a++;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//2&#125;public static void main(String[] args) &#123;    Integer a = 1;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//1&#125;</code></pre><p>######3、String 使用+拼接，也是不同的。String是不可变类</p><pre><code>public static void cr(String a)&#123;    a=a+&quot; kai&quot;;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//yin kai&#125;public static void main(String[] args) &#123;    String a = &quot;yin&quot;;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//yin&#125;</code></pre><p>######4、ArrayList这种复合对象传入的是对象的引用；修改list内部元素对所有引用都生效<br><img src="https://upload-images.jianshu.io/upload_images/13965490-2fb39d3f3630e3f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>public static void cr(List a)&#123;    a.add(4);    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//[1, 2, 3, 4]&#125;public static void main(String[] args) &#123;    ArrayList&lt;Integer&gt; a = new ArrayList();    Collections.addAll(a, 1,2,3);    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//[1, 2, 3, 4]&#125;</code></pre><p>######5、ArrayList 在cr方法中用一个新new的对象赋值，则指向不同的堆内存块了；此时两个list修改不会影响对方<br><img src="https://upload-images.jianshu.io/upload_images/13965490-33f9138e35605045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>public static void cr(List a)&#123;    a = new ArrayList();    Collections.addAll(a, 4,5,6);    System.out.println(&quot;进入方法打印&quot;);    System.out.println(a);//[4, 5, 6]&#125;public static void main(String[] args) &#123;    ArrayList&lt;Integer&gt; a = new ArrayList();    Collections.addAll(a, 1,2,3);    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(a);//[1, 2, 3]&#125;</code></pre><p>######6、Integer[]、int[]数组传的也是引用</p><pre><code>public static void cr(Integer[] a)&#123;    a[3] = 4;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;public static void main(String[] args) &#123;    Integer[] a = &#123;1,2,3,null&#125;;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;//public static void cr(int[] a)&#123;    a[3] = 4;    System.out.println(&quot;进入方法打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;public static void main(String[] args) &#123;    int[] a = new int[4];    a[0] = 1;    a[1] = 2;    a[2] = 3;    cr(a);    System.out.println(&quot;调用方法后打印&quot;);    System.out.println(Arrays.toString(a));//[1, 2, 3, 4]&#125;</code></pre><p>######7、自己写的类构造的对象中的传值和传引用</p><pre><code>public class Test &#123;   private String name;    public void setName(String name) &#123;        this.name = name;    &#125;    public void changeName(String name) &#123;        name = &quot;kaikai&quot;;    &#125;    public void changeAge(Integer age) &#123;        age = 22;    &#125;    private void changeTest(Test test)&#123;        test.setName(&quot;kai&quot;);    &#125;    public Test(String name) &#123;        this.name = name;    &#125;    public Test() &#123;    &#125;    public static void main(String[] args) &#123;        Test test1 = new Test();        int age = 20;        test1.changeAge(age);        System.out.println(&quot;age===&gt;&quot;+age); //20        Test test2 = new Test(&quot;yin&quot;);        test2.changeTest(test2);        System.out.println(&quot;test2.name==&gt;&quot;+test2.name);// kai        String str = &quot;xuan&quot;;        test2.changeName(str);        System.out.println(&quot;str===&gt;&quot;+str);//xuan    &#125;&#125;</code></pre><p>这个例子也可以这样理解：使用方法作用域来理解<br>1、我们学过JVM中的栈。每个方法都有一个栈帧，栈帧里面有对应的<code>局部变量表</code>。所以这里打印的age是main方法中的age,而不是changeAge方法中的age</p><pre><code>Test test1 = new Test();int age = 20;test1.changeAge(age);System.out.println(&quot;age===&gt;&quot;+age); //20</code></pre><p>2、这里打印的name是test2对象实例中的name属性</p><pre><code>Test test2 = new Test(&quot;yin&quot;);test2.changeTest(test2);System.out.println(&quot;test2.name==&gt;&quot;+test2.name);// kai</code></pre><p>3、这里打印的str 和第一点一样,是main方法中的str </p><pre><code>String str = &quot;xuan&quot;;test2.changeName(str);System.out.println(&quot;str===&gt;&quot;+str);//xuan</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础命令.md</title>
      <link href="/2022/03/20/java-ji-chu-ming-ling/"/>
      <url>/2022/03/20/java-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>首先确定电脑环境变量配置正确<br>1、直接执行class文件</p><p>进入到文件夹里，看到了HelloWorld.class文件。可以直接执行</p><pre><code>java HelloWorld</code></pre><p>2、运行java文件</p><p>cmd进入java文件路径下<br>编译成字节码.class文件 javac HelloWorld.java<br>运行文件，使用-cp参数指定类文件搜索路径 java -cp D:\ajava\test HelloWorld </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识2-比较-==-和-equals().md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-2-bi-jiao-he-equals/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-2-bi-jiao-he-equals/</url>
      
        <content type="html"><![CDATA[<h3 id="的用法"><a href="#的用法" class="headerlink" title="== 的用法"></a>== 的用法</h3><p><strong><code>不推荐</code>== 使用在数值类型之间</strong><br>1、 == 使用在包装类型之间，比较的是引用地址</p><p>java中对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，<code>推荐使用equals方法进行判断</code>。</p><pre><code>Integer a1 = -129;Integer b1 = -129;System.out.println(a1==b1);//falseInteger a2 = 128;Integer b2 = 128;System.out.println(a2==b2);//flase</code></pre><p>2、== 两边如果有一个是基本类型的话，比较的是内容</p><pre><code>Integer a1 = -129;int b1 = -129;System.out.println(a1==b1);//trueInteger a2 = 128;int b2 = 128;System.out.println(a2==b2);//true</code></pre><p><strong>==<code>不推荐</code>使用在String之间</strong><br>因为jvm中存在字符串常量池，String a = “yinkai” 的字符串实际上存在常量池里面。而new String(“yinkai”)在jvm堆内存里；因为==比较的是引用，所以返回false</p><pre><code>String a = &quot;yinkai&quot;;String b = new String(&quot;yinkai&quot;);System.out.println(a == b);//false</code></pre><p>###equals()的用法<br><strong>1、<code>推荐</code>字符串之间的比较使用equals()</strong></p><pre><code>String a = &quot;yinkai&quot;;String b = new String(&quot;yinkai&quot;);System.out.println(a.equals(b));//true</code></pre><p><strong>2、<code>推荐</code>数值类型之间的比较使用equals()</strong></p><pre><code>        /**         * -128  127         */Integer a1 = -129;Integer b1 = -129;System.out.println(a1==b1);//falseSystem.out.println(a1.equals(b1));//trueInteger a2 = -128;Integer b2 = -128;System.out.println(a2==b2);//trueSystem.out.println(a2.equals(b2));//true</code></pre><p><strong>3、<code>推荐</code>Long 与 int 比较时使用equals()是个大坑！</strong><br>看代码：</p><pre><code>   @Test    public  void demo2()&#123;        Integer integer100 = 100;        int int100 = 100;        Long long200 = 200l;        System.out.println(long200.equals(integer100 + int100));    &#125;</code></pre><p>结果输出为false。<br>分析过程：<br>①integer100+int100就会得到一个类型为int且value为200的基础数据类型a<br>②Long的equals方法将a进行装箱，装箱所得到的是类型为Integer的对象b<br>③因为b与long200为不同的类型的对象，所以输出false；</p><p>总结：Long 与 相同值的 包装类 用equals比较时，如果传入的类型不是Long,那么全部返回false</p><p>###结论</p><ul><li>String使用equals()比较</li><li>数值使用equals()比较</li></ul><p>###测试</p><pre><code>  public static void main(String[] args)&#123;        System.out.println(&quot;==========test1========&quot;);        test1();        System.out.println(&quot;==========test2========&quot;);        test2();        System.out.println(&quot;==========test3========&quot;);        test3();        System.out.println(&quot;==========test4========&quot;);        test4();        System.out.println(&quot;==========test5========&quot;);        test5();        System.out.println(&quot;==========test6========&quot;);        test6();        System.out.println(&quot;==========test7========&quot;);        test7();    &#125;    public static void test1()&#123;        Integer m=127;        Integer n=127;        System.out.println(m==n);//true        System.out.println(m.equals(n));//true    &#125;    public static void test2()&#123;        Integer m=127;        int n=127;        System.out.println(m==n);//true    &#125;    public static void test3()&#123;        Integer m=127;        Integer n=new Integer(127);        System.out.println(m==n);//false        System.out.println(m.equals(n));//true    &#125;    public static void test4()&#123;        Integer m=127;        Integer n=Integer.valueOf(127);        System.out.println(m==n);//true        System.out.println(m.equals(n));//true    &#125;    public static void test5()&#123;        Integer m=128;        Integer n=128;        System.out.println(m==n);//false        System.out.println(m.equals(n));//true    &#125;    public static void test6()&#123;        Integer m=128;        int n=128;        System.out.println(m==n);//true    &#125;    public static void test7()&#123;        Integer m=128;        Integer n=new Integer(128);        System.out.println(m==n);//false        System.out.println(m.equals(n));//true    &#125;</code></pre><p>1、int 跟Integer、Integer.valueOf()、new Integer()做==比较时，只比较两者的数值，数值相等即为true.根据这个原则，test2()和test6()都是输出为true;<br>   <code>“==” 等号只要作用在基本类型之上，那么就是比较内容</code></p><p>2、When boxing (transforming int to Integer)the compiler uses a cache for small values (-128 - 127) and reuses the same objects for the same values.<br>在-128-127之间时，包括边界值，Integer m=127,Integer n=Integer.valueOf(127),都会将127装箱成Integer类型，并且m和n共用同一个127的Integer类型。<br>根据这个原则，test1()输出为true,true;</p><p>3、当值不在-128-127之内时，Integer m=128,Integer n= 128或者Integer n=Integer.valueOf(128)，也会将128装箱成Integer类型，但这时不再重用同一个Integer对象，而是各自一个了。此时的Integer<br>m=128或Integer m=Integer.valueOf(128)，都相当于new了一个Integer对象。</p><p>4、当一个int数值用new创建时，无论在不在-128-127之间，都会创建一个Integer对象，而且不会重用</p><p>5、Integer m=数值和Integer m=Integer.valueOf(数值）的效果一样的，两者可以互换。他们在-128-127之内时，会重用Integer,在之外，不会重用。</p><p>看看java.lang.Integer.valueOf(int)方法的源码，就一目了然了。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9347822769ecf43e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识3-数值类型之间的类型转换.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-3-shu-zhi-lei-xing-zhi-jian-de-lei-xing-zhuan-huan/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-3-shu-zhi-lei-xing-zhi-jian-de-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>###java中基本类型数值的取值范围和占用字节<br>要明白java中的类型转换问题必须先要了解java中的各个基本数据类型数值类型的占用字节和取值范围<br>类型| 占用字节|   取值范围<br>-|-|-<br>byte|1字节| -128 ~ 127<br>short| 2字节|-32768 ~ 32767<br>int| 4字节| -2147483648 ~ 2147483647<br>long| 8字节| -9223372036854775808 ~ 9223372036854775807<br>float|    4字节|大约±3.40282347E+38F(6~7位有效数字)<br>double|8字节|大约±1.79769313486231570E+308(15位有效数字)<br>byte==&gt;字节<br>bit==&gt;位<br>关系==&gt;1byte = 8bit</p><pre><code>boolean  8bit/1bytebyte      8bit/1bytechar      16bit/2byteshort     16bit/2bytefloat      32bit/4byteint        32bit/4bytelong      64bit/8bytedouble  64bit/8byte</code></pre><p>###隐式类型转换<br>从表示范围小的类型转换为表示范围大的类型，可以直接转换，称为隐式转换。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9e13e5b4ba06bca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>6个实心箭头箭头表示无信息丢失的转换;</li><li>3个虚箭头表示可能有精度损失的转换.</li></ul><p><strong>无信息丢失的隐式转换</strong></p><ul><li><p>byte==&gt;short</p></li><li><p>short==&gt;int</p></li><li><p>int==&gt;long</p></li><li><p>int==&gt;double</p></li><li><p>float==&gt;double</p></li><li><p>char==&gt;int<br>~~~<br>  public static void main(String[] args) {</p><pre><code>  byte a = 97;  short b = a;//byte==&gt;short  System.out.println(b);//97  int c = b;//short==&gt;int  System.out.println(c);//97  long d = c;//int==&gt;long  System.out.println(d);//97  double e = c;//int==&gt;double  System.out.println(e);//97.0  float f = new Float(97);  double g = f;//float==&gt;double  System.out.println(g);//97.0  char h = &#39;a&#39;;  int i = h;//char==&gt;int  System.out.println(i);//97</code></pre></li></ul><pre><code>&#125;</code></pre><pre><code>**有信息丢失的隐式转换**- int==&gt;float- long==&gt;float- long==&gt;double</code></pre><pre><code>public static void main(String[] args) &#123;    int a = 999999999;    float b = a;//int==&gt;float    System.out.println(b);//1.0E9    long c = 999999999999999999L;    float d = c;//long==&gt;float    System.out.println(d);//9.9999998E17    long e = 999999999999999999L;    double f = e;//long==&gt;double    System.out.println(f);//1.0E18&#125;</code></pre><pre><code>###显式类型转换强制类型转换（显式类型转换），从存储范围大的类型到存储范围小的类型。该类类型转换很可能存在精度的损失。`强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。`</code></pre><pre><code>public static void main(String[] args) &#123;    int a = 127;    byte b = (byte)a;//int==&gt;byte    System.out.println(b);//127    int c = 128;    byte d = (byte)c;//int==&gt;byte    System.out.println(d);//-128 出现精度丢失&#125;</code></pre><pre><code>###运算时会产生精度提升当使用上面两个数值进行二元操作时,先要将两个操作数转换为同一类型,然后再进行计算。规则:两个数中小类型的值将自动转换为大类型的值。小转大可以,但是大转小会损失精度,则需要强制转换。这里的b是byte类型的；`b*3`中，3是int类型。`b*3`精度提升成int类型了。所以这里又赋值给b会报错：`Error:(16, 13) java: 不兼容的类型: 从int转换到byte可能会有损失`,因此需要进行强制转换![image.png](https://upload-images.jianshu.io/upload_images/13965490-75ca29d767944bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>byte b = 127;<br>b=(byte)(b*3);<br>System.out.println(b);//125 出现精度丢失</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识4.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-4/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-4/</url>
      
        <content type="html"><![CDATA[<p><strong>1、++i 和 i++的区别</strong></p><ul><li><p>i++先赋值后增加</p></li><li><p>++i 先增加后赋值</p></li></ul><pre><code>public static void main(String[] args) &#123;    int i = 0;    System.out.println(i++);//0  此时i的值已经为1，i++的返回值只是执行i++之前i的副本    System.out.println(i);//1&#125;public static void main(String[] args) &#123;    int i = 0;    System.out.println(++i);//1  此时i的值为1，++i的值返回值就是i的值    System.out.println(i);//1&#125;</code></pre><ul><li>一个特殊的例子 i=i++;</li></ul><p>执行i++之前i的值的副本为0，副本赋值给i了。那么输出0</p><pre><code>public static void main(String[] args) &#123;    int i = 0;    i=i++;    System.out.println(i);//0  执行i++之前i的值的副本为0，副本赋值给i了。那么输出0&#125;</code></pre><p><strong>2、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</strong></p><ul><li><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-18c3d0bd55fc2f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>有多个punlic类，报错~<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9cd324d70be0e779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>可以没有public类，类名可以不和文件名保持一致<br><img src="https://upload-images.jianshu.io/upload_images/13965490-0aef3498bf11c61b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><ul><li>一个java文件里包含多个类的话，编译一个java文件会生成多个class文件<br><img src="https://upload-images.jianshu.io/upload_images/13965490-9fd9561d1e34aefe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><strong>3、数值类型的错误</strong></p><p>1、float i = 0.1 报错<br>java中出现的浮点小数默认是双精度，因此需要使用double类型来接收~<br><img src="https://upload-images.jianshu.io/upload_images/13965490-205dfe896832492a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>2、Long j = 121321; 报错<br>java中的整数默认是int类型,如果需要直接赋值给Long类型的话。后面需要加一个L;直接赋值给long类型却是正确的！因为存在int到long的隐式类型转换<br><img src="https://upload-images.jianshu.io/upload_images/13965490-7904ccb7806c1db0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>4、&amp;和&amp;&amp;的区别</strong></p><ul><li><p>&amp;&amp;具有<code>短路</code>的功能，即如果第一个表达式为false，则不再计算第二个表达式；例如，对于if(str != null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。</p></li><li><p>&amp;还可以用作<code>位运算符</code>，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 </p></li></ul><p><strong>5、switch语句变量类型</strong></p><ul><li><p>在jdk 1.7 之前，switch 只能支持 byte、short、char、int 这几个基本数据类型和其对应的封装类型。switch后面的括号里面只能放int类型的值，但由于byte，short，char类型，它们会 自动 转换为int类型（精精度小的向大的转化），所以它们也支持。</p></li><li><p>Jdk1.7之后整型、枚举类型，boolean，字符串都可以。</p></li></ul><p><strong>6、char型变量中能不能存贮一个中文汉字？</strong><br>　char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：<code>unicode编码的汉字占用两个字节</code>，所以，char类型的变量也是占用两个字节。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-1adedb499236b9bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  编译后<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c60a0b7762ca4fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>7、使用final关键字修饰一个引用变量时，是引用不能变，还是引用的对象不能变？</strong><br>　使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。<br><img src="https://upload-images.jianshu.io/upload_images/13965490-c5f2e3e9a3b67a12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>8、java中构造对象的几种方式</strong></p><ul><li>用<code>new</code>语句创建对象，这是最常见的创建对象的方法。显式的调用构造函数 </li><li> 运用<code>反射</code>手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li>调用对象的<code>clone()</code>方法。是在内存上对已有对象的影印，所以不会调用构造函数 </li><li>运用<code>反序列化</code>手段，调用java.io.ObjectInputStream对象的 readObject()方法。是从文件中还原类的对象，也不会调用构造函数。</li></ul><p><strong>9、ArrayList list = new ArrayList(20);中的list扩容次数</strong><br>我们知道ArrayList 的初始容量为10，加载因子为0.75，扩容为原来的1.5倍。但是这里构造list的时候传入了20为初始容量，所以不会进行扩容</p><p><strong>10、为什么泛型不可以有基本类型</strong><br>因为Java中的泛型是通过编译时的<code>类型擦除</code>来完成的，当泛型被类型擦除后都变成Object类型。但是Object类型不能指代像int，double这样的基本类型只能指代Integer，Double这样的引用类型。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-基础知识5-新建实例时各部分执行顺序.md</title>
      <link href="/2022/03/20/java-ji-chu-zhi-shi-5-xin-jian-shi-li-shi-ge-bu-fen-zhi-xing-shun-xu/"/>
      <url>/2022/03/20/java-ji-chu-zhi-shi-5-xin-jian-shi-li-shi-ge-bu-fen-zhi-xing-shun-xu/</url>
      
        <content type="html"><![CDATA[<p>我们先来看一个例子</p><pre><code>package test;class HelloA &#123;    public HelloA() &#123;        System.out.println(&quot;父类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 1 执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 2 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 1 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 2 执行&quot;);    &#125;&#125; class HelloB extends HelloA &#123;    public HelloB() &#123;        System.out.println(&quot;子类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;子类实例块 1 执行&quot;);    &#125;     &#123;         System.out.println(&quot;子类实例块 2 执行&quot;);     &#125;    static &#123;        System.out.println(&quot;子类静态块 1 执行&quot;);    &#125;     static &#123;         System.out.println(&quot;子类静态块 2 执行&quot;);     &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;执行 new HelloB()&quot;);        new HelloB();//①        System.out.println(&quot;new HelloB() 执行完毕&quot;);        System.out.println(&quot;===========================&quot;);        System.out.println(&quot;执行 new HelloA()&quot;);        new HelloA();//②        System.out.println(&quot;new HelloA() 执行完毕&quot;);    &#125;&#125;</code></pre><p>####运行结果<br>父类静态块 1 执行<br>父类静态块 2 执行<br>子类静态块 1 执行<br>子类静态块 2 执行<br>执行 new HelloB()<br>父类实例块 1 执行<br>父类实例块 2 执行<br>父类构造器执行<br>子类实例块 1 执行<br>子类实例块 2 执行<br>子类构造器执行<br>new HelloB() 执行完毕<br>===========================<br>执行 new HelloA()<br>父类实例块 1 执行<br>父类实例块 2 执行<br>父类构造器执行<br>new HelloA() 执行完毕</p><p>####上面代码的执行流程可以分析成这样流程<br>父类静态块 &gt; 子类静态块 &gt; main方法开始执行 &gt; 执行 new 子类() ①&gt;执行new 父类()②</p><p>①：父类实例块&gt;父类构造器&gt;子类实例块&gt;子类构造器<br>②：子类实例块&gt;子类构造器</p><ul><li>静态块只执行一次，在main方法之前便执行</li><li>父类静态块在子类静态块之前执行</li><li>多个静态块执行顺序就是定义的顺序，由上到下执行</li><li>多个实例块执行顺序就是定义的顺序，由上到下执行</li><li>实例块在构造方法之前执行</li><li>父类的实例块和构造器在子类的实例块和构造器之前执行</li></ul><p>####误区：<br>  1、在父类静块中访问子类静态属性，只会的到子类静态属性的默认值，因为子类还没有初始化；int类型的默认值是0，所以下面的例子打印出HelloB.i的值为0<br>如：</p><pre><code>class HelloA &#123;    public HelloA() &#123;        System.out.println(&quot;父类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 1 执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 2 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 1 执行&quot;);        int i = HelloB.i;        System.out.println(i);    &#125;    static &#123;        System.out.println(&quot;父类静态块 2 执行&quot;);    &#125;&#125; class HelloB extends HelloA &#123;    static  int i  = 1;    public HelloB() &#123;        System.out.println(&quot;子类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;子类实例块 1 执行&quot;);    &#125;     &#123;         System.out.println(&quot;子类实例块 2 执行&quot;);     &#125;    static &#123;        System.out.println(&quot;子类静态块 1 执行&quot;);    &#125;     static &#123;         System.out.println(&quot;子类静态块 2 执行&quot;);     &#125;    public static void main(String[] args) &#123;    &#125;&#125;</code></pre><p>执行结果：<br>父类静态块 1 执行<br>0<br>父类静态块 2 执行<br>子类静态块 1 执行<br>子类静态块 2 执行</p><p>2、在实例块中访问构造器中赋值的类属性，只会的到实例属性的默认值；</p><pre><code>class HelloA &#123;    public HelloA() &#123;        System.out.println(&quot;父类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 1 执行&quot;);    &#125;    &#123;        System.out.println(&quot;父类实例块 2 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 1 执行&quot;);    &#125;    static &#123;        System.out.println(&quot;父类静态块 2 执行&quot;);    &#125;&#125; class HelloB extends HelloA &#123;    int i ;    public HelloB() &#123;        i = 1;        System.out.println(&quot;子类构造器执行&quot;);    &#125;    &#123;        System.out.println(&quot;子类实例块 1 执行&quot;);        System.out.println(i);    &#125;     &#123;         System.out.println(&quot;子类实例块 2 执行&quot;);     &#125;    static &#123;        System.out.println(&quot;子类静态块 1 执行&quot;);    &#125;     static &#123;         System.out.println(&quot;子类静态块 2 执行&quot;);     &#125;    public static void main(String[] args) &#123;        new HelloB();    &#125;&#125;</code></pre><p>执行结果：</p><p>父类静态块 1 执行<br>父类静态块 2 执行<br>子类静态块 1 执行<br>子类静态块 2 执行<br>父类实例块 1 执行<br>父类实例块 2 执行<br>父类构造器执行<br>子类实例块 1 执行<br>0<br>子类实例块 2 执行<br>子类构造器执行</p><p>3、在静态块中访问实例属性,idea直接报错了<br><img src="https://upload-images.jianshu.io/upload_images/13965490-3422b25d4e1a364d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###静态块执行即类被虚拟机加载<br>什么时候类会被加载？可以看看我的这篇文章<br><a href="https://www.jianshu.com/p/558750148f36">https://www.jianshu.com/p/558750148f36</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-字符串拼接方式-+-、-concat-和-StringBuilder的性能比较.md</title>
      <link href="/2022/03/20/java-zi-fu-chuan-pin-jie-fang-shi-concat-he-stringbuilder-de-xing-neng-bi-jiao/"/>
      <url>/2022/03/20/java-zi-fu-chuan-pin-jie-fang-shi-concat-he-stringbuilder-de-xing-neng-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p>###字符串的concat()方法</p><pre><code>    /**     * Concatenates the specified string to the end of this string.     * &lt;p&gt;     * If the length of the argument string is &#123;@code 0&#125;, then this     * &#123;@code String&#125; object is returned. Otherwise, a     * &#123;@code String&#125; object is returned that represents a character     * sequence that is the concatenation of the character sequence     * represented by this &#123;@code String&#125; object and the character     * sequence represented by the argument string.&lt;p&gt;     * Examples:     * &lt;blockquote&gt;&lt;pre&gt;     * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot;     * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot;     * &lt;/pre&gt;&lt;/blockquote&gt;     *     * @param   str   the &#123;@code String&#125; that is concatenated to the end     *                of this &#123;@code String&#125;.     * @return  a string that represents the concatenation of this object&#39;s     *          characters followed by the string argument&#39;s characters.     */    public String concat(String str) &#123;        int otherLen = str.length();        if (otherLen == 0) &#123;            return this;        &#125;        int len = value.length;        #使用 Arrays.copyOf()扩容        char buf[] = Arrays.copyOf(value, len + otherLen);        #使用 getChars()插入字符        str.getChars(buf, len);        # 使用到了new关键字拼接出来的字符串也是一个新对象        return new String(buf, true);    &#125;</code></pre><p>####concat和+、StringBuild相比的字符串拼接效率如何</p><pre><code>/** * @author ceshi * @Title: * @Package * @Description: * @date 2020/2/218:03 */public class HelloTest &#123;    /**     * 计算concat所用时间     */    public static void str1()&#123;        String s1 = &quot;yinkai&quot;;        String str1 = &quot;&quot;;        long str1Start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000; i++) &#123;            str1 = str1.concat(s1);        &#125;        long str1End = System.currentTimeMillis();        System.out.println(&quot;concat计算时间为：&quot; + (str1End - str1Start)+&quot;  &quot;+str1.length());    &#125;    /**     * 计算+所用时间     */    public static void str2()&#123;        String s2 = &quot;yinkai&quot;;        String str2 = &quot;&quot;;        long str2Start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000; i++) &#123;            str2 = str2 + s2;        &#125;        long str2End = System.currentTimeMillis();        System.out.println(&quot;+计算时间为：&quot; + (str2End - str2Start)+&quot;  &quot;+str2.length());    &#125;    /**     * 计算stringBuilder所用时间     */    public static void str3()&#123;        String s3 = &quot;yinkai&quot;;        String str3 = &quot;&quot;;        long str3Start = System.currentTimeMillis();        StringBuilder stringBuilder = new StringBuilder(str3);        for (int i = 0; i &lt; 100000; i++) &#123;            stringBuilder.append(s3);        &#125;        long str3End = System.currentTimeMillis();        System.out.println(&quot;StringBuilder计算时间为：&quot; + (str3End - str3Start)+&quot;  &quot;+stringBuilder.toString().length());    &#125;    public static void main(String[] args) &#123;        str1();//14036        str2();//52531        str3();//10    &#125;&#125;</code></pre><ul><li>实验结果<br>性能上 StringBuilder &gt; concat &gt; +</li><li>使用建议<br>一两个字符串之间的拼接推荐使用concat ，多了就使用StringBuilder</li></ul><p>+一般用在非字符串和字符串之间的拼接中</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-字符串操作.md</title>
      <link href="/2022/03/20/java-zi-fu-chuan-cao-zuo/"/>
      <url>/2022/03/20/java-zi-fu-chuan-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>###基础使用<br>1、java字符串占位符替换</p><pre><code>java.text.MessageFormat.format(&quot;该域名&#123;0&#125;被访问了 &#123;1&#125; 次.&quot;, domain , iVisit);</code></pre><p>或者使用</p><pre><code>String domain = &quot;www.baidu.com&quot;;int iVisit = 0;System.out.println(String.format(&quot;该域名%s被访问了%s次.&quot;, domain , iVisit));</code></pre><p>注意：常见HTML标签的属性对用法有干扰，此时需要使用转义<br>比如：</p><pre><code>String pattern = &quot;&lt;div class=\&quot;content-img-wrapper\&quot;&gt;&lt;div class=\&quot;content-img\&quot; data-pending=\&quot;false\&quot; data-src=&#123;0&#125; alt=&#123;1&#125; style=\&quot;width: 100%; height: 0px; padding-top: 66.5%; background-image: url(&#123;2&#125;);\&quot;&gt;&lt;/div&gt;&lt;div class=\&quot;content-img-desc\&quot;&gt;&lt;div class=\&quot;triangle\&quot;&gt;&lt;/div&gt;&#123;3&#125;&lt;/div&gt;&lt;/div&gt;&quot;;String format = MessageFormat.format(pattern, &quot;\&#39;http://bai\&#39;&quot;, &quot;\&#39;你好\&#39;&quot;, &quot;\&#39;http://bai\&#39;&quot;, &quot;你好&quot;);System.out.println(format);</code></pre><p>还可以直接：替代方法 相比字符串的格式化操作，使用字符串的替换更加安全，避免因为疏忽或者考虑不全等带来的崩溃问题。 </p><pre><code>String s = &quot;%country%/%city%&quot;.replace(&quot;%country%&quot;, &quot;China&quot;).replace(&quot;%city%&quot;, &quot;Beijing&quot;);</code></pre><p>2、字符串中替换第一个出现的字符</p><pre><code>String join = &quot;hello,hello php&quot;;join = join.replaceFirst(&quot;hello&quot;, &quot;你好&quot;);System.out.println(join);    //输出：你好 java,hello php</code></pre><p>3、数组join成字符串<br>Jdk8的新方法，不用通过数组，直接连接字符串</p><pre><code>String str = String.join(&quot;,&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre><p>当然也提供了重载</p><pre><code>String[] arr = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;String join = String.join(&quot;,&quot;, arr);</code></pre><p>jdk1.8之前都是用apache的commons工具类吧</p><pre><code>org.apache.commons.lang3.StringUtils.join(articleIds,&quot;,&quot;);</code></pre><p>4、字符串前缀和后缀判断<br>如果字符串以指定的前缀开始，则返回 true；否则返回 false。</p><pre><code>String Str = &quot;www.runoob.com&quot;;System.out.print(&quot;返回值 :&quot; );System.out.println(Str.startsWith(&quot;www&quot;) );System.out.print(&quot;返回值 :&quot; );System.out.println(Str.startsWith(&quot;runoob&quot;) );System.out.print(&quot;返回值 :&quot; );System.out.println(Str.startsWith(&quot;runoob&quot;, 4) );</code></pre><p>同样 endsWith 就是针对后缀的方法</p><p>5、大小写转换</p><ul><li>小写转大写<pre><code>String str = &quot;nihao cai xu kun &quot;;String s = str.toUpperCase();System.out.println(s);</code></pre></li><li>大写转小写<pre><code>String str = &quot;NIHAO CAI XU KUN  &quot;;String s = str.toLowerCase();System.out.println(s);</code></pre></li></ul><p>6、字符串非空判断</p><ul><li> null 、“”、 “  ” 都被算为空<pre><code>org.apache.commons.lang3.StringUtils.isBlank(string) </code></pre></li><li>null、”” 为空<pre><code>org.apache.commons.lang3.StringUtils.isEmpty(string) </code></pre></li><li>“” 为空<pre><code>String.isEmpty()</code></pre>7、判断字符串中是否存在某个字符<pre><code>if(&quot;yinkai&quot;.indexOf(&quot;m&quot;) == -1)&#123;          System.out.println(&quot;no exit&quot;);&#125;</code></pre>或<pre><code>if(!&quot;yinkai&quot;.contains(&quot;m&quot;))&#123;     System.out.println(&quot;no exit&quot;);&#125;</code></pre>8、截取字符串</li><li>按字符索引截取<pre><code>String substring = &quot;yin_kai&quot;.substring(4,7);System.out.println(substring);</code></pre></li></ul><p>9、忽略大小写的比较内容</p><pre><code>if(&quot;XXX&quot;.equalsIgnoreCase(&quot;xxx&quot;))&#123;   System.out.println(&quot;yes&quot;);&#125;</code></pre><p>10、把字符串按 “,” 分为字符串数组</p><pre><code>String[] a= &quot;1,2,3,4,5&quot;.split(&quot;,&quot;);for (String s : a) &#123;       System.out.println(s);&#125;</code></pre><p>11、将字符串数组join成字符串</p><pre><code>String[] arr = &#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;&#125;;String join = String.join(&quot;,&quot;, arr);System.out.println(join);</code></pre><p>12、字符串去除空格</p><ul><li>去除首尾空格（只限于半角空格）<pre><code>String trim = &quot; 1 2 &quot;.trim();System.out.println(trim);</code></pre></li><li>去除所有空格（只限于半角空格）<pre><code>String trim = &quot; 1 2 &quot;.replaceAll(&quot; &quot;, &quot;&quot;);System.out.println(trim);</code></pre></li><li>去除所有空格，包括全角空格<pre><code>String trim = &quot; 1 ｄｓ 2 &quot;.replaceAll(&quot;　| &quot;, &quot;&quot;);System.out.println(trim);</code></pre></li></ul><p>13、去除半角空格、回车、换行符、制表符（只限于半角）</p><pre><code>    public static String replaceBlank(String str) &#123;        String dest = &quot;&quot;;        if (str!=null) &#123;            Pattern p = Pattern.compile(&quot;\\s*|\t|\r|\n&quot;);            Matcher m = p.matcher(str);            dest = m.replaceAll(&quot;&quot;);        &#125;        return dest;    &#125;    public static void main(String[] args) &#123;        System.out.println(replaceBlank(&quot;just \n  \t    \t 　do it!&quot;));    &#125;</code></pre><p>14、字符串拼接</p><ul><li>使用 +</li><li>使用 concat方法<pre><code>String concat = &quot;yin&quot;.concat(&quot;kai&quot;);System.out.println(concat);</code></pre></li><li>使用StringBuilder/StringBuffer</li></ul><p>###实用场景<br>1、获取文件后缀</p><pre><code>String orginalFilename = &quot;file.txt&quot;;String substring = orginalFilename.substring(orginalFilename.lastIndexOf(&quot;.&quot;));// 返回 图片 &quot;1.jpg&quot; 的后缀： &quot;.jpg&quot;System.out.println(substring);</code></pre><p>2、截取目标字符串的指定子字符串之后的字符串</p><pre><code>String str=&quot;abcdefg&quot;;System.out.println(str.substring(str.indexOf(&quot;c&quot;)+1));</code></pre><p>3、干掉指定sql字符串中第一个AND</p><pre><code>String sql = &quot;select * from t_customer WHERE AND name=&#39;张三&#39; AND sex=&#39;男&#39; AND station=&#39;百度&#39; AND salary BETWEEN 5001 AND 10000&quot;;String s = org.apache.commons.lang.StringUtils.replaceOnce(sql, &quot; AND&quot;, &quot;&quot;);System.out.println(s);</code></pre><p>###生成字符串</p><p>生成32位的md5摘要</p><pre><code>System.out.println(DigestUtils.md5DigestAsHex(&quot;1234&quot;.getBytes()));</code></pre><p>生成32位的uuid</p><pre><code> String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);</code></pre><p>###字符串转码</p><pre><code>String string = new String(str.toString().getBytes(), &quot;UTF-8&quot;);</code></pre><blockquote><p>GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换：<br>GBK、GB2312－－Unicode－－UTF8<br>UTF8－－Unicode－－GBK、GB2312</p></blockquote><p>GBK转UTF-8</p><pre><code>    public static byte[] getUTF8BytesFromGBKString(String gbkStr) &#123;        int n = gbkStr.length();        byte[] utfBytes = new byte[3 * n];        int k = 0;        for (int i = 0; i &lt; n; i++) &#123;            int m = gbkStr.charAt(i);            if (m &lt; 128 &amp;&amp; m &gt;= 0) &#123;                utfBytes[k++] = (byte) m;                continue;            &#125;            utfBytes[k++] = (byte) (0xe0 | (m &gt;&gt; 12));            utfBytes[k++] = (byte) (0x80 | ((m &gt;&gt; 6) &amp; 0x3f));            utfBytes[k++] = (byte) (0x80 | (m &amp; 0x3f));        &#125;        if (k &lt; utfBytes.length) &#123;            byte[] tmp = new byte[k];            System.arraycopy(utfBytes, 0, tmp, 0, k);            return tmp;        &#125;        return utfBytes;    &#125;    public static void main(String[] args) throws IllegalAccessException, PkiException, InvocationTargetException &#123;        try &#123;            byte[] str = &quot;支持™&quot;.getBytes(&quot;gbk&quot;);            String gbkStr = new String(str, &quot;gbk&quot;);            String utf8 = new String(getUTF8BytesFromGBKString(gbkStr), &quot;UTF-8&quot;);            System.out.println(utf8);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-实现按Map的value排序.md</title>
      <link href="/2022/03/20/java-shi-xian-an-map-de-value-pai-xu/"/>
      <url>/2022/03/20/java-shi-xian-an-map-de-value-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自弃者天弃之</p></blockquote><p>如果要实现按value排序，不能采用SortedMap结构比如TreeMap，因为SortedMap是按key排序的Map，而不是按value排序</p><p>可以使用ArrayList做排序过渡，然后构建一个LinkedHashMap</p><pre><code>package com.springboot.study.demo1;import java.util.*;public class Test &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() &#123;&#123;            put("3", "1");            put("1", "2");            put("2", "3");        &#125;&#125;;        Map sorted1 = sortByValue(map, true);        Map sorted2 = sortByValue(map, false);        System.out.println(sorted1);        System.out.println(sorted2);    &#125;    /**     * 实现map的value排序     *     * @param map     * @param reverse     * @return     */    public static Map sortByValue(Map map, final boolean reverse) &#123;        //将Map转为 List&lt;Map.Entry&gt;        List list = new ArrayList(map.entrySet());        //在 List&lt;Map.Entry&gt; 内部按元素getValue大小排序        Collections.sort(list, new Comparator() &#123;            public int compare(Object o1, Object o2) &#123;                if (reverse) &#123;                    return -((Comparable) ((Map.Entry) (o1)).getValue())                            .compareTo(((Map.Entry) (o2)).getValue());                &#125;                return ((Comparable) ((Map.Entry) (o1)).getValue())                        .compareTo(((Map.Entry) (o2)).getValue());            &#125;        &#125;);        //将有序的List转为 LinkedHashMap，使用LinkedHashMap做插入顺序排序        Map result = new LinkedHashMap(map.size());        for (Iterator it = list.iterator(); it.hasNext(); ) &#123;            Map.Entry entry = (Map.Entry) it.next();            result.put(entry.getKey(), entry.getValue());        &#125;        list = null;        return result;    &#125;&#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13965490-aeac6b12e3b914a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-小技巧1，多表join时。提出类型、部门等在程序中兑换成名字.md</title>
      <link href="/2022/03/20/java-xiao-ji-qiao-1-duo-biao-join-shi-ti-chu-lei-xing-bu-men-deng-zai-cheng-xu-zhong-dui-huan-cheng-ming-zi/"/>
      <url>/2022/03/20/java-xiao-ji-qiao-1-duo-biao-join-shi-ti-chu-lei-xing-bu-men-deng-zai-cheng-xu-zhong-dui-huan-cheng-ming-zi/</url>
      
        <content type="html"><![CDATA[<p>list转map。使用id做key，name做value</p><pre><code>    private Map&lt;String, String&gt; getChannel() &#123;        List&lt;MgbChannel&gt; list = channelService.list(new LambdaQueryWrapper&lt;MgbChannel&gt;().eq(MgbChannel::getDelStatus, DelFlag.EFFECTIVE.getIndex()));        return list.stream().collect(Collectors.toMap(MgbChannel::getChannelKey, MgbChannel::getChannelName, (k1, k2) -&gt; k1));    &#125;    private Map&lt;String,String&gt; getProductCategory() &#123;        List&lt;ProductCategory&gt; list = productCategoryService.list();        return list.stream().collect(Collectors.toMap(ProductCategory::getCatNo, ProductCategory::getCatName, (k1, k2) -&gt; k1));    &#125;</code></pre><p>使用如下：</p><pre><code>    @Override    public GbmResult selectMgbGoodsPage(Page&lt;MgbGoods&gt; page, MgbGoodsDto dto) &#123;        Page&lt;MgbGoodsVo&gt; mgbGoodsVoPage = mgbGoodsMapper.selectMgbGoodsPage(page, dto);        //品类        Map&lt;String, String&gt; productCategoryMap = getProductCategory();        //渠道        Map&lt;String, String&gt; channelMap = getChannel();        List&lt;MgbGoodsVo&gt; records = mgbGoodsVoPage.getRecords();        for (MgbGoodsVo vo:records) &#123;            //获取品类名称            //一级            vo.setCatRootName(productCategoryMap.get(vo.getCatRootNo()));            //二级            vo.setCatParentName(productCategoryMap.get(vo.getCatParentNo()));            //三级            vo.setCatChildName(productCategoryMap.get(vo.getCatChildNo()));            //上架渠道            vo.setChannelName(channelMap.get(vo.getChannelKey()));            //销量            //商品状态            vo.setStateName(MgbGoodsStateEnum.getMsgByIndex(vo.getState()));            //获取0扣点采集价和代发价//            getZeroPointsPrice(vo);        &#125;        return GbmResult.success(new PageBean(mgbGoodsVoPage));    &#125;</code></pre><p>这样就能代替大表的subquery了！！！</p><p>###value为实体类对象</p><pre><code>    /**     * 获取所有供应商名、售后地址，  supplierNo==&gt;supplierName,refundAddress     * @return     */    @Cacheable(value = &quot;getSupplierBySupplierNoMap&quot;)    @Override       public Map&lt;String, Supplier&gt; getSupplierBySupplierNoMap() &#123;        List&lt;Supplier&gt; list = list(new LambdaQueryWrapper&lt;Supplier&gt;().select(Supplier::getSupplierNo, Supplier::getSupplierName,Supplier::getRefundAddress));        return list.stream().collect(Collectors.toMap(Supplier::getSupplierNo, a -&gt; a, (k1, k2) -&gt; k1));    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-工具之Collections中的sort方法如何比较元素？.md</title>
      <link href="/2022/03/20/java-gong-ju-zhi-collections-zhong-de-sort-fang-fa-ru-he-bi-jiao-yuan-su/"/>
      <url>/2022/03/20/java-gong-ju-zhi-collections-zhong-de-sort-fang-fa-ru-he-bi-jiao-yuan-su/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-异常处理思路.md</title>
      <link href="/2022/03/20/java-yi-chang-chu-li-si-lu/"/>
      <url>/2022/03/20/java-yi-chang-chu-li-si-lu/</url>
      
        <content type="html"><![CDATA[<p>什么时候只需打印异常信息，什么时候又需要抛出异常？</p><p>1、影响正常业务流程的异常做抛出自定义异常处理<br>   像是参数非空判断、重要业务文件io流异常、</p><p>2、不影响正常业务流程的异常只需打印一下异常日志<br> 像是 记录操作日志到数据库、删除中间生成的临时文件捕获的异常就是属于这类不影响正常业务流程的！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-异常处理规范.md</title>
      <link href="/2022/03/20/java-yi-chang-chu-li-gui-fan/"/>
      <url>/2022/03/20/java-yi-chang-chu-li-gui-fan/</url>
      
        <content type="html"><![CDATA[<ol><li><p>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj != null) {…} 反例：try { obj.method(); } catch (NullPointerException e) {…} </p></li><li><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。 </p></li><li><p><code>中招</code>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。<code>对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理</code>。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p></li></ol><ol start="4"><li><p><code>中招</code>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p><code>注意</code>【强制】有try块放到了事务代码中，catch异常后（不进行下一步抛出），如果需要回滚事务，一定要注意手动回滚事务。</p></li></ol><ol start="6"><li>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</li></ol><ol start="7"><li><p> <code>注意</code>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p><pre><code>private int x = 0;public int checkReturn() &#123;try &#123;// x等于1，此处不返回return ++x;&#125; finally &#123;// 返回的结果是2return ++x;&#125;&#125;</code></pre></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li></ol><ol start="9"><li>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</li></ol><ol start="10"><li><p><code>注意</code>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p></li><li><p><code>注意</code>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：<br>1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：</p><pre><code>public int f() &#123; return Integer 对象&#125;</code></pre><p>如果为null，自动解箱抛NPE。</p></li></ol><p> 2） 数据库的查询结果可能为null。</p><p> 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。</p><p>4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。</p><p> 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>正例：使用JDK8的Optional类来防止NPE问题。</p><ol start="12"><li>【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。</li></ol><ol start="13"><li>【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error mes