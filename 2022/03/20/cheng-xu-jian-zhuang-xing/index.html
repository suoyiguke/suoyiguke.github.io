<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="想做一个冷漠的人，但又太乐于助人">
    <meta name="baidu-site-verification" content="fmlEuI34ir" />
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48" />
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7" />
    <meta name="description" content="###防止NPE
1、重要 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：

返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。 反例：public int f() { return In">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>尹凯的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">尹凯的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">尹凯的博客</div>
        <div class="logo-desc">
            
            广州番禺职业技术学院 | 自考本科在读
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/suoyiguke" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/suoyiguke" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        <span class="chip bg-color">无标签</span>
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-20
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    尹凯
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    33 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>###防止NPE</p>
<p>1、<code>重要</code> 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p>
<ul>
<li><p>返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p>
<blockquote>
<p>所以，接口的返回值一定使用包装类型！</p>
</blockquote>
</li>
<li><p> 数据库sql查询参数可能为 null。比如in(null) 这是大忌！查询参数中<strong>mybatis_plus</strong> 加前面的布尔值判断非空参数查询 ; 集合就list.stram().fillter(Objects:isNotNull)</p>
</li>
<li><p><code>数据库的查询</code>结果可能为 null。</p>
</li>
<li><p><code>集合</code>里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p>
</li>
<li><p>Map 结构里get元素 可以为null。</p>
</li>
<li><p><strong>RPC、HTTP、webservice 调用</strong> <code>远程调用返回对象时</code>，一律要求进行空指针判断，防止 NPE。</p>
</li>
<li><p>对于 <code>Session</code> 中获取的数据，建议进行 NPE 检查，避免空指针。</p>
</li>
<li><p><code>级联调用</code> obj.getA().getB().getC()；一连串调用，易产生 NPE。<br>正例：使用 JDK8 的 Optional 类来防止 NPE 问题</p>
</li>
</ul>
<p>2、<code>方法的返回值</code>可以为 null，不强制返回空集合，或者空对象等，<strong>必须添加注释充分说明什么情况下会返回 null 值。</strong><br>说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也<br>并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。</p>
<p>3、<code>三目运算</code>符非常容易出现空指针，表达式1和表达式2都会被执行。类似于<code>非短路的|</code><br> condition? 表达式 1 : 表达式 2 中，注意表达式 1 和 2 在类型对齐时，可能抛出因<code>自动拆箱</code>导致的 NPE 异常。</p>
<p>说明：以下两种场景会触发类型对齐的拆箱操作：</p>
<ul>
<li>表达式 1 或表达式 2 的值只要有一个是原始类型。</li>
<li>表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。<br>反例：<pre><code>      Integer a = 1;
      Integer b = 2;
      Integer c = null;
      Boolean flag = false;
      // a*b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常
      Integer result=(flag? a*b : c);
</code></pre>
</li>
</ul>
<p>4、当 <code>switch</code> 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null<br>判断。因为switch 指定条件变量为String时会去调用 hahcode()方法</p>
<blockquote>
<p>直接报空指针异常 Exception in thread “main” java.lang.NullPointerException</p>
</blockquote>
<p>反例：</p>
<pre><code>    public static void main(String[] args) &#123;
        method(null);
    &#125;

    public static void method(String param) &#123;
        switch (param) &#123;
            // 肯定不是进入这里
            case &quot;sth&quot;:
                System.out.println(&quot;it&#39;s sth&quot;);
                break;
            // 也不是进入这里
            case &quot;null&quot;:
                System.out.println(&quot;it&#39;s null&quot;);
                break;
            // 也不是进入这里
            default:
                System.out.println(&quot;default&quot;);
        &#125;
    &#125;
</code></pre>
<p>正例：</p>
<pre><code>
    public static void main(String[] args) &#123;
        method(null);
    &#125;

    public static void method(String param) &#123;
        if(null==param)&#123;
            return;
        &#125;
        switch (param) &#123;
            // 肯定不是进入这里
            case &quot;sth&quot;:
                System.out.println(&quot;it&#39;s sth&quot;);
                break;
            // 也不是进入这里
            case &quot;null&quot;:
                System.out.println(&quot;it&#39;s null&quot;);
                break;
            // 也不是进入这里
            default:
                System.out.println(&quot;default&quot;);
        &#125;
    &#125;
</code></pre>
<p>5、对象非空和对象的属性非空判断一起做，<code>请使用短路的||</code>。避免发生空指针 ！<br>短路或是一真就真，不会再去判断第二个了。若user 为null，执行第二个条件一定会空指针</p>
<p>反例：</p>
<pre><code>      String a = null;
        if(null == a|a.length()==0)&#123;
            System.out.println(&quot;失败&quot;);
        &#125;
</code></pre>
<p>正例：</p>
<pre><code> String a = null;
        if(null == a||a.length()==0)&#123;
            System.out.println(&quot;失败&quot;);
        &#125;
</code></pre>
<p>6、<code>重要</code> 包装类型使用==、+ - * / 进行比较。拆箱导致空指针； 左右一边的对象为null一边的对象为基本类型。<br>会把null进行隐式拆箱导致空指针</p>
<p>它的厉害之处在于我们无法直接观察到空指针，因为光从代码层面看确实“很安全”，但问题发生在“拆箱”，中间隔了一个JDK语法糖，被蒙蔽了。当user.getType()发现自己要和左边的int值比较时，需要拆箱为基础类型。<br>问题代码</p>
<pre><code>if (CommonConstants.USER_TYPE == user.getType()) &#123;
    // ...
&#125;

public class CommonConstants &#123;
    // 他用了int，而不是Integer
    public static final int USER_TYPE = 1;
&#125;
</code></pre>
<p>总之，Integer拆箱底层会调用：intValue()，所以上面的代码编译后近似于：</p>
<pre><code>if (CommonConstants.USER_TYPE == user.getType().intValue()) &#123;
    // ...
&#125;
if (CommonConstants.USER_TYPE == user.getType().intValue()) &#123;
    // ...
&#125;
</code></pre>
<blockquote>
<p>一定要注意。使用 == 进行包装类型之间的判断有两大坏处： 1、数据缓存导致比较结果不正确；2、隐式拆箱导致空指针！<br>请使用 Objects.equals 进行比较;<br>但是Objects.equals也是有坑的！<br><img src="https://upload-images.jianshu.io/upload_images/13965490-655e532281dec040.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</blockquote>
<blockquote>
<p>原理：一个int和一个Integer比较，要么int装箱为Integer，要么Integer拆箱为int，总之要在“同一个水平线”。Objects.equals()选择不改变Integer，而是把int装箱为Integer。int作为基础类型是没有null的，也就不会发生NPE。也就是说，Objects.equals()的思想是：用安全的装箱替代不稳定的拆箱。<br>一定记得加L </p>
</blockquote>
<pre><code> if (Objects.equals(1L, groupListSize)) &#123;
</code></pre>
<p>7、StringBuilder<br>构造器是空不安全的<br>java.lang.StringBuilder</p>
<pre><code>    public StringBuilder(String str) &#123;
        super(str.length() + 16);
        append(str);
    &#125;
</code></pre>
<p>请尽量使用append代替构造器：</p>
<p>new StringBuilder().append(province).append(city).append(area).toString())</p>
<p>8、List里面的元素可能是空，在逐一操作时请使用.filter(Objects::nonNull)，这样写更直观</p>
<pre><code>        List&lt;JqReturnExchange&gt; records = page.getRecords();
        records.parallelStream().filter(Objects::nonNull).forEach(returnExchange -&gt; &#123;
            Integer auditStateInt = Optional.of(returnExchange)
                    .map(JqReturnExchange::getAuditState)
                    .map(AuditState::getCode).orElse(AuditState.TO_BE_APPROVED.getCode());
            returnExchange.setAuditStateInt(auditStateInt);
        &#125;);
</code></pre>
<p>8、分组的判定字段不能为null。<br>反例：<br> saveZskAccessoriesListDoList.stream().collect(Collectors.groupingBy(ZskAccessoriesListDo::getSpu));<br>正例：<br>.stream().filter(m-&gt;ToolUtil.isNotEmpty(m.getSpu())).collect(Collectors.groupingBy(ZskAccessoriesListDo::getSpu));</p>
<p>9、比较器中容易空指针<br>空安全的比较器</p>
<p>userList.sort(Comparator.comparing(User::getId).thenComparing(User::getAge));<br>实际上这个代码有空值安全问题，里面的age字段为null时会报错，如何解决呢？</p>
<p>方法是使用nullsLast或者nullsFirst</p>
<p>就像下面这样</p>
<p>new TreeSet&lt; (Comparator.comparing(ZskAccessoriesListDtoError::getRowNum,Comparator.nullsLast(Integer::compareTo)));</p>
<p>实际上有更简单的写法</p>
<p> new TreeSet&lt;&gt;(Comparator.comparing(ZskAccessoriesListDtoError::getRowNum,Comparator.nullsLast(Comparator.naturalOrder())));</p>
<p>nullsLast、reverseOrder<br>sorted(Comparator.comparing(Rule::getVal,Comparator.nullsLast(Comparator.reverseOrder())))</p>
<p>10、正则表达式匹配容易空指针<br>getPattern().matcher（参数为空报空指针）</p>
<pre><code>    //遍历，全都不包含才返回false || 包含之外的就返回false
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) &#123;
        if (ToolUtil.isEmpty(value)) &#123;
            return true;
        &#125;
        HashSet&lt;Boolean&gt; booleans = new HashSet&lt;&gt;(2);
        StringBuilder stringBuilder = new StringBuilder();
        for (ContainCharEnum containCharEnum : values) &#123;
            booleans.add(containCharEnum.getPattern().matcher(value).find());
            stringBuilder.append(containCharEnum);
        &#125;
</code></pre>
<p>###浮点计算</p>
<p>1、<code>重要</code> 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals来判断。<br>说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。<br>反例：</p>
<pre><code>        float a = 1.0F - 0.9F;
        float b = 0.9F - 0.8F;
        if (a == b) &#123;
            // 预期进入此代码块，执行其它业务逻辑
            // 但事实上 a==b 的结果为 false
            System.out.println(1);
        &#125;
        Float x = Float.valueOf(a);
        Float y = Float.valueOf(b);
        if (x.equals(y)) &#123;
            // 预期进入此代码块，执行其它业务逻辑
            // 但事实上 equals 的结果为 false
            System.out.println(2);

        &#125;
</code></pre>
<p>正例：<br>(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</p>
<pre><code>float a = 1.0F - 0.9F;
float b = 0.9F - 0.8F;
float diff = 1e-6F;
if (Math.abs(a - b) &lt; diff) &#123;
 System.out.println(&quot;true&quot;);
&#125;
</code></pre>
<p>(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。</p>
<pre><code>        BigDecimal a = new BigDecimal(&quot;1.0&quot;);
        BigDecimal b = new BigDecimal(&quot;0.9&quot;);
        BigDecimal c = new BigDecimal(&quot;0.8&quot;);
        BigDecimal x = a.subtract(b);
        BigDecimal y = b.subtract(c);
        if (x.compareTo(y) == 0) &#123;
            System.out.println(&quot;true&quot;);
        &#125;
</code></pre>
<blockquote>
<p>如上所示 BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。<br>说明：equals()方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareTo()则会忽略精度</p>
</blockquote>
<p>2、禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。<br>说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。<br>如：BigDecimal g = new BigDecimal(0.1F); 实际的存储值为：0.10000000149<br>正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了</p>
<pre><code>Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。
 BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;);
 BigDecimal recommend2 = BigDecimal.valueOf(0.1);
</code></pre>
<blockquote>
<p>请使用字符串来构造BigDecimal</p>
</blockquote>
<p>###异常处理篇</p>
<p>1、 <strong>运行时异常不应该被捕获</strong> ,  Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。<br>说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不<br>通过 catch NumberFormatException 来实现。<br>正例：if (obj != null) {…}<br>反例：try { obj.method(); } catch (NullPointerException e) {…}</p>
<p>2、<code>重要</code> 异常捕获后不要用来做流程控制，条件控制。<br>说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多</p>
<blockquote>
<p>不要为了图方便直接使用异常控制程序流程！我亲身经历过因为大量异常抛出捕获打印堆栈信息导致 CPU飙高。这种业务流程方面完全可以不使用异常。</p>
</blockquote>
<p>3、<code>重要</code> catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。<br>说明：对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，<br>这是一种不负责任的表现。<br>正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p>
<blockquote>
<p>不要图方便直接对一大段代码进行全局的try catch，然后统一使用Exception父类接收异常对象。</p>
</blockquote>
<p>4、<code>重要</code> 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请<br>将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的<br>内容</p>
<p>5、事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。<code>或者抛出到上层，这样也能回滚。但是最好手动回滚</code></p>
<p>6、finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。<br>说明：如果 JDK7 及以上，可以使用 try-with-resources 方式</p>
<p>7、<code>重要</code>不要在 finally 块中使用 return。<br>说明：try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存<br>在 return 语句，则在此直接返回，无情丢弃掉 try 块中的返回点。</p>
<p>反例：</p>
<pre><code>private int x = 0;
public int checkReturn() &#123;
 try &#123;
 // x 等于 1，此处不返回
 return ++x;
 &#125; finally &#123;
 // 返回的结果是 2
 return ++x;
 &#125; &#125;
</code></pre>
<p>8、捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br>说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p>
<p>9、<code>重要</code> 在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable<br>类来进行拦截。<br>说明：通过反射机制来调用方法，如果找不到方法，抛出 NoSuchMethodException。什么情况会抛出<br>NoSuchMethodError 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，<br>或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代<br>码编译期是正确的，但在代码运行期时，会抛出 NoSuchMethodError</p>
<blockquote>
<p>Throwable 是Error和Exption的父类</p>
</blockquote>
<p>反例：</p>
<pre><code>    public static void main(String[] args) &#123;
        try &#123;
            throw new Error();
        &#125;catch (Exception e)&#123;
            System.out.println(e);
        &#125;
        System.out.println(&quot;不会执行&quot;);
    &#125;
</code></pre>
<p>正例：</p>
<pre><code>        try &#123;
            throw new Error();
        &#125;catch (Throwable e)&#123;
            System.out.println(e);
        &#125;
        System.out.println(&quot;会被执行&quot;);
</code></pre>
<p>10、catch异常打印异常请使用log.err打印，而不是使用e.printStackTrace(); e.printStackTrace() ，会输出大量堆栈信息，性能非常差。如果频繁调用势必导致cpu飙高。</p>
<p>正例</p>
<pre><code> catch (IOException e) &#123;
            log.error(e.toString(),e);
            log.info(&quot;okHttp.post请求出错了-------------------&gt;&quot;+ url);
        &#125;
</code></pre>
<p>反例</p>
<pre><code>catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
</code></pre>
<p>###其它</p>
<p>1、list、set转 array<br>使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。<br>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现<br>ClassCastException 错误。<br>正例：</p>
<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(2);
list.add(&quot;guan&quot;);
list.add(&quot;bao&quot;);
String[] array = list.toArray(new String[0]);
</code></pre>
<p> 说明：使用 toArray 带参方法，数组空间大小的 length： </p>
<ul>
<li> <strong>等于 0，动态创建与 size 相同的数组，性能最好。</strong></li>
<li>大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。</li>
<li>等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。</li>
<li>大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患</li>
</ul>
<p>2、集合类边遍历边删除一定要使用Iterator迭代器，直接使用for循环会报错</p>
<pre><code>   Iterator&lt;Entry&lt;String, Cache&gt;&gt; it = cacheMap.entrySet().iterator();
        while (it.hasNext()) &#123;
            Entry&lt;String, Cache&gt; next = it.next();
            GuavaCache value = (GuavaCache)  next.getValue();
            if (value.isEmpty(next.getKey())) &#123;
                it.remove();
            &#125;
        &#125;
</code></pre>
<p>3、使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</p>
<p>4、Integer、Long等 类型请使用eques来比较相等<br>因为-128 ~ 127走缓存，这个范围之外的如128就是new实例了，这时候使用==会返回false</p>
<p>7、Bean copy属性性能比较<br>属性copy时各方式的使用场景：</p>
<ul>
<li>对性能要求较高的时候，推荐采用手工方法调用</li>
<li>一般场景推荐使用net.sf.cglib.beans.BeanCopier#copy</li>
<li>如果考虑到引入新jar包的风险时，推荐使用org.springframework.beans.BeanUtils.copyProperties</li>
<li>不可以使用apache家的性能非常差</li>
</ul>
<p>8、比较两个对象使用equals注意要重写 hashcode、和equals方法；<br>另外若一个对象要做Map的key，也需要重写hashcode、和equals方法。否则不唯一</p>
<p>9、equals使用的时候一定左边写常量。避免空指针<br>Object code = (Object)”0”;<br>code.equals(0) 返回false<br>code.equals(“0”) 返回true</p>
<p>为了使语意明确和避免控制针， 判断请改为这样：<br>“0”.equals(code)</p>
<blockquote>
<p>推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b)</p>
</blockquote>
<p>10、list转map时。使用的toMap 请使用 3个参数的，带 BinaryOperator<U> mergeFunction的。这个方法会在key冲突时提供解决办法，而不是直接报错</p>
<pre><code>    public static &lt;T, K, U&gt;
    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,
                                    Function&lt;? super T, ? extends U&gt; valueMapper,
                                    BinaryOperator&lt;U&gt; mergeFunction) &#123;
        return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new);
    &#125;
</code></pre>
<p>反例</p>
<blockquote>
<p>报错 Exception in thread “main” java.lang.IllegalStateException: Duplicate key 12.1</p>
</blockquote>
<pre><code>  String[] departments = new String[]&#123;&quot;iERP&quot;, &quot;iERP&quot;, &quot;EIBU&quot;&#125;;
        Map&lt;Integer, String&gt; map = Arrays.stream(departments)
                .collect(Collectors.toMap(String::hashCode, str -&gt; str));
</code></pre>
<p>正例：(v1, v2) -&gt; v2) 表示，如果发生冲突，则以V2 （后加入的）为准</p>
<pre><code>   String[] departments = new String[]&#123;&quot;iERP&quot;, &quot;iERP&quot;, &quot;EIBU&quot;&#125;;
        Map&lt;Integer, String&gt; map = Arrays.stream(departments)
                .collect(Collectors.toMap(String::hashCode, str -&gt; str,(v1, v2) -&gt; v2));
</code></pre>
<p>11、<code>重要</code> 关于基本数据类型与包装数据类型的使用标准如下：</p>
<ul>
<li>所有的 POJO 类属性必须使用包装数据类型。</li>
<li>RPC 方法的返回值和参数必须使用包装数据类型。</li>
<li>所有的局部变量使用基本数据类型。<br>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或<br>者入库检查，都由使用者来保证。</li>
</ul>
<p>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：某业务的交易报表上显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调<br>用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线-。所以包装数据类型<br>的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p>
<p>12、<code>重要</code> 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。<br>反例：POJO 类的 createTime 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间</p>
<p>13、序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果<br>完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。<br>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>
<p>14、禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法。<br>说明：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到的。</p>
<p>15、使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容<br>的检查，否则会有抛 IndexOutOfBoundsException 的风险。<br>说明：</p>
<pre><code>String str = &quot;a,b,c,,&quot;;
String[] ary = str.split(&quot;,&quot;);
// 预期大于 3，结果是 3
System.out.println(ary.length);
</code></pre>
<p>16、<code>重要</code> 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。<br>说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append<br>操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。<br>反例：</p>
<pre><code>String str = &quot;start&quot;;
for (int i = 0; i &lt; 100; i++) &#123;
 str = str + &quot;hello&quot;;
 &#125;
</code></pre>
<p>17、final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：<br>1） 不允许被继承的类，如：String 类。<br>2） 不允许修改引用的域对象，如：POJO 类的域变量。<br>3） 不允许被覆写的方法，如：POJO 类的 setter 方法。<br>4） 不允许运行过程中重新赋值的局部变量。<br>5） 避免上下文重复使用一个变量，使用 final 关键字可以强制重新定义一个变量，方便更好地进行重构。</p>
<p>18、慎用 Object 的 clone 方法来拷贝对象。<br>说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝，需覆写 clone 方法实现域对象的深度遍历式拷贝。</p>
<p>19、类成员与方法访问控制从严：</p>
<ul>
<li><p> 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 2） 工具类不允许有 public 或 default 构造方法。</p>
</li>
<li><p>类非 static 成员变量并且与子类共享，必须是 protected。 </p>
</li>
<li><p>类非 static 成员变量并且仅在本类使用，必须是 private。</p>
</li>
<li><p> 类 static 成员变量如果仅在本类使用，必须是 private。</p>
</li>
<li><p> 若是 static 成员变量，考虑是否为 final。</p>
</li>
<li><p>类成员方法只供类内部调用，必须是 private。</p>
</li>
<li><p>类成员方法只对继承类公开，那么限制为 protected。</p>
</li>
</ul>
<p>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果<br>是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不<br>得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你<br>会担心的</p>
<p>20、关于 hashCode 和 equals 的处理，遵循如下规则：<br>1） 只要覆写 equals，就必须覆写 hashCode。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写<br>这两种方法。<br>3） 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。<br>说明：String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。</p>
<p>21、<code>重要</code> 判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。<br>说明：在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。<br>正例：</p>
<pre><code>Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);
if(map.isEmpty()) &#123;
 System.out.println(&quot;no element in this map.&quot;);
&#125;
</code></pre>
<p>22、<code>重要</code> 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。<br>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的<br>value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用<br>Map.forEach 方法。<br>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对<br>象；entrySet()返回的是 K-V 值组合集合</p>
<p>23、<code>重要</code> 集合初始化时，指定集合初始值大小。<br>说明：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默<br>认值（16）即可。<br>正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认<br>为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。<br>反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，<br>resize()方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序<br>性能。</p>
<p>24、<code>去重</code> 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的<br>contains()进行遍历去重或者判断包含操作。</p>
<p>25、<code>重要</code> 在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么<br>注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default<br>语句并且放在最后，即使它什么代码也没有。</p>
<blockquote>
<p>说明：注意 break 是退出 switch 语句块，而 return 是退出方法体。</p>
</blockquote>
<p>for循环和switch 嵌套使用：</p>
<ul>
<li><p>break不跳出循环</p>
</li>
<li><p>continue 跳过本次循环<br>如何直接提前结束循环？<br>1、使用return<br>2、使用 continue goto</p>
<pre><code>  public static void main(String[] args) &#123;
      for (int i = 0; i &lt; 3; i++) &#123;
          switch (i)&#123;
              case 1:
                  break;
              default:
                  continue;
          &#125;

          // break不跳出循环
          // continue 跳过本次循环
          System.out.println(&quot;a&quot;);
          
      &#125;

  &#125;
</code></pre>
</li>
</ul>
<p>26、<code>重要</code> List.remove 在数据不存在时会报数组越界。java8有List.removeIf可以代替之<br>正例</p>
<pre><code>   final ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(1);
        list.add(2);
        list.add(3);
        list.removeIf(e-&gt;Objects.equals(e,4));
</code></pre>
<p>set</p>
<pre><code>sSet.removeIf(s -&gt; Objects.equals(s,String.valueOf(OrderErrMsgEnum.COMMODITY_REFERENCE.getState())));
</code></pre>
<p>反例，报错：Exception in thread “main” java.lang.IndexOutOfBoundsException: Index: 4, Size: 3</p>
<pre><code>     final ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(1);
        list.add(2);
        list.add(3);
        list.remove(4);
</code></pre>
<p>27、Map的一个方法computeIfPresent 可以快速完成对value的修改。不用再遍历然后if了</p>
<pre><code>        // 创建一个 HashMap
        HashMap&lt;String, Integer&gt; prices = new HashMap&lt;&gt;();

        // 往HashMap中添加映射关系
        prices.put(&quot;Shoes&quot;, 200);
        prices.put(&quot;Bag&quot;, 300);
        prices.put(&quot;Pant&quot;, 150);
        System.out.println(&quot;HashMap: &quot; + prices);

        // 重新计算鞋加上10%的增值税后的价值
        int shoesPrice = prices.computeIfPresent(&quot;Shoes&quot;, (key, value) -&gt; value + value * 10/100);
        System.out.println(&quot;Price of Shoes after VAT: &quot; + shoesPrice);

        // 输出更新后的HashMap
        System.out.println(&quot;Updated HashMap: &quot; + prices);
</code></pre>
<p>28、截取指定字符的之前的前缀。indexOf会返回-1.这个时候需要做判断。否则substring传入-1报错:<br>正例</p>
<pre><code>           final int index = platformOrderNo.indexOf(&quot;-&quot;);
                if(!Objects.equals(-1,index))&#123;
                    platformOrderNo = platformOrderNo.substring(0, index);
                &#125;
</code></pre>
<p>java.lang.StringIndexOutOfBoundsException: String index out of range: -1<br>###边界值缺失判断</p>
<p>但产品语言与程序语言并不完全等同，直接翻译有时会引发意想不到的BUG。</p>
<p>假设现在有一个需求：<br>● 下单24小时以后，为用户发放奖励</p>
<p>一般来说，我们可以采用定时任务完成这个需求，具体做法是：<br>● 用户下单后，在order_task表插入一条记录（为了方便记忆，type和status都用字符串代替）：</p>
<p>● 定时任务扫描需要发放下单奖励的任务、为用户发放奖励、更新任务状态：</p>
<pre><code># 伪代码 86400=24*60*60
SELECT * FROM order_task WHERE order_type=&#39;complete_order_prize&#39; and task_status=&#39;wait&#39; and gmt_create &lt; now-86400;
</code></pre>
<p>注意时间条件，由于产品需求是下单24小时后才发放奖励，所以要满足条件：</p>
<pre><code>gmt_create &lt; now-86400。
</code></pre>
<p>解决方法是，查询奖励任务时，加一个边界判断：下单24小时后，<strong>且最近3个月内的订单</strong>。</p>
<p>个人建议<br>● 注意边界判断，不要做产品语言的翻译机，要从开发的角度考虑设计是否合理<br>● 养成打日志的习惯有利于问题排查</p>
<blockquote>
<p>这个案例中出错的原因就是只是查询超过24小时没处理的信息，然而现在存在积压的非常久的信息，没有被处理。数量非常之大。所以查询的数量就非常多了。因此需要加一个 <strong>且最近3个月内的订单</strong> 条件。</p>
</blockquote>
<p>###subList的代替方案<br> ArrayList的subList方法，返回的是原集合的一个子集合（视图），修改任意一个集合的元素的值，都会彼此影响；原集合结构性修改（删除或添加元素）时，会报ConcurrentModificationException异常；结构性修改子集合时，会影响原集合，所以使用时要注意，避免程序错误或者异常。</p>
<ul>
<li><p>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异 常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。<br>说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视<br>图，对于 SubList 的所有操作最终会反映到原列表上。</p>
</li>
<li><p>在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p>
</li>
<li><p>对于一个不确定长度的原List，如果你想做以下截取操作：list.subList(0, 5)或者list.subList(2, 5)，当原List长度不满足List.size()&gt;=5时，会抛异常。为了避免误操作，你必须先判断size：</p>
<pre><code>if(list != null &amp;&amp; list.size() &gt;= 5) &#123;
  return list.subList(2, 5);
&#125;
if(list != null &amp;&amp; list.size() &gt;= 5) &#123;
  return list.subList(2, 5);
&#125;
</code></pre>
</li>
</ul>
<p>既然subList那么多问题， 我们可以使用java8提供的新方法来代替subList：</p>
<blockquote>
<p>stream的skip和limit返回的list是一个新的对象。对他操作并不会影响原来的</p>
</blockquote>
<pre><code>        List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
        List&lt;String&gt; limit3 = list.stream().limit(3).collect(Collectors.toList());
        // 超出实际长度也不会报错
        List&lt;String&gt; limit5 = list.stream().limit(5).collect(Collectors.toList());
        List&lt;String&gt; range3_4 = list.stream().skip(2).limit(2).collect(Collectors.toList());
        // 超出实际长度也不会报错
        List&lt;String&gt; range3_5 = list.stream().skip(2).limit(3).collect(Collectors.toList());
        //[a, b, c] [a, b, c, d] [c, d] [c, d]
        System.out.println(limit3 + &quot; &quot; + limit5 + &quot; &quot; + range3_4 + &quot; &quot; + range3_5);
</code></pre>
<p>对比下</p>
<ul>
<li>subList a表示开始索引，b表示结束索引</li>
<li>stream的skip 表示开始索引，b表示长度<pre><code>      List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
      List&lt;String&gt; range3_4 = list.stream().skip(2).limit(2).collect(Collectors.toList());
      //[c, d]
      System.out.println(range3_4);
      //[c, d]
      System.out.println(list.subList(2,4));
</code></pre>
</li>
<li>所以，a和skip 都为0时，两个方法结果是一样的</li>
</ul>
<pre><code> List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
        final List&lt;String&gt; addList1 = list.stream().skip(0).limit(3).collect(Collectors.toList());
        System.out.println(addList1);
        final List&lt;String&gt; addList2 = list.subList(0, 3);
        System.out.println(addList2);
</code></pre>
<p>###List的交差并操作<br>两个list直接进行集合操作，可能大部分人就是想到使用嵌套的for循环来做。这样的代码极不优雅，而且容易出错。</p>
<p>方法1：<br>当然，List本身提供了诸如addAll()、retainAll()、removeAll()等操作，可以很方便的实现并集、交集、差集。所以，上面的去重取并集可以这样：</p>
<p>方法2：<code>重要</code> 使用stream的 filter</p>
<pre><code>        // 前台List
        List&lt;Item&gt; aList = Lists.newArrayList(
                new Item(1, &quot;甲&quot;),
                new Item(2, &quot;乙&quot;),
                new Item(3, &quot;丙&quot;)
        );
        // 后台List
        List&lt;Item&gt; bList = Lists.newArrayList(
                new Item(3, &quot;丙&quot;),
                new Item(99, &quot;对照数据&quot;)
        );

        /**
         * 两个list去重后取并集
         */

        // 对aList进行筛选（bList中不存在的item）
        Map&lt;Integer, Item&gt; bItemMap = bList.stream().collect(Collectors.toMap(Item::getId, v -&gt; v, (v1, v2) -&gt; v1));
        List&lt;Item&gt; filteredAList = aList.stream()
                .filter(aItem -&gt; !bItemMap.containsKey(aItem.getId()))
                .collect(Collectors.toList());

        // 组合去重后的两个List，后台List置顶
        bList.addAll(filteredAList);

        System.out.println(JSON.toJSONString(bList));
</code></pre>
<p>###try-catch 使用注意<br>finally里面请不要写业务逻辑、不要写return，只做资源关闭。或者只写独立的业务。否则容易出现意想不到的问题！</p>
<p>###集合之间无缝切换实现时注意<br>HashMap 用ConcurrentHashMap替换时需要注意 put进去key和value为null时会报空指针</p>
<p>###接收mq消息，接收接口调用消息<br>新添加type时一定要注意兼容老接口请求，老接口可能就是一个json字符串，里面不包含type。<br>否则解析失败，各种打印异常堆栈信息。导致服务宕机！<br>这个坑我掉入过几次了，之前在丰速时就是这样。这次在讯销也有类似问题。</p>
<p>修改接口时只考虑实现功能，没有考虑兼容性了！</p>
<h3 id="Objects-equals坑"><a href="#Objects-equals坑" class="headerlink" title="Objects.equals坑"></a>Objects.equals坑</h3><pre><code>       //fasle
        System.out.println(Objects.equals(1,new Long(1)));
//true
        System.out.println(Objects.equals(1,new Integer(1)));
</code></pre>
<p>基本类型和包装类型比较比较还是得要用 == ，或者Objects.equals只能用在int和Integer直接比较，long和long之间比较！</p>
<p>这种代码就是有问题,注意数据类型1L和1不同</p>
<p>###StringUtils.split的坑<br>请使用apache的而不是spring的</p>
<pre><code>      String[] split1 = org.apache.commons.lang.StringUtils.split(&quot;aaaa,bbbb,cccc&quot;, Constant.COMMA);
        System.out.println(split1.length);
        System.out.println(Arrays.asList(split1));

        String[] split2 = org.springframework.util.StringUtils.split(&quot;aaaa,bbbb,cccc&quot;, Constant.COMMA);
        System.out.println(split2.length);
        System.out.println(Arrays.asList(split2));
</code></pre>
<p>###<code>重要</code>字符串转数值很容易出现格式化错误，因此我们需要提前判断<br> NumberUtil.isInteger(designFormulas) ? Integer.valueOf(designFormulas) : Constant.NUMBER_ZERO;<br>这个问题还可以延伸到json的解析，如果有个不规范的字符串调用了JSON.parse那么也会有转换失败的运行时异常抛出。这个时候如果上层没有try-catch那么将会导致相关业务异常。而且要尽力减少异常的影响面积，比如一个云打印的功能，其中一个图片展示出现了json解析异常。那么仅仅是这个图片显示不出来而不是整个云打印功能都瘫痪！</p>
<p>###接口<br>公开接口需要进行入参保护，尤其是批量操作的接口。<br>反例：某业务系统，提供一个用户批量查询的接口，API 文档上有说最多查多少个，但接口实现上没做任何<br>保护，导致调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。</p>
<p>###查询<br>1、关于配置表或者其它业务表的查询<br>应该要尽量添加where条件。如 is_delete、客户编号、平台编号等。<br>这些条件非常容易忘记添加。这也会导致业务出错。而且查询的结果也会非常大</p>
<p>2、sql注入预防<br>项目里搜索CONCAT(‘%’,’$ 查看使用$的地方。改之</p>
<pre><code>LIKE CONCAT(&#39;%&#39;,&#39;#&#123;zskKnowledgeVo.keyword&#125;&#39;,&#39;%&#39; )
</code></pre>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2022/03/20/cheng-xu-jian-zhuang-xing/" property="cc:attributionName"
               rel="cc:attributionURL">
                尹凯
            </a> 采用
            <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/20/chou-xiang-lei-ke-yi-shi-xian-jie-kou-chou-xiang-lei-ke-yi-ji-cheng-shi-ti-lei/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            抽象类可以实现接口：抽象类实现接口，可以不实现接口的方法。
interface  Inter &#123;
    void print();
&#125;

abstract class GG implements  Inter&#123
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2022-03-20
                        </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/03/20/cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1、从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2022-03-20
                            </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 尹凯的博客<br />'
            + '作者: 尹凯<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>
<!-- 
<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'artDetail',
        blogId: '20962-1585405055583-879',
        name: '因为我是一个人，身为一个人应该做的',
        qrcode: 'https://.com/medias/gzh.jpg',
        keyword: 'VIP',
    });
</script> -->

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2018-2021 YinKai. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">90k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/suoyiguke" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:suoyiguke_yinkai@aliyun.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=2542847562&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    
    <script type="text/javascript" src="/libs/others/snow.js"></script>
    

</body>

</html>